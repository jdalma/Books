
우리가 확인할 기법은 예외를 던지는 대신에 예외 상황이 발생했음을 표현하는 값을 돌려준다는 아이디어를 바탕으로 한다.  
하지만 오류 코드를 사용하는 대신 '값이 정의될 수도 있음'을 표현하는 새로운 제네릭 타입을 도입하고 고차 함수를 사용해 오류를 처리하고 전파하는 일반적인 패턴을 캡슐화 한다.  
우리가 사용할 오류 처리 전략은 **완전히 타입 안전하고, 오류를 강제로 처리하도록 타입 검사기에 의해 전적으로 도움을 받을 수 있으며, 문법적인 잡음도 거의 없다.**  

# 제어 상실

예외를 던지는 식으로 프로그래밍하는 것은 바람직하지 않은 동작이라고하는데, 이 이유는 **제어 상실** 과 연관있다.  
제어 상실은 **예외가 처리되지 않아 프로그램이 중단되거나, 호출 스택의 위에 있는 어떤 코드가 예외를 잡아서 예외를 처리하는 것 중 하나를 뜻한다.**  
  
**에외가 던져지면, 제어가 프로그램의 현재 지점으로부터 벗어난 다른 쪽에 위임되면서 호출 스택을 거슬어 올라가며 전파된다.**  
예외가 함수적인 코드에서 던져지기 위한게 아니라면, 함수형 프로그래밍에서 예외적인 경우를 어떻게 처리할 수 있을까?  
  
큰 아이디어는 **실패와 예외를 일반적인 값으로 표현할 수 있다는 것이다.**  
오류 처리와 복구 패턴을 일반화하는 고차함수를 작성할 수 있으며, **오류를 값으로 반환하는 함수적 해법은 더 안전하다.**  
이 함수적 해법은 참조 투명성을 유지하며, 오류 처리 로직 통합도 유지해준다.  

<h3>예외의 단점</h3>

1. **예외는 참조 투명성을 깨고 문맥 의존성을 만든다.** 이로 인해 치환 모델이 제공하는 단순한 추론을 벗어나며, 혼란스러운 예외 기반의 코드를 작성할 수 있게 된다. 이런 이유 때문에 전통적으로 **예외를 오류 처리에만 사용하고 흐름 제어에는 쓰지 말라는 조언이 있어 왔다.** 함수형 프로그래밍에서는 오류를 회복할 수 없는 극단적인 상황이 아닌 한, **예외를 던지는 일을 피한다.**
2. **예외는 타입 안전하지 않다.** 코틀린에서는 예외를 처리하도록 강요하지 않는다 그리고 예외가 발생하는지 검사하지 않으면 예외가 던져진다는 사실을 실행 시점이 돼서야 감지할 수 있다.

<h3>예외의 장점</h3>

예외를 사용하면 오류 처리 로직을 코드 기반 여기저기에 흩어놓는 대신에 오류 처리 로직을 통합하고 중앙화할 수 있다.  

# 예외에 대한 대안으로 문제가 있는 방법

<h3>센티넬 값</h3>

예외를 던지는 대신에 특정 타입의 값을 반환하는 것이다.  
예를 들어 문제가 발생한 상황에 `Double.NaN` 이런 값을 반환하거나 `null`을 돌려주도록 하는 것이다.  
이런 방법은 예외가 없는 프로그래밍 언어에서 사용한 방법이다.
  
하지만 이 방법은
1. 오류가 조용히 전파될 수 있다. 컴파일러가 이에 대해 경고하지 않으므로 클라이언트 코드에서 조건 검사를 잊어버릴 수 있기 때문에 제대로 작동하지 않을 수 있다.
2. 클라이언트 코드에서 명시적으로 값을 검사해야 하므로 보일러 프레이트 코드가 많이 필요하다.
3. 다형적인 코드에 적용할 수 없다.
4. 호출하는 쪽에서 특정 정책이나 호출 규약을 지키도록 요구한다.

<h3>디폴트 값 제공</h3>

예외를 던지는 방식에 대한 두 번째 대안은 입력을 처리할 수 없는 경우에 돌려줄 디폴트 값을 호출자가 추가 인자로 제공하게 하는 것이다.

```kotlin
fun mean(list: List<Double>, onEmpty: Double) : Double {
    return if (list.isEmpty()) onEmpty
    else list.sum() / list.size
}
```

하지만 이런 경우에는 디폴트 값이 Double로 한정된다는 단점이 있고, 만약 내부 가공 처리가 더 존재할 때는 `onEmpty` 파라미터를 반환하는 것으로 모든 경우의 상태를 클라이언트 코드에게 전달할 수 없을 것이다.  

# Option으로 성공 상황 인코딩하기

이 접근 방법은 **호출하는 쪽으로 오류 처리 전략을 미루는 것이라고 생각할 수 있다.**  
이런 경우를 표현하는 `Option`이라는 새 타입을 도입한다.  
  
```kotlin
sealed class Option<out ITEM: Any> {
    data class Some<out ITEM: Any>(val get: ITEM) : Option<ITEM>()
    data object None: Option<Nothing>()
}

fun mean(list: List<Double>) : Option<Double> =
    if(list.isEmpty()) None
    else Some(list.sum() / list.size)
```

코틀린 표준 라이브러리에서는 `Option`이 쓰인 모습을 볼 수 없지만, 여러 언어나 함수형 라이브러리에서는 볼 수 있다.  
아래는 `Option`이 쓰이는 몇 가지 상황이다.  
이것이 편리한 이유는 **오류 처리 패턴을 고차 함수로 분리할 수 있으므로 예외 처리 코드에 등장하는 일반적인 보일러플레이트 코드를 작성하지 않아도 된다는 점에 있다.**  

1. `getOption`을 사용해 주어진 키를 맵에서 찾는다. 이 함수는 키가 맵에 들어 있으면 값을 `Some`으로 감싸 돌려주고, 키가 들어있지 않으면 `None`을 반환한다.
2. 리스트나 다른 이터러블에 대해 정의된 `firstOrNone`과 `lastOrNone`은 시퀀스가 비어 있지 않을 때 첫 번째 원소나 마지막 원소가 들어 있는 `Option`을 반환한다.

> **널이 될 수 있는 타입과 Option비교**  
> 코틀린은 Option 개념을 도입하지 않기로 결정했다.  
> 코틀린을 만든 이들은 가벼운 wrapper를 인스턴스화하는 것을 성능상 부가 비용이라고 언급한다.  
> **그래서 코틀린에서는 null 값을 다루는 대안을 널이 될 수 있는 타입이라는 개념으로 도입했다.**  

