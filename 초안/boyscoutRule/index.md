---
title: 보이스카웃 규칙 실천하기
date: "2024-05-31"
tags:
   - Refactoring
   - Cleancode
---

엉클 밥이 설명한 [보이스카웃 규칙](https://www.oreilly.com/library/view/97-things-every/9780596809515/ch08.html)을 실천한 경험을 정리해보려 한다.  
편하게 읽고 싶다면 [종립님이 정리한 글](https://johngrib.github.io/wiki/jargon/boy-scout-rule/)을 읽어보자.  

# 첫 번째. 공통 기능을 모아놓은 빈 제거하기

# 두 번째. 절차지향 메소드를 객체로 분리하여 책임 위임하기

# 세 번째. 리플렉션 제거하기

# 네 번째. 라이브러리에 대한 의존성 제한하기

# 결론

2. 리팩토링
   1. 리팩토링할 범위를 정한다.
   2. 그 범위에 해당하는 테스트를 작성한다.
   3. 현재 테스트 범위에서 필요로 하는 의존성을 파악하여 필요한 의존성만 주입한다.
   4. 기존 코드에 대한 테스트 코드를 작성한다.
   5. 리팩토링 작업을 분류한다. 예를 들어, 반환 값을 Map에서 객체로 변환할지, 연산을 추상화할지
      1. 이 작업을 하면서 기존 코드를 분석하게 되는데, 불필요한 연산이나 논리적으로 잘못된 로직을 발견할 가능성이 높다.
3. 문제점
   1. 각 검증 로직에서 공유하는 변수가 존재, (errorReason, validationError)
   2. 논리적으로 의미없는 코드가 존재 `userIdList.filter { !duplicateSet.add(it) }.toMutableSet()`
   3. 검증이 불확실한 코드가 존재 `userRegisterMapper.selectExistCompanyId(userDataList[0].companyId)`
4. getter/setter에 비즈니스 로직이 들어가서 어떤 용도로 호출되는지 알 수가 없다. 직렬화/역직렬화할 때도 호출되어서 메서드를 리팩터링 하기도 힘들다.
   1. 한 가지의 용도로만 사용하거나 직렬화/역직렬화 규칙에 포함되지 않도록 메서드를 작성하는게 좋을 것 같다.
   2. 어떤 setter가 로직에서 명시적으로 한 곳에서 사용중이지만 해당 객체로 역직렬화하는 곳도 해당 setter가 호출되기 때문에 의도된 행위인지 파악하기 힘들다.
   3. getter에 setter 역할을 하는 로직이 들어가는 것도 어떤 의미로 사용되는지 알기 힘들다.
   4. 만약 1 ~ 10까지 연산이 실행될 때 3 정도에서 (getter의 반환값을 사용하지 않으면서) getter를 호출한다고 하면 getter 내부에 있는 setter 로직으로 인해 변화되는 필드들이 3 ~ 10까지에 어떤 역할이 있는지 확인해야 하는 추가 비용이 든다.
5. 웹 요청부터 응답까지 동일한 생명주기를 가진 객체가 있는데, 전반적인 연산 자체가 해당 객체의 속성들을 수정하는 기조이다. 그래서 어떤 메서드 호출 순서를 바꾸기 위해서는 서로 의존하고 있는 필드가 있는지 확인해야 하는 너무 큰 문제가 발생한다.
6. 레거시인 절차지향 코드들을 보면 가능한 DB 조회와 연산을 분리하려 한 것 같은 느낌이 있다.
   1. 대부분 이해가 안가는 코드들은 읽는 사람의 도메인 지식이 작성자와 싱크가 되지 않기 때문인 것 같다.
   2. 불안이라는 책에서 그 사람의 비극(또는 상황)을 알면 그 사람의 상황을 한층 더 이해할 수 있다고 하는데 이 내용이 코드를 작성된 시점 그때의 작성자 상황을 이해하지 못해서 그런 것도 있지 않을까?
7. 클린 코드는 기계적인 원칙이 아닌 탐색의 결과이고 완성은 없다. cleaner code
8. 리팩토링을 진행하면서 느낀점은 작업자가 정한 작업 영역의 기준을 매번 잘 정해야 한다. 이것도 이번 리팩토링에 포함시킬 수 있을까? 그리고 내가 하는 행위가 리팩토링인지 기능 추가인지 의식하고 분리해서 진행해야 한다.