---
title: 보이스카웃 규칙 실천하기
date: "2024-05-31"
tags:
   - Refactoring
   - Cleancode
---

엉클 밥이 설명한 [보이스카웃 규칙](https://www.oreilly.com/library/view/97-things-every/9780596809515/ch08.html)을 실천한 경험을 정리해보려 한다.  
보이스카웃 규칙에 대해서는 [종립님이 정리한 글](https://johngrib.github.io/wiki/jargon/boy-scout-rule/)을 읽어보자.  
  
# 라이브러리에 대한 의존성 제한하기

# 공통 기능을 모아놓은 빈 제거하기

기능 중에 폴더 구조를 가지는 기능을 가진 서비스가 있다.  
어떤 정보들을 프로젝트안에 존재하는 폴더에 저장하는 기능이다. 즉, **한 개의 프로젝트에 N개의 폴더를 생성할 수 있으며 각 폴더에 N개의 정보를 저장하는 것이다.**  

1. 한 프로젝트의 모든 폴더를 조회하는 API
2. 한 프로젝트 안에 폴더를 생성하고 해당 폴더를 조회하는 API

이 두 개의 웹 API가 아래와 같은 의존도를 가지고 있었다.  

![](./commonBeanDeleteBefore.png)

위의 다이어그램을 보면 의아한 점이 생긴다.  

1. **ProjectFolderService와 FolderService, ProjectFolderMapper와 FolderMapper의 차이는 뭘까?**
   1. ProjectFolder와 Folder를 분리할 필요가 없고 동일한 관심사를 가지고 있다고 판단되었다.
2. **CommonUtils는 어떤 공통 기능을 가졌을까?**
   1. 폴더의 재귀 구조를 생성해주는 기능이 구현되어 있었다.
   2. 서로 같은 관심사를 가진 두 개의 Service가 존재하게 되면서 중복되는 코드를 CommonUtils라는 스프링 빈에 작성해놓은 것으로 추측된다.
   3. 이 공통 기능을 가진 빈은 다시 Mapper를 필요로 한다.

공통 기능을 가진 스프링 빈은 의존성을 분리하는 이점이 있긴 하지만 OOP에 전혀 도움이 되지 않으며, 깨진 창문처럼 더 더러워지기 쉬운 이름을 가져서 어정쩡한 책임을 쉽게 묻기 좋은 클래스이다.  
CommonUtils 라는 이름은 죄책감을 가지지 않고 기능을 추가하기 딱 좋은 이름이지 않나?  
  
결론은 **한 개의 관심사에 분리된 책임을 한 곳으로 모으고, 공통 기능을 수행하는 객체를 생성하기로 했다.**  

![](./commonBeanDeleteAfter.png)
  

CommonUtils가 수행하던 기능을 (여러 FolderEntity를 대표하는) `Folders`라는 객체가 수행하도록 수정하였다.  
영속성 계층에서 여러 FolderEntity를 조회한 결과로 **폴더들을 조작하는 책임** Folder객체를 생성하여 CommonUtils를 대신하였다.  

# 절차지향 메소드를 객체,함수로 분리하여 책임 분리하기


# 결론

2. 리팩토링
   1. 리팩토링할 범위를 정한다.
   2. 그 범위에 해당하는 테스트를 작성한다.
   3. 현재 테스트 범위에서 필요로 하는 의존성을 파악하여 필요한 의존성만 주입한다.
   4. 기존 코드에 대한 테스트 코드를 작성한다.
   5. 리팩토링 작업을 분류한다. 예를 들어, 반환 값을 Map에서 객체로 변환할지, 연산을 추상화할지
      1. 이 작업을 하면서 기존 코드를 분석하게 되는데, 불필요한 연산이나 논리적으로 잘못된 로직을 발견할 가능성이 높다.
3. 문제점
   1. 각 검증 로직에서 공유하는 변수가 존재, (errorReason, validationError)
   2. 논리적으로 의미없는 코드가 존재 `userIdList.filter { !duplicateSet.add(it) }.toMutableSet()`
   3. 검증이 불확실한 코드가 존재 `userRegisterMapper.selectExistCompanyId(userDataList[0].companyId)`
4. getter/setter에 비즈니스 로직이 들어가서 어떤 용도로 호출되는지 알 수가 없다. 직렬화/역직렬화할 때도 호출되어서 메서드를 리팩터링 하기도 힘들다.
   1. 한 가지의 용도로만 사용하거나 직렬화/역직렬화 규칙에 포함되지 않도록 메서드를 작성하는게 좋을 것 같다.
   2. 어떤 setter가 로직에서 명시적으로 한 곳에서 사용중이지만 해당 객체로 역직렬화하는 곳도 해당 setter가 호출되기 때문에 의도된 행위인지 파악하기 힘들다.
   3. getter에 setter 역할을 하는 로직이 들어가는 것도 어떤 의미로 사용되는지 알기 힘들다.
   4. 만약 1 ~ 10까지 연산이 실행될 때 3 정도에서 (getter의 반환값을 사용하지 않으면서) getter를 호출한다고 하면 getter 내부에 있는 setter 로직으로 인해 변화되는 필드들이 3 ~ 10까지에 어떤 역할이 있는지 확인해야 하는 추가 비용이 든다.
5. 웹 요청부터 응답까지 동일한 생명주기를 가진 객체가 있는데, 전반적인 연산 자체가 해당 객체의 속성들을 수정하는 기조이다. 그래서 어떤 메서드 호출 순서를 바꾸기 위해서는 서로 의존하고 있는 필드가 있는지 확인해야 하는 너무 큰 문제가 발생한다.
6. 레거시인 절차지향 코드들을 보면 가능한 DB 조회와 연산을 분리하려 한 것 같은 느낌이 있다.
   1. 대부분 이해가 안가는 코드들은 읽는 사람의 도메인 지식이 작성자와 싱크가 되지 않기 때문인 것 같다.
   2. 불안이라는 책에서 그 사람의 비극(또는 상황)을 알면 그 사람의 상황을 한층 더 이해할 수 있다고 하는데 이 내용이 코드를 작성된 시점 그때의 작성자 상황을 이해하지 못해서 그런 것도 있지 않을까?
7. 클린 코드는 기계적인 원칙이 아닌 탐색의 결과이고 완성은 없다. cleaner code
8. 리팩토링을 진행하면서 느낀점은 작업자가 정한 작업 영역의 기준을 매번 잘 정해야 한다. 이것도 이번 리팩토링에 포함시킬 수 있을까? 그리고 내가 하는 행위가 리팩토링인지 기능 추가인지 의식하고 분리해서 진행해야 한다.
