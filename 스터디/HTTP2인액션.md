# 1장 웹 기술과 HTTP

## **브라우저에 www.google.com 이동한다고 가정해 봅시다. 우리가 웹페이지를 볼때까지 어떤 과정을 거쳐서 보이게 되는지 설명해 주세요**

1. 실제 주소의 이름을 DNS 서버로부터 요청한다. IP 주소를 DNS에 질의할 때 탐색을 빠르게 만들려고 가장 가까운 서버의 IP 주소를 제공한다.
2. 웹 브라우저가 전달받은 주소로 표준 웹 포트 `80` 또는 표준 보안 웹 포트 `443`에 IP를 통한 **TCP 연결** 을 요청한다.
   - **Internet Protocol** : 인터넷을 통해 트래픽을 보내는데 사용
   - **Transmission Control Protocol** : 연결을 안정적으로 만드는 안정성과 재전송을 더함
3. 브라우저가 웹 서버와 연결을 맺고 있으면 웹 사이트를 요청하기 시작할 수 있다.
   - 브라우저는 줄여 쓴 웹 주소를 구문적으로 더 올바른 URL 주소로 자동 수정한다.
4. 웹 서버는 요청에 응답한다. 웹 페이지를 만드는 필요한 다른 정보를 참조한다.
5. 웹 브라우저가 반환된 응답을 처리한다. HTML 코드 해석을 시작하고 메모리에 해당 페이지의 문서 객체 모델 DOM을 구축한다.
6. 웹 브라우저가 추가로 필요한 리소스를 요청한다. 각 리소스들은 이 1 ~ 6단계를 거친다.
7. 브라우저가 중요한 리소스를 충분히 얻으면 화면에 페이지를 렌더링하기 시작한다.
   - 언제부터 페이지를 렌더링하기 시작할지 정하는 것은 쉽지 않은 작업이다.
8. 페이지를 처음 표시한 후 웹 브라우저는 백그라운드에서 페이지에 필요한 다른 리소스를 계속 다운로드하고 리소스를 처리하는 대로 페이지를 업데이트 한다.
   - 결과적으로 처음에는 이미지 없이 표시된 웹 페이지를 자주 보게 되고, 더 다운로드 되면 이미지가 채워지는 것을 보게 된다.
9. 페이지가 완전히 로드되면 브라우저는 로딩 아이콘을 멈추고, 자바스크립트 코드에서 페이지가 어떤 동작을 수행할 준비가 됐다는 표시로 사용할 수 있는 `OnLoad` 자바스크립트 이벤트를 발생시킨다.

**이 책은 3번 ~ 8번 단계에 집중한다.** (2번 단계도 언급되긴 한다.)  


- [`AWS` 웹 브라우저에 URL을 입력하면 어떻게 되나?](https://aws.amazon.com/ko/blogs/korea/what-happens-when-you-type-a-url-into-your-browser/)  
- [`널널한개발자` 웹 브라우저에 URL을 입력하면 어떻게 되나?](https://www.youtube.com/watch?v=GAyZ_QgYYYo&list=RDCMUCdGTtaI-ERLjzZNLuBj3X6A&start_radio=1&rv=GAyZ_QgYYYo&t=6&ab_channel=%EB%84%90%EB%84%90%ED%95%9C%EA%B0%9C%EB%B0%9C%EC%9E%90TV)  

## **HTTP가 무엇이고 HTTP/1.1까지 어떻게 진화했는지 설명해 주세요**

하이퍼텍스트 전송 프로토콜을 의미하며, 처음에는 하이퍼텍스트 문서(다른 문서로의 링크를 담은 문서)를 전송할 의도로 만들어졌고, 첫 번째 버전은 이러한 문서만 지원했다.  
하지만 이 프로토콜이 다른 문서 유형(이미지 등)을 전송하는 데 사용될 수 있음을 깨달았다.  
  
**HTTP는 보통 TCP/IP가 제공하는 안정적인 네트워크 연결에 의존한다.**  
TCP/IP는 자체가 어떤 유형의 물리적 연결(이더넷, Wi-Fi 등) 위에 만들어진다.  
통신 프로토콜이 계층으로 나눠졌기 때문에 각 계층은 자신이 잘하는 일에 집중할 수 있다.  
  
**HTTP는 네트워크 연결이 설정되는 방법의 하부 수준 세부 사항을 다루지 않는다.**  
HTTP 어플리케이션이 네트워크 오류와 연결 종료를 어떻게 다룰지를 염두에 둬야 하지만 프로토콜 자체는 이러한 작업을 감안하지 않는다.  
  
**HTTP는 본질적으로 요청 및 응답 프로토콜이다.**  
HTTP의 성공 비결은 서비스 수준에서 비교적 HTTP를 구현하기 쉽게 만들어준 간결함이다.  

1. **HTTP의 첫 버전(0.9)** 은 간단한 문법만 허용했으며 GET 메서드 밖에 없었다.  
   - 캐리지 리턴과 라인피드로 구성된 ASCII 텍스트 한 줄이 전송돼야 한다.
   - 서버는 HTML 형식의 메시지로 응답해야 하며 사양에는 ASCII 문자로된 바이트 스트림으로 정의한다.
   - HTTP 헤더 필드 라는 개념이나 이미지와 같은 다른 미디어의 개념이 없었다.
2. **HTTP/1.0**
   - HEAD와 POST가 추가됐다.
   - 요청받은 리소스와 전송하는 응답에 대한 더 많은 정보를 HTTP 헤더로 제공한다.
   - 3자리 응답 코드가 추가되었다.
   - **본문 데이터의 콘텐츠 유형을 정의하는 데 HTTP 응답 헤더를 사용함으로써 처음으로 웹 피이지에 미디어를 추가할 수 있는 능력을 포함해 웹에 풍부한 새로운 기회를 열었다.**
   - **POST가 추가되면서 컨텐츠가 HTTP 요청의 요소로서 클라이언트에서 서버로 보내지게 하며, 처음으로 HTTP 요청이 HTTP 응답과 같이 본문을 가질 수 있게됐다.**
3. **HTP/1.1**
   - 지속적 연결, 필수 서버 헤더, 개선된 캐싱 옵션, 청크 인코딩 등을 개선하고 프록시 지원 기능, 인증 기능, 새로운 상태 코드, 후행 헤더를 도입했다.
   - PUT, OPTIONS, CONNECT, TRACE, DELETE 등이 추가됐다.
   - 서버가 리소스를 브라우저의 캐시에 저장해서 필요하면 나중에 재사용할 수 있도록 클라이언트에 지시할 수 있다.
   - HTTP가 상태 없는 프로토콜에서 상태를 가질 수 있게 하는 HTTP 쿠키를 도입했다.
   - 지속적인 연결이 TCP 연결을 여러 요청에서 재사용할 수 있게 했고 성능이 향상됐지만, 여전히 기본적으로 **요청-응답 프로토콜** 이다.
   - **HTTP 연결에서 요청 하나가 처리되는 동안 HTTP 연결은 다른 요청에 사용되지 않는다.**


## **HTTP/0.9에서는 줄 바꿈 문자를 하나만 사용해도 되는데 HTTP/1.0부터는 줄바꿈 문자를 2개 써야 합니다. 그 이유에 대해서 설명해 주세요.**

두 개의 캐리지 리턴/줄 바꿈 문자를 끝에 작성해야하는데, 2개를 작성하는 이유는 (두 번째 줄바꿈 문자) **빈 줄을 보내어 요청 헤더 섹션이 끝났다는 것을 표현하기 위해서 이다.**  

## **동일한 형식의 헤더를 여러개 보내면 어떻게 되나요?**

HTTP 헤더는 대소문자를 구분하지 않고, `[헤더 이름]: [헤더 내용]`으로 표시한다.  
동일한 형식의 헤더를 여러 개 보내면 쉼표로 구분한 값을 보내는 것과 의미상 동일하다.  
헤더를 확장할 수 있지만 "수신자가 이러한 필드를 인지할 수 있다고 가정할 수 없으며" 무시 될 수 있다.  
  
**표준 헤더는 HTTP/1.0 호환 서버에서 반드시 처리돼야한다고 명시적으로 서술했다.**  


## **HTTP 응답코드는 2xx(성공), 3xx(리다렉션), 4xx(클라이언트 오류), 5xx(서버 오류)로 분류되어 있습니다. 이렇게 분류되어 있는 이유는 무엇인가요?**

응답 코드가 확장 가능하기 때문에 프로토콜 변경 없이 필요한 만큼 새로운 코드를 추가할 수 있기 때문이다.  
응답 코드는 일반적인 분류로 설계됐고, 가장 적합한 상태 코드를 사용하는 것은 애플리케이션 각자에 달려 있다.  

## **HTTP/1.1에서 Host 헤더가 필수적으로 포함된 이유는 무엇인가요? 필수로 포함되어 생긴 문제는 무엇인가요?**

HTTP 요청 행에서 제공된 URL은 절대 URL (예를 들어, `http://www.example.com/section/page.html`)이 아니라 상대 URL (예를 들어, `/section/page.html`) 이다.  
HTTP가 생성됐을 때는 웹 서버가 하나의 웹 사이트만 호스팅한다고 가정했다. 따라서 URL의 호스트 부분은 사용자가 HTTP 요청을 하기 전에 웹 서버에 연결돼야 하기 떄문에 명확했다.  
하지만 오늘날 많은 웹 서버는 여러 사이트를 동일한 서버애서 호스팅되기 때문에 서버에게 어떤 사이트를 원하는지 구분하기 위해서 이다.  
  
HTTP/1.0에서는 `Host` 헤더가 선택적이지만 HTTP/1.1에서는 필수이다.  
필수로 만든 덕분에 서버가 가상 호스팅을 더 많이 사용할 수 있게 해서 사이트마다 개별 웹 서버를 추가하는 복잡한 작업 없이도 웹의 엄청난 성장을 가능하게 했다.  
HTTP 요청에 `Host` 헤더가 없거나 잘못된 경우 서버가 올바르게 응답할 수 없다는 단점이 있다.  
또한, `Host` 헤더를 조작하면 웹 사이트간의 트래픽을 변조하거나, 피싱 사이트로 리디렉션하는 등의 보안 문제를 일으킬 수 있다. 

## **Connection: Keep-Alive가 생긴 이유는 무엇인가요?**

처음의 HTTP는 단일 요청 및 응답 프로토콜이었다.  
클라이언트가 연결을 맺고, 리소스를 요청하고, 응답을 받으면 연결이 종료됐다.  
이로인해 연결을 항상 다시 맺어야 하므로 연결 종료는 낭비가 되고, 불필요한 지연이 발생했다.  
위의 문제를 해결하기 위해 등장했다.  
대신 응답 본문의 길이를 정의하고자 `Content-Length` HTTP 헤더를 사용해야 하며, 본문을 전부 수신하면 클라이언트는 자유롭게 다른 요청을 보낼 수 있다.  
  
헤더에 `Keep-Alive`를 지정함으로써 클라이언트는 서버에 추가적인 요청 전송을 허용하고자 연결을 맺은 채로 그대로 두라고 요청한다.  
만약 서버가 해당 기능을 지원하는 경우 응답에 헤더에 포함된다.  
HTTP/1.1은 이 기능을 기본값으로 변경했다. 어떤 HTTP/1.1 연결이든 `Connection: Keep-Alive` 헤더가 응답에 없더라도 지속적인 연결을 사용 중이라고 가정할 수 있다.  


## **HTTPS란 무엇이고 어떤 문제 때문에 나오게 되었나요?**

HTTP는 원래 일반 텍스트 프로토콜이기 때문에 HTTP 메시지는 인터넷을 통해 암호화되지 않은 상태로 전송되었기 때문에 메시지가 목적지로 라우팅될 때 모든 참여자가 읽을 수 있다.  
사용자가 보낸 메시지가 인터넷 서비스 제공자로부터 전송되며, **인터넷은 메시지가 라우팅되는 방법을 제어할 수 없으며, 인터넷 사용자는 얼마나 많은 참여자가 사용자의 메시지를 볼지 알 수 없다.**  
HTTP가 일반 텍스트이기 때문에 도중에 메시지를 가로채고, 읽고, 고쳐 쓰기까지 할 수 있다. 이 문제를 해결하기 위해 HTTPS가 등장했다.  
  
**HTTPS는 전송 중의 메시지를 전송 계층 보안 (TLS, Transport Layer Security) 프로토콜을 사용해 암호화하는 HTTP의 보안 버전이다.**  
이전 이름인 보안 소켓 계층 (SSL, Secure Sockets Layer)로도 알려져 있다.  
SSL은 TLS로 표준화 됐으며 TLS는 2018년에 표준으로 승인됐다.  
  
## **HTTPS는 HTTP 메시지에 암호화, 무결성, 인증을 추가했습니다. 각각에 대해 설명해 주세요.**

**암호화** : 메시지는 전송 중에 제 3자에게 읽힐 수 없다.  
**무결성** : 암호화된 메시지가 디지털 서명되고 서명이 복호화되기 전에 암호학적으로 검증되기 때문에 메시지는 전송 중에 변경되지 않는다.  
**인증** : 통신을 하는 주체인 서버와 클라이언트가 서로 믿을 수 있는 주체임이 보장된다.  

## **HTTPS의 키를 교환할 때 공개키 암호화를 통해서 교환하는 이유는 무엇일까요?**

**공유 비밀키를 미리 알고 있을 필요없이 안전하게 웹 사이트와 통신할 수 있도록 하기 위함이다.**  
사용자가 처음 연결할 때 서버가 디지털 인증서 형태의 공개키를 제공한다.  
브라우저는 이 공개키를 사용해 메시지를 암호화한다. 짝이 되는 개인키는 서버만이 가졌으므로 서버에서만 메시지를 복호화할 수 있다.  
  
HTTPS는 암호화,복호화를 제외하고는 기존의 HTTP와 동일하다. (HTTPS는 표준 HTTP 요청 및 응답을 다른 프로토콜로 대체하는 것이 아니라 감싼다.)  
클라이언트와 서버는 TLS 핸드 쉐이킹을 통해
1. 서버는 공개키를 제공
2. 서버와 클라이언트가 암호화 방식에 합의
3. 서버와 클라이언트가 미래에 사용할 공유 암호화 키를 협상

> 공개키 암호화는 느리기 때문에 공개 암호화키는 **공유 비밀키를 협상하는 데만 사용된다.**  
> 공유 비밀키는 더 나은 성능으로 향후의 메시지를 암호화하는 데 사용된다.


## **HTTPS가 동작하는 과정에 대해서 설명해 주세요.**

# 2장 HTTP/2를 향한 여정
- HTTP/1.1의 근본적인 성능 문제란 무엇인가요?
- HTTP/1.1에서 파이프라이닝이 잘 쓰이지 않은 이유는 무엇인가요?
- HTTP/1.1의 성능 문제를 우회해서 해결하는 방법에는 2가지가 있습니다. 1. 여러 HTTP 연결을 사용한다. 2. 적지만 잠재적으로 큰 HTTP 요청을 만든다. 각 해결책에 대해서 설명하고 한계점에 대해서도 설명해 주세요.
- HTTP/1.1에서 브라우저가 도메인 당 요청 수를 6개로 제한한 이유는 무엇인가요?
- HTTP/1.1은 텍스트 기반 프로토콜입니다. 그래서 요청과 헤더도 텍스트 기반인데요. 이로인해 생기는 문제는 무엇인가요?
- HTTP-NG는 실패하고 SPDY는 성공할 수 있었던 이유는 무엇인가요?
- SPDY가 HTTP/1을 어떻게 개선했나요?
- SPDY가 HTTP/2로 표준화된 과정은 무엇인가요?
- 만약 HTTP/2를 적용했는데 성능에 큰 이점이 없었다. 무엇을 의심해봐야 할까?
- HTTP/1.1의 성능 문제를 우회하는 방법이 HTTP/2에서 안티패턴이 되는 이유는 무엇인가요?

# 메모

1. 추가적인 리소스 요청을 더 효율적으로 만드는 것이 주목적인 HTTP/2의 핵심 근거 중 하나다.
2. HTTP/1.1이 파이프라이닝 개념을 추가했고 동일한 지속적인 연결을 통해 여러 요청을 보내고 응답을 순서대로 받을 수 있어야 한다.
   - 예를 들어, 두 개의 파일에 대한 요청을 함께 보내고 응답을 순서대로 받을 수 있어야 한다.
3. HTTPS의 큰 문제점 하나는 상대 서버에 연결 중임을 나타내는 것이지 그 서버를 신뢰할 수 있음을 나타내는 것이 아니라는 것이다.