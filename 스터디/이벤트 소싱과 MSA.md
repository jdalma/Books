
MSA는 모노리스에 대응하는 개념으로 등장했지만, 새로운 개념은 아니다.  
소프트웨어 설계를 이끌어 오던 `"관심사 분리"` 기반의 `"모둘화"`가 그 정점에 이르렀을 뿐이다.  
  
MSA에서 이벤트 기술을 바라보는 다양한 관점이 있다.  
빠른 메시지 송수신, 새로운 로그수집 방식, 단방향 협업, 비동기 메시징, 사건기록방식 정보 관리 등 어떤 관점은 기술이고 어떤 관점은 용도이다.  
하지만 이벤트 기술의 뿌리는 현재의 거래에 초점을 두고, 최종 상태는 계산을 하여 얻는 전통적인 장부기반의 정보관리이다.  
이런 방식은 상태 업데이트 개념 없이 추가에 집중하므로 대용량 거래에서 빠른 성능을 보여주지만 최종 상태를 계산하는 과정이 필요하다.  
최종 상태가 아닌 개별 거래를 중심으로 정보를 관리하도록 설계하는 것을 **이벤트 소싱** 이라고 한다.  
  
**이벤트 소싱은 데이터와 구조적 모델에 기반한 방식과 달리 설계의 중심에 객체가 있어야 하고 이 객체가 풍부한 기능을 제공하면서 서로 협력해야 한다.**  
비즈니스 로직이 없는 전형적인 CRUD로 충분하거나 데이터 일관성과 실시간 갱신이 매우 중요한 경우라면 이벤트 소싱을 적용하기에 신중해야 한다.  

# 1주차 : DDD와 OOP

- **바운디드 컨텍스트를 바라보는 여러 관점**
  - BC를 MSA 단위로 바라보는 관점
  - 애그리게이트를 MSA 단위로 바라보는 관점
- **엔티티와 값 객체**
  - DDD에서 엔티티와 값 객체는 오직 식별방식으로 구분된다.
  - 구현자 마음이다. 결국 선택의 문제
  - **왜 식별이 필요할까?**
    - 라이프사이클이 긴 객체의 변화의 일관성 유지를 위함
    - 해당 객체의 의존성이 여러 곳에 전파되어 참조무결성 유지를 위함
  - **값 객체를 식별하지 않는 이유는 뭘까?**
    - 애그리게이트 경계 내의 객체라서 불변식의 결과이다.
    - 편의상 나눈 데이터이다.
  - 값 객체는 식별되지 않는 독립객체이기 때문에 유지보수비용이 적고, 엔티티는 식별가능하기 때문에 일관성관리가 쉽다.
  - **애그리게이트와 일관성(consistency)**
    - **일관성의 종류**
      - 트랜잭션 일관성 : 연산의 중간 과정과 결과 모두 일관성이 보장됨
      - 결과적 일관성 : 결과적으로는 일관성이 보장되지만 중간에는 그렇지 않은 구간도 발생함
    - **애그리게이트를 보는 관점**
      - 불변식의 단위 (도메인의 사정)
      - 트랜잭션 일관성의 보장 범위 (개발의 사정)
- 불변식은 도메인에서 발견된 변하지 않고 꼭 지켜야 할 규칙이다. 불변식은 도메인에 의해 계속 변경된다.

# 2주차 : 이벤트소싱

- **이벤트를 바라보는 관점**
  - 상황발생 : 런타임에 의도적 혹은 우발적으로 상황이 발생함
  - 사실공유 : 어떤 일이 발생하고, 이 일은 이미 발생했으며 이 사실을 전파하고 싶다.
  - 아 시실을 전달하여 다른 행위를 유발하거나 기록해두고 후에 다른 용도로 사용할 것이다.
  - 이벤트는 어디까지 유발해야하고 행위의 의도를 얼마나 드러내야 할까? 해야할 일을 모두 기술할까? 상황만 기술할까?
- **명령과 이벤트의 차이**
  - 명령은 보다 명시적인 여파를 기술함으로 보다 여파 반영주기가 짧으면서 신뢰성이 더 필요한 경우에 사용한다. (트랜잭션 일관성까지도 사용할 때가 있다)
  - 이벤트는 추상적으로만 기술하고 여파를 해석하는 건 수신측에 보다 재량권을 준다. (결과적 일관성에 많이 사용)
- **커맨드의 멱등성 확보**
  - 등록, 삭제 등 멱등하지 않은 행위를 멱등하게 만드는 방법
    - 키를 먼저 발급받는다 (멱등하지 않은 구간)
    - 키를 갖고 등록, 삭제를 한다 (그 키로는 몇 번을 해도 1번만 일어난다)
  - 즉, **크리티컬한 섹션은 멱등하게 만들고 상대적으로 덜 위험한 키 발급만 멱등하지 않게 분리한다.**
  - 모든 커맨드의 실행이 동시성에서 안전해지려면 멱등해야 한다.
  - 이를 위해 모든 커맨드 생성 시 키를 발급한다.
  - **고유키 발급 주체는 누구로 할 것인가?**
    - 이벤트를 수신할 객체 : 메세지 수신자가 특정되어버린다.
    - 통합 키 발급 객체 : 키 발급소와 수신자 및 이벤트 발급자가 긴밀하게 통신해야한다. (애그리게이트 스토어)

***

# 무지목록
1. 7장에서 설명할 CQRS를 적용해 Cart 서비스에 사용자별 제한 금액을 실시간으로 동기화해 서비스 간 독립성을 높일 수 있다.??
2. MySQL에서 TEXT와 JSON 필드의 차이점
3. 스프링의 `@Cacheable`, `@CachePut`으로 캐싱 알고리즘을 사용한다.
4. 메시지 릴레이 또는 리버스 릴레이는 실행하는 서비스가 다중 인스턴스로 실행되면 안되지 않을까? 그럼 이 릴레이들은 배치 서비스로 한 개의 인스턴스로 처리되도록 격리해야하나?
5. TCP/IP에서 통신 오류가 발생하는 사례는 극히 드물지만, "Best Effort(최선을 다해 전송)"을 목표로 설계한 것이기 때문에 100% 전송되는 것을 신뢰할 수 없다.
   1. TCP/IP의 문제점은? HTTP는 100% 전송을 어떻게 보장하는지?
6. 마이크로서비스 아키텍처에서 분산 트랜잭션을 사용할 수 없다면 어떻게 애그리게이트간 데이터 일관성을 유지할까? 결과적 일관성으로?
7. 분산 트랜잭션을 사용해 일관성을 유지하는 방법에 익숙한 개발자에게 보상 트랜잭션은 기술적으로 수용 불가한 방법일 수 있다.   하지만 도메인 전문가는 일관성을 달성하는데 소요되는 시간에 관대하거나 거의 신경쓰지 않는 경우가 많으므로 충분한 활용 가치가 있다.
   1. 이 말이 많이 와닿았다. 실무에서 나는 심각하게 받아들인 내용을 도메인 전문가는 별 문제 아닌듯이 말한 경험이 있다.