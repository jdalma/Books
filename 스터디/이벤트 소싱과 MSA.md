
MSA는 모노리스에 대응하는 개념으로 등장했지만, 새로운 개념은 아니다.  
소프트웨어 설계를 이끌어 오던 `"관심사 분리"` 기반의 `"모둘화"`가 그 정점에 이르렀을 뿐이다.  
  
MSA에서 이벤트 기술을 바라보는 다양한 관점이 있다.  
빠른 메시지 송수신, 새로운 로그수집 방식, 단방향 협업, 비동기 메시징, 사건기록방식 정보 관리 등 어떤 관점은 기술이고 어떤 관점은 용도이다.  
하지만 이벤트 기술의 뿌리는 현재의 거래에 초점을 두고, 최종 상태는 계산을 하여 얻는 전통적인 장부기반의 정보관리이다.  
이런 방식은 상태 업데이트 개념 없이 추가에 집중하므로 대용량 거래에서 빠른 성능을 보여주지만 최종 상태를 계산하는 과정이 필요하다.  
최종 상태가 아닌 개별 거래를 중심으로 정보를 관리하도록 설계하는 것을 **이벤트 소싱** 이라고 한다.  
  
**이벤트 소싱은 데이터와 구조적 모델에 기반한 방식과 달리 설계의 중심에 객체가 있어야 하고 이 객체가 풍부한 기능을 제공하면서 서로 협력해야 한다.**  
비즈니스 로직이 없는 전형적인 CRUD로 충분하거나 데이터 일관성과 실시간 갱신이 매우 중요한 경우라면 이벤트 소싱을 적용하기에 신중해야 한다.  

# 1주차 : 1장,2장 DDD와 OOP

- **바운디드 컨텍스트를 바라보는 여러 관점**
  - BC를 MSA 단위로 바라보는 관점
  - 애그리게이트를 MSA 단위로 바라보는 관점
- **엔티티와 값 객체**
  - DDD에서 엔티티와 값 객체는 오직 식별방식으로 구분된다.
  - 구현자 마음이다. 결국 선택의 문제
  - **왜 식별이 필요할까?**
    - 라이프사이클이 긴 객체의 변화의 일관성 유지를 위함
    - 해당 객체의 의존성이 여러 곳에 전파되어 참조무결성 유지를 위함
  - **값 객체를 식별하지 않는 이유는 뭘까?**
    - 애그리게이트 경계 내의 객체라서 불변식의 결과이다.
    - 편의상 나눈 데이터이다.
  - 값 객체는 식별되지 않는 독립객체이기 때문에 유지보수비용이 적고, 엔티티는 식별가능하기 때문에 일관성관리가 쉽다.
  - **애그리게이트와 일관성(consistency)**
    - **일관성의 종류**
      - 트랜잭션 일관성 : 연산의 중간 과정과 결과 모두 일관성이 보장됨
      - 결과적 일관성 : 결과적으로는 일관성이 보장되지만 중간에는 그렇지 않은 구간도 발생함
    - **애그리게이트를 보는 관점**
      - 불변식의 단위 (도메인의 사정)
      - 트랜잭션 일관성의 보장 범위 (개발의 사정)
- 불변식은 도메인에서 발견된 변하지 않고 꼭 지켜야 할 규칙이다. 불변식은 도메인에 의해 계속 변경된다.

# 2주차 : 3장,4장 이벤트소싱

- **이벤트를 바라보는 관점**
  - 상황발생 : 런타임에 의도적 혹은 우발적으로 상황이 발생함
  - 사실공유 : 어떤 일이 발생하고, 이 일은 이미 발생했으며 이 사실을 전파하고 싶다.
  - 아 시실을 전달하여 다른 행위를 유발하거나 기록해두고 후에 다른 용도로 사용할 것이다.
  - 이벤트는 어디까지 유발해야하고 행위의 의도를 얼마나 드러내야 할까? 해야할 일을 모두 기술할까? 상황만 기술할까?
- **명령과 이벤트의 차이**
  - 명령은 보다 명시적인 여파를 기술함으로 보다 여파 반영주기가 짧으면서 신뢰성이 더 필요한 경우에 사용한다. (트랜잭션 일관성까지도 사용할 때가 있다)
  - 이벤트는 추상적으로만 기술하고 여파를 해석하는 건 수신측에 보다 재량권을 준다. (결과적 일관성에 많이 사용)
- **커맨드의 멱등성 확보**
  - 등록, 삭제 등 멱등하지 않은 행위를 멱등하게 만드는 방법
    - 키를 먼저 발급받는다 (멱등하지 않은 구간)
    - 키를 갖고 등록, 삭제를 한다 (그 키로는 몇 번을 해도 1번만 일어난다)
  - 즉, **크리티컬한 섹션은 멱등하게 만들고 상대적으로 덜 위험한 키 발급만 멱등하지 않게 분리한다.**
  - 모든 커맨드의 실행이 동시성에서 안전해지려면 멱등해야 한다.
  - 이를 위해 모든 커맨드 생성 시 키를 발급한다.
  - **고유키 발급 주체는 누구로 할 것인가?**
    - 이벤트를 수신할 객체 : 메세지 수신자가 특정되어버린다.
    - 통합 키 발급 객체 : 키 발급소와 수신자 및 이벤트 발급자가 긴밀하게 통신해야한다. (애그리게이트 스토어)

# 3주차 : 5장 마이크로서비스 협업

- REST 통신의 에러 처리
  - 404 : '없다'가 상태의 일부라면 같은 로직을 처리해야하는 클라코드가 상태로 분기해야됨
  - 400 : 인자가 잘못된 경우는 다양함. 밸리데이션에 걸리기도 하지만 DB정합성 문제나 심지어 서버가 의존하는 외부 자원의 문제일 수도 있음
  - 500 : 너무 포괄적인 에러가 되어버림. 409, 422등의 상황과 분리하기 어려움
- **어댑터에 어느 정도의 지식 소유의 재량권이 주어져야 할까?**
  - 완전 일치 하는 경우 → `this.cartService.queryCart(id)`
  - 지식을 포함하는 경우 → `this.cartService.queryCart(id).findItem()`
    - queryCart가 반환하는 Cart의 `findItem`을 호출해야 하는 것이 생각해야 할 지점이다.
    - 만약 `this.cartService.queryCartFindItem(id)` 으로 처리했으면 어댑터가 알아야 할 정보는 줄어드는 것이 맞다.
- **발행 구독 모델**
  - 옵저버 패턴과 달리 채널에 발행하거나 채널을 구독한다.
  - 옵저버 패턴은 옵저버가 서브젝트를 알고 있다. 즉, 서브젝트가 존재하지 않으면 옵저버가 존재하지 않는다.
  - 발행 구독 모델의 핵심은 채널(카프카의 토픽)이다. 채널에 발행하고 채널을 구독하는 것이 옵저버 패턴과 큰 차이이다.
  - **채널은 쉽게 처음부터 존재할 수 있기 때문에 발행자와 구독자의 생성 순서 문제가 발생하지 않는다.** 
  - 여러 발행자가 채널에 참여할 수 있고 여러 구독자가 채널에 참가하여 비동기적으로 통신할 수 있다.
  - **발행 구독 모델의 주인공은 발행자, 구독자가 아니라 채널이 주인공이다.**
    - 구독자가 발행자를 아는가 모르는가?
    - 발행된 메세지가 구독자 전체에게 소비되는가? 특정 구독자에게만 소비되는가?
    - 채널은 발행된 메세지를 어떤 방식으로 전파하는가? (릴레이? 선착순?)
    - 새로 참가하는 구독자는 어디까지의 기존 메세지를 수신하는가?
- **REST 아웃바운드의 장단점**
  - REST 프로토콜을 한 번 더 포트로 끼워넣기 때문에 직접 참조를 피하고 변화의 충격흡수층이 하나 더 생김
  - 여전히 구체적인 아웃바운드 대상을 알아야 한다.
    - 게이트웨이 뿐만 아니라 이 비즈니스 로직에 의존하는 서비스를 다 알아야 한다.
    - 이는 거시적으로 의존성 방향이 잘못되게 만든다.
    - 즉, 개별 아웃바운드 대상에 대한 의존성이 생겨버린다.
  - **최대한 의존성을 제거하려면 "남이 나를 의존하도록 만들면 된다"**
    - 채널에 메세지만 발행하는 것으로서 대상을 모르게 한다.
    - 발행할 메세지의 규격을 자신이 정하고 외부 의존성이 제거된다. 의존성 역전이라고 볼 수 있다.
- **254p TransformedEvent**
  - 메시지 릴레이가 자기 마음대로 메시지 스펙을 정한 경우 → 수신측에서 스펙을 알아서 변환해야 한다.
  - 메시지 릴레이가 수신자의 사정을 아는 경우 → 이벤트 브로킹의 의미가 사라지고 수신자 의존성이 발생한다.
- **토픽(채널)의 선택은 릴레이 권한인가?**
  - 릴레이 권한인 경우 → 릴레이를 목적에 따라 사용하며, 외부에서 릴레이 정책만 알면된다. 릴레이가 도메인을 모르기 때문에 기능적인 토픽만 쓴다.
  - 이벤트 권한인 경우 → 도메인이 이벤트를 생성하므로 도메인 목적에 맞는 토픽을 사용한다. 수신측에서도 풍부한 도메인 수준의 토픽을 수신하게 된다.
- **이벤트를 수신했을 때**
  - 카프카 메세지를 역직렬화하는 클래스 타입을 수신자는 어떻게 알고 있나?
    - 발행자가 수신자 타입에 맞춘 경우 : 수신자 의존성 발생
    - 수신자가 발행자 타입에 맞춘 경우 : 정상
  - 이벤트 수신의 실질적인 멱등성 확보방법은 메세지의 고유 ID이다.

# 4주차 : 6장 결과적 일관성

- **트랜잭션의 범위**
  - 애그리게이트는 불변식의 단위이다. 불변식을 어기는 CRUD는 처음부터 이뤄지면 안되며, 항상 불변 상태가 유지되어야 한다.
  - 인메모리에서 불변 상태를 유지해야 한다. 모든 메소드에 불변식을 무조건 적용하고, 특수한 모델에 불변식을 적용한 setter로 구현한다.
  - 레포에서 불변 상태를 유지하기 위해 관계형 구조를 포기하고 루트 엔티티로 외의 모든 서브 데이터를 VO화하여 관리한다.
    - 레포 수준의 트랜잭션 지원을 이용하여 관리한다.
  - 트랜잭션은 어쩔 수 없을 때만 사용한다. 각 불변식 그룹의 범위를 최대한 축소한다.
  - **언젠가 만족되면 되는지, 아니면 항상 적용될 불변식인지 구분해야 한다.**
- **애그리게이트 간 일관성**
  - **애그리게이트는 상시 불변식이 유지되어야 한다.**
  - 애그리게이트 간에는 언젠가(결과적으로) 일관성이 유지되면 된다.
  - 실제 상시 불변식이 필요한 경우는 없을때가 많다.
- **분산 트랜잭션**
  - 애그리게이트 간 (여러 분산된 서비스들의 협력하에) 트랜잭션을 달성하는 것이다.
  - 이 분산 트랜잭션은 대부분 성골할것이라는 낙관적 관점에 기반한다.
  - 이 낙관성(성공률)을 높이는 로직이 필요하다. 주로 트랜잭션 대상을 좁히고 분할하거나 사본을 통해 전개하게 변경한다.
  - 이를 관리하는 여러 패턴과 각 패턴에 따른 솔루션이 존재한다. (트랜잭션 타워)
    - 오케스트레이션 엔진 : 넷플릭스 콘덕터, 템포랄, 카문다 등
    - 분산 트랜잭션 관리 : 2PC 계열, Axon, NServiceBus
    - 워크플로 오케스트레이터 : 에어플로, 카문다, 템포랄
    - 프로세스 매니저 : 특정 애그리게이트를 중심으로 전개 (이 책에서 설명하는 내용)
- **사가 패턴**
  - 결과적 일관성은 언젠가 된다는 것이다.
  - '오케스트레이션'과 '코레오그래피'처럼 통제 방식으로 분류할 수도 있고, '순차성'과 '병렬성(원자성)'처럼 트랜잭션 내 태스크로 전개 분류를 할 수 있다.
  - **오케스트레이션**
    - 단점 : 통제 책임을 가진 객체(모듈)이 트랜잭션 레시피를 모두 알고 있어야 하기에 단일 실패점이 존재한다.
    - 장점 : 범용적인 MSA는 드물고 수 많은 MSA가 참가하는 경우도 거의 없다. 의존성이 많아지긴 하겠지만 한 곳에 모을 수 있기에 퍼사드화하는게 관리상 유리하다. 이 책에서 소개하는 프로세스 매니저 정도의 책임을 뜻한다.
  - **코레오그래피**
    - 단점 : MSA가 이벤트에만 '일반화(추상화)'에 의존하고 대응해야하며 모든 로그를 본인이 책임져야 한다. 구현하기가 어려워 실패할 가능성이 높다.
    - 장점 : 진정한 의미의 분산화와 병렬성이 광범위하게 확보된다. 의존성이 낮아지고 범용적으로 활용 가능하다.
- **메세지를 기반으로 해야하나?**
  - 대부분의 MSA는 대부분 REST API만으로 구현한다.
  - 가용성은 게이트웨이 및 서비스 매시로 해결된다.
  - 코루틴 또는 리액티브를 비롯한 비동기처리로 오케스트레이션 사가패턴을 해결할 수 있다.
- 이 책에서는 리버스 릴레이가 적용된 이후에 로컬 이벤트로 전환되어 스프링 이벤트를 사용한다.

***

# 무지목록
1. 7장에서 설명할 CQRS를 적용해 Cart 서비스에 사용자별 제한 금액을 실시간으로 동기화해 서비스 간 독립성을 높일 수 있다.??
2. MySQL에서 TEXT와 JSON 필드의 차이점
3. 스프링의 `@Cacheable`, `@CachePut`으로 캐싱 알고리즘을 사용한다.
4. 메시지 릴레이 또는 리버스 릴레이는 실행하는 서비스가 다중 인스턴스로 실행되면 안되지 않을까? 그럼 이 릴레이들은 배치 서비스로 한 개의 인스턴스로 처리되도록 격리해야하나?
5. TCP/IP에서 통신 오류가 발생하는 사례는 극히 드물지만, "Best Effort(최선을 다해 전송)"을 목표로 설계한 것이기 때문에 100% 전송되는 것을 신뢰할 수 없다.
   1. TCP/IP의 문제점은? HTTP는 100% 전송을 어떻게 보장하는지?
6. 마이크로서비스 아키텍처에서 분산 트랜잭션을 사용할 수 없다면 어떻게 애그리게이트간 데이터 일관성을 유지할까? 결과적 일관성으로?
7. 분산 트랜잭션을 사용해 일관성을 유지하는 방법에 익숙한 개발자에게 보상 트랜잭션은 기술적으로 수용 불가한 방법일 수 있다.   하지만 도메인 전문가는 일관성을 달성하는데 소요되는 시간에 관대하거나 거의 신경쓰지 않는 경우가 많으므로 충분한 활용 가치가 있다.
   1. 이 말이 많이 와닿았다. 실무에서 나는 심각하게 받아들인 내용을 도메인 전문가는 별 문제 아닌듯이 말한 경험이 있다.
8. 이벤트로 다른 서비스와 협력하게되면 트랜잭션의 범위안에서 다른 서비스의 응답을 기다리는 경우가 많을 것 같은데.. 커넥션을 오래 잡고 있어 문제가 발생하는 일은 없을까?
9. 클린 아키텍처에서 중복된 코드를 진짜 중복과 우발적 중복으로 분류하고 중복을 제거할 때 주의해야 함을 설명한다.
10. gson도 프로토콜 버퍼를 사용한다?