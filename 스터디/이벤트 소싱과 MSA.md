
MSA는 모노리스에 대응하는 개념으로 등장했지만, 새로운 개념은 아니다.  
소프트웨어 설계를 이끌어 오던 `"관심사 분리"` 기반의 `"모둘화"`가 그 정점에 이르렀을 뿐이다.  
  
MSA에서 이벤트 기술을 바라보는 다양한 관점이 있다.  
빠른 메시지 송수신, 새로운 로그수집 방식, 단방향 협업, 비동기 메시징, 사건기록방식 정보 관리 등 어떤 관점은 기술이고 어떤 관점은 용도이다.  
하지만 이벤트 기술의 뿌리는 현재의 거래에 초점을 두고, 최종 상태는 계산을 하여 얻는 전통적인 장부기반의 정보관리이다.  
최종 상태가 아닌 개별 거래를 중심으로 정보를 관리하도록 설계하는 것을 **이벤트 소싱** 이라고 한다.  
이런 방식은 상태 업데이트 개념 없이 추가에 집중하므로 대용량 거래에서 빠른 성능을 보여주지만 최종 상태를 계산하는 과정이 필요하다.  
  
**이벤트 소싱은 데이터와 구조적 모델에 기반한 방식과 달리 설계의 중심에 객체가 있어야 하고 이 객체가 풍부한 기능을 제공하면서 서로 협력해야 한다.**  
비즈니스 로직이 없는 전형적인 CRUD로 충분하거나 데이터 일관성과 실시간 갱신이 매우 중요한 경우라면 이벤트 소싱을 적용하기에 신중해야 한다.  

# 1주차 : DDD와 OOP

- **바운디드 컨텍스트를 바라보는 여러 관점**
  - BC를 MSA 단위로 바라보는 관점
  - 애그리게이트를 MSA 단위로 바라보는 관점
- **엔티티와 값 객체**
  - DDD에서 엔티티와 값 객체는 오직 식별방식으로 구분된다.
  - 구현자 마음이다. 결국 선택의 문제
  - **왜 식별이 필요할까?**
    - 라이프사이클이 긴 객체의 변화의 일관성 유지를 위함
    - 해당 객체의 의존성이 여러 곳에 전파되어 참조무결성 유지를 위함
  - **값 객체를 식별하지 않는 이유는 뭘까?**
    - 애그리게이트 경계 내의 객체라서 불변식의 결과이다.
    - 편의상 나눈 데이터이다.
  - 값 객체는 식별되지 않는 독립객체이기 때문에 유지보수비용이 적고, 엔티티는 식별가능하기 때문에 일관성관리가 쉽다.
  - **애그리게이트와 일관성(consistency)**
    - **일관성의 종류**
      - 트랜잭션 일관성 : 연산의 중간 과정과 결과 모두 일관성이 보장됨
      - 결과적 일관성 : 결과적으로는 일관성이 보장되지만 중간에는 그렇지 않은 구간도 발생함
    - **애그리게이트를 보는 관점**
      - 불변식의 단위 (도메인의 사정)
      - 트랜잭션 일관성의 보장 범위 (개발의 사정)
- 불변식은 도메인에서 발견된 변하지 않고 꼭 지켜야 할 규칙이다. 불변식은 도메인에 의해 계속 변경된다.

***

# 무지목록
1. 7장에서 설명할 CQRS를 적용해 Cart 서비스에 사용자별 제한 금액을 실시간으로 동기화해 서비스 간 독립성을 높일 수 있다.??