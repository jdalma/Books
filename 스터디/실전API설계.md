# 메모

- [Swagger Hub](https://app.swaggerhub.com/search?type=API&owner=designing-apis)
- [연습](https://app.swaggerhub.com/apis/jeongdalma/practice-mini/1.0.0#/default)
- Open API는 YAML 기능 중에서 JSON 스키마 형식에 맞는 기능만 사용한다. 그래서 OpenAPI는 YAML의 여러 데이터 타입 중에서 JSON이 지원하는 데이터 타입만 사용할 수 있으며 그 외의 타입은 사용할 수 없다.
- 스웨거 2.0, OpenAPI 3.0, OpenAPI 3.1이 존재하며, 3.1은 아직 안정적이지 않아 이 책은 3.0을 기준으로 학습한다. 다행이 3.0과 3.1의 차이는 2.0과 3.0의 차이만큼 크지는 않다.
- [스웨거 에디터](https://editor.swagger.io/)는 Open API 정의서 작성을 도와주는 도구이며, 온라인 서비스를 사용할 수도 있고 직접 자체 웹 서버에 호스팅하여 사용할 수도 있다. 
- [OpenAPI로부터 포스트맨 정의하기](https://learning.postman.com/docs/integrations/available-integrations/working-with-openAPI/)
- [포스트맨으로부터 OpenAPI 정의하기](https://blog.postman.com/creating-an-openapi-definition-from-a-collection-with-the-postman-api/)
- OpenAPI 문서가 상세한 프로토콜을 기술한다고 해도 여전히 description 부분에서 사람이 충분히 읽을 수 있는 정보로 재기술 되어야 한다!!!

# API 설계의 특수성

- **API는 다른 서비스를 개발하기 위한 중간 제품** 즉, API의 고객은 B2B 고객이라는 것이다.
   1. API는 헤드리스 서비스(프론트 없이 API만 제공하는 서비스)로서 API 그 자체가 상품이라는 것이다.
   2. 핵심은 백엔드 REST API가 전부가 아니라는 것이다. API 스펙을 발표하고 해당 API가 어디로 팔려나가는 정도의 상품을 생각해야 한다.
- **API 변화는 그 API를 사용한 모든 서비스에 문제를 발생 시킴**
   1. 상품으로서의 API는 다른 회사의 손익구조에 영향을 많이 끼친다.
- **API 설계 원칙**
   1. 협업 : 다양한 이해관계자들의 충분한 합의 (다수가 동의한 것)
   2. 성과 : 가치, 도메인을 중심에 둘 것 (쓸모있는 것)
   3. 기술 : 기술 선택은 용도에 맞출 것 (기술 중심이 아닐 것)
   4. 약속 : API는 고객과의 약속, 큰 책임을 고려할 것 (신중히 설계, MVP 방식은 통하지 않는다.)
   5. **문서** : **무엇보다 문서가 우선될 것** 즉, 실체는 코드가 아니라 문서라는 것!!!
      1. 어떤 기술로 개발되어 있는지 상관없다. API 문서에 나와았는 입출력에만 의존한다.
- **문서 작성 흐름**
   1. 개발 중심 흐름 : 개발부터하고 그 결과를 문서로 생성함, 개발이 변경되면 자동 생성기가 문서를 변화시킴
      1. 코드가 문서를 만들어내는 것은 잘못됐다!!! 그 반대의 흐름을 만들어내야 한다.
   2. **API설계 원칙 흐름** : 5대 원칙에 근거하여 API 문서를 먼저 작성하는 것
- **문서 작성 기본 요령**
   1. ADDR 프로세스에 따라 (DDD의 여러 기법 동원, 유저스토리매핑, 작업스토리, 스토리스토밍, 유즈케이스, 예제매핑 등)
      1. 도메인 분석을 통한 작업 스토리 추출 및 디지털 기능 식별
      2. 작업 스토리별 액티비티 단계 캡쳐
      3. 이벤트스토밍의 네러티브를 이용한 API 경계 식별 (애그리거트 분리)
      4. 식별된 바운디드컨텍스트 내의 구체적인 개별 API 정의
      5. REST 구조에 맞는 실제 설계

> 즉, API 문서를 작성하는 것은 **실제 도메인을 파악하고 시장성 있는 기능이 무엇인지 분석하는 과정**

애플리케이션 계층에서는 클래스로 도메인을 표현하고, 데이터베이스 계층에서는 테이블로 도메인을 표현한다.  
애플리케이션 구현 방법에 따라 클래스와 테이블을 수동으로 변환할 수도 있고 ORM 같은 자동화 체계를 사용할 수도 있다.  
**API는 자신의 도메인 모델을 가진 세 번째 계층이라고 볼 수 있다.**  

# 멱등성

- 한 번 실행하나 여러 번 실행하나 똑같다.
- **멱등의 장점** (순수한 함수형 프로그래밍의 장점과 같음)
  - 순서나 횟수를 무시하기 때문에 안적정이다.
  - 복잡한 조합으로 결과를 만들지 않아 동작을 예측하기 쉽다.
- **비멱등한 부분만 격리하여 최소화하고 나머지는 멱등하게 만들기**
  - 대부분 일부가 비멱등하기 때문에 **비멱등한 부분만 비멱등 API로 빼고 나머지를 멱등 API화함**
  - 예를들어 게시물을 등록할 때 게시물에 해당하는 키를 발급받아 한 번만 등록을 허용하여 이후부터는 무시하도록 설정하면 멱등으로 변한다.
- **비멱등한 API가 생기는 근본적인 이유는 상태 때문이다.**
  - 도메인은 if로 이루어진 덩어리이며, 상태는 이 도메인에 의해 결정된다.
- 보안(인증/인가)는 비멱등이다.
  - 키를 삽입할 수 있는 HTTP 사양 상의 장소 : 쿠키, 헤더, 쿼리스트링, 요청 본문도 가능하지만 GET,DELETE는 본문이 없다.

# 모델이란?
- 현실 세계의 복잡한 실체를 필요한 부분만 남긴 것
- 분야 == 바운디드 컨텍스트 == 엔티티 == 에그리거트 == 관련된 상태모음
- **모델은 끝없이 갱신하고 검토하고를 반복해야 한다.**

# JSON 스키마

OpenAPI는 표준 JSON 스키마를 약간 조정해서 사용하기 때문에 표준 JSON 스키미와 OpenAPI에서 사용하는 JSON 스키마의 차이점이 존재한다는 것을 알아야한다.  
예를 들어,

2. JSON 스키마에서는 여러 타입을 지정할 수 있지만, OpenAPI에서는 오직 하나의 타입만 지정 가능하다.
   1. 예를 들어, `type: [ number, string, null ]`과 같은 방법은 OpenAPI에서 사용할 수 없다.
   2. 대신에 Open API에서 nullable 키워드로 널 허용 여부 지정은 필요하기 때문에 추가됐다.

  
**데이터는 주어진 스키마에 대해 유효할 수 있고 유효하지 않을 수 있기 때문에 결국 데이터에 대한 검증이 핵심이다.**  
  