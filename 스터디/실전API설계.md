# 메모

- [Swagger Hub](https://app.swaggerhub.com/search?type=API&owner=designing-apis)
- [연습](https://app.swaggerhub.com/apis/jeongdalma/practice-mini/1.0.0#/default)
- **Open API 정의서의 스키마는 도메인 모델의 속성과 관계를 표현한 것이다.**
- Open API는 YAML 기능 중에서 JSON 스키마 형식에 맞는 기능만 사용한다. 그래서 OpenAPI는 YAML의 여러 데이터 타입 중에서 JSON이 지원하는 데이터 타입만 사용할 수 있으며 그 외의 타입은 사용할 수 없다.
- 스웨거 2.0, OpenAPI 3.0, OpenAPI 3.1이 존재하며, 3.1은 아직 안정적이지 않아 이 책은 3.0을 기준으로 학습한다. 다행이 3.0과 3.1의 차이는 2.0과 3.0의 차이만큼 크지는 않다.
- [스웨거 에디터](https://editor.swagger.io/)는 Open API 정의서 작성을 도와주는 도구이며, 온라인 서비스를 사용할 수도 있고 직접 자체 웹 서버에 호스팅하여 사용할 수도 있다. 
  - 온라인 버전 [스웨거 코드젠](https://generator.swagger.io/)이 존재한다.
  - [OpenAPI로부터 포스트맨 정의하기](https://learning.postman.com/docs/integrations/available-integrations/working-with-openAPI/)
  - [포스트맨으로부터 OpenAPI 정의하기](https://blog.postman.com/creating-an-openapi-definition-from-a-collection-with-the-postman-api/)
- OpenAPI 문서가 상세한 프로토콜을 기술한다고 해도 여전히 description 부분에서 사람이 충분히 읽을 수 있는 정보로 재기술 되어야 한다!!!
- 결국 프로젝트에 관여도, 기여도가 높은 사람이 리딩하게 된다. 그러려면 당연하게도 자기가 재밌어하거나 잘하고 싶은 욕심이 있어야 한다.
  - 하고 싶은 일을 하면 자연스럽게 잘해질 것이고, 일이 재미가 없다면 그 일을 못 해서 그렇다.
- URL에는 소문자만 사용하는 것이 좋다. 호스트 이름은 대소문자를 가리지 않지만 경로는 대소문자를 가린다. 따라서 **하이픈으로 묶어서 사용하는 케밥 케이스를 사용하여 모두 소문자를 사용하면 이런 혼란을 없앨 수 있다.**

# API 설계의 특수성

- **API는 다른 서비스를 개발하기 위한 중간 제품** 즉, API의 고객은 B2B 고객이라는 것이다.
   1. API는 헤드리스 서비스(프론트 없이 API만 제공하는 서비스)로서 API 그 자체가 상품이라는 것이다.
   2. 핵심은 백엔드 REST API가 전부가 아니라는 것이다. API 스펙을 발표하고 해당 API가 어디로 팔려나가는 정도의 상품을 생각해야 한다.
- **API 변화는 그 API를 사용한 모든 서비스에 문제를 발생 시킴**
   1. 상품으로서의 API는 다른 회사의 손익구조에 영향을 많이 끼친다.
- **API 설계 원칙**
   1. 협업 : 다양한 이해관계자들의 충분한 합의 (다수가 동의한 것)
   2. 성과 : 가치, 도메인을 중심에 둘 것 (쓸모있는 것)
   3. 기술 : 기술 선택은 용도에 맞출 것 (기술 중심이 아닐 것)
   4. 약속 : API는 고객과의 약속, 큰 책임을 고려할 것 (신중히 설계, MVP 방식은 통하지 않는다.)
   5. **문서** : **무엇보다 문서가 우선될 것** 즉, 실체는 코드가 아니라 문서라는 것!!!
      1. 어떤 기술로 개발되어 있는지 상관없다. API 문서에 나와았는 입출력에만 의존한다.
- **문서 작성 흐름**
   1. 개발 중심 흐름 : 개발부터하고 그 결과를 문서로 생성함, 개발이 변경되면 자동 생성기가 문서를 변화시킴
      1. 코드가 문서를 만들어내는 것은 잘못됐다!!! 그 반대의 흐름을 만들어내야 한다.
   2. **API설계 원칙 흐름** : 5대 원칙에 근거하여 API 문서를 먼저 작성하는 것
- **문서 작성 기본 요령**
   1. ADDR 프로세스에 따라 (DDD의 여러 기법 동원, 유저스토리매핑, 작업스토리, 스토리스토밍, 유즈케이스, 예제매핑 등)
      1. 도메인 분석을 통한 작업 스토리 추출 및 디지털 기능 식별
      2. 작업 스토리별 액티비티 단계 캡쳐
      3. 이벤트스토밍의 네러티브를 이용한 API 경계 식별 (애그리거트 분리)
      4. 식별된 바운디드컨텍스트 내의 구체적인 개별 API 정의
      5. REST 구조에 맞는 실제 설계

> 즉, API 문서를 작성하는 것은 **실제 도메인을 파악하고 시장성 있는 기능이 무엇인지 분석하는 과정**

애플리케이션 계층에서는 클래스로 도메인을 표현하고, 데이터베이스 계층에서는 테이블로 도메인을 표현한다.  
애플리케이션 구현 방법에 따라 클래스와 테이블을 수동으로 변환할 수도 있고 ORM 같은 자동화 체계를 사용할 수도 있다.  
**API는 자신의 도메인 모델을 가진 세 번째 계층이라고 볼 수 있다.**  

# 멱등성

- 한 번 실행하나 여러 번 실행하나 똑같다.
- **멱등의 장점** (순수한 함수형 프로그래밍의 장점과 같음)
  - 순서나 횟수를 무시하기 때문에 안적정이다.
  - 복잡한 조합으로 결과를 만들지 않아 동작을 예측하기 쉽다.
- **비멱등한 부분만 격리하여 최소화하고 나머지는 멱등하게 만들기**
  - 대부분 일부가 비멱등하기 때문에 **비멱등한 부분만 비멱등 API로 빼고 나머지를 멱등 API화함**
  - 예를들어 게시물을 등록할 때 게시물에 해당하는 키를 발급받아 한 번만 등록을 허용하여 이후부터는 무시하도록 설정하면 멱등으로 변한다.
- **비멱등한 API가 생기는 근본적인 이유는 상태 때문이다.**
  - 도메인은 if로 이루어진 덩어리이며, 상태는 이 도메인에 의해 결정된다.
- 보안(인증/인가)는 비멱등이다.
  - 키를 삽입할 수 있는 HTTP 사양 상의 장소 : 쿠키, 헤더, 쿼리스트링, 요청 본문도 가능하지만 GET,DELETE는 본문이 없다.

# 모델이란?
- 현실 세계의 복잡한 실체를 필요한 부분만 남긴 것
- 분야 == 바운디드 컨텍스트 == 엔티티 == 에그리거트 == 관련된 상태모음
- **모델은 끝없이 갱신하고 검토하고를 반복해야 한다.**

# JSON 스키마

OpenAPI는 표준 JSON 스키마를 약간 조정해서 사용하기 때문에 표준 JSON 스키미와 OpenAPI에서 사용하는 JSON 스키마의 차이점이 존재한다는 것을 알아야한다.  
예를 들어,

2. JSON 스키마에서는 여러 타입을 지정할 수 있지만, OpenAPI에서는 오직 하나의 타입만 지정 가능하다.
   1. 예를 들어, `type: [ number, string, null ]`과 같은 방법은 OpenAPI에서 사용할 수 없다.
   2. 대신에 Open API에서 nullable 키워드로 널 허용 여부 지정은 필요하기 때문에 추가됐다.

  
**데이터는 주어진 스키마에 대해 유효할 수 있고 유효하지 않을 수 있기 때문에 결국 데이터에 대한 검증이 핵심이다.**  
  
# 세 가지 유형의 엔드포인트

**리소스**는 도메인 모델에 있는 개념의 개별 인스턴스다.  
이 개별 리소스를 가리키는 URL을 **리소스 엔드포인트** 라고 한다.  
리소스 목록을 가리키는 URL을 **컬렉션 엔드포인트** 라고 한다.  
컬렉션에서 특정 리소스들만 찾고 싶을 때는 쿼리 파라미터로 요청할 수도 있지만, 하위 디렉토리를 의미하는 **서브리소스 컬렉션 엔드포인트** 를 사용할 수도 있다.  
예를 들어, 특정 사용자의 Job을 가지고 올 때 `GET /jobs?user_id={user_id}`가 아니라 `GET /users/{user_id}/jobs`로 요청하는 것이다.  
  
조회를 서브리소스 컬렉션 엔드포인트를 사용하면 생성 API도 `POST /jobs`가 아니라 `POST /users/{id}/jobs`를 사용해야 한다고 생각할 수 있다.  
하지만 일반적으로 **CRUD 방식으로 API를 설계할 때는 서브리소스 경로 사용을 최소화하고 가능한 한 짧은 경로를 사용하는 것이 바람직하다.**  
서브리소스 경로를 사용해야만 했던 유일한 이유는 **짧은 경로를 사용하면 다른 행위와 충돌이 발생할 수 있기 때문이다.**  

> **컬렉션 엔드포인트에서 반환할 리소스가 없어도 왜 404를 반환하면 안되는가?**  
> 리소스 엔드포인트를 통해 자원을 조회할 때 해당 자원이 있으면 200, 없으면 404를 반환한다.  
> 하지만 컬렉션 엔드포인트는 해당 자원이 없더라도 항상 200을 반환한다.  
> **반환할 데이터가 아예 존재하지 않는 것이 아니라 컬렉션이 비어있을 뿐 컬렉션 자체는 존재하기 때문이다.**  
> 즉, 바구니가 비어있는것이지 바구니가 없는 것은 아니라는 것이다.

일반적으로 아래와 같이 사용한다.  

|**연산**|**상태 코드**|**응답 본문**|
|:------:|:---:|:---|
|생성|201|비어 있고 Location 헤더 반환|
|읽기|200|리소스 또는 컬렉션을 포함하는 객체|
|수정|200|리소스|
|삭제|204|비어 있음|

> **Login 행위는 사용자 정보를 보여주는 읽기 행위와는 분명히 다르다.**  
> 떄로는 CRUD 패러다임에서 벗어나 다른 방식으로 연산을 설계할 필요가 있다.  
> `POST /users/login` 또는 `POST /users/action/login` 이라고 많이들 정하긴 하지만, **세션은 웹 애플리케이션에서 사용되는 개념이므로 도메인 모델에도 포함해보면 어떨까?**  
> 도메인 모델에 세션 개념을 추가하면 Login 행위도 CRUD 동사에 매끄럽게 연결된다.  
> 

# API 설계 우선 방식 (또는 계약 우선 방식)

1. **API 정의서에 대해 신뢰할 수 있는 단일 진실 출처** : main 브랜치를 공식 단일 진실 출처로 지정한다.
2. **변경을 제안하는 방법과 변경에 동의하는 방법** : 풀 리퀘스트를 사용한다.
3. **변경 내용을 비교할 수 있는 방법** : 이해관계자가 각자의 브랜치를 main 브랜치와 비교하며 유지 관리한다.