
1. [x] **2장. 생성 패턴 사용하기**
   1. object 키워드를 통해 싱글톤 객체를 선언하거나, 클래스 내에서 `companion` 키워드와 함께 사용하여 정적 메서드를 모아놓기 위한 동반 객체를 만들 수도 있다.
   2. `apply()` 함수는 객체의 상태를 변경한 뒤에 그 객체를 반환하고자 할 때 사용한다.
2. [x] **3장. 구조 패턴 이해하기**
3. [x] **4장. 동작 패턴과 친해지기**


# 1주차 : 객체 생성 패턴, 구조 패턴

- **싱글톤과 Enum 클래스의 관계**
  - 서비스 전체 라이프사이클에서 인스턴스가 1개만 계속 생존해야하는 경우
  - 상태를 갖지 않게 하거나 동시성에 대한 대비를 할 것
  - JVM 플랫폼에서 원천적으로 안전한 싱글톤 객체는 Enum이다
  - 전역 수준에 선언된 변수와 함수도 전부 싱글톤이다
- **팩토리 메서드**
  - 타입은 모든걸 규정할 수 있지만 유일하게 불가능 한 것이 생성자를 추상화할수는 없다.
  - JVM 플랫폼에서 팩토리 메서드 패턴이 계속 필요한 이유가 생성법을 추상화할 방법이 없기 떄문이다.
  - `KFunctionX`를 이용해서 `::클래스` 형식을 통해 생성자를 함수로 치환할 수 있긴 하다.
- **정적 팩토리 메서드**
  - 코틀린 생성자는 일반 함수에 비해 2가지 제약 조건이 있음
    - suspend로 생성할 수 없음
    - refied 제네릭을 사용할 수 없음
  - 이 제약을 피하려면 정적 팩토리를 제공하는 수 밖에 없다. *정적 팩토리 메서드로 팩토리를 만들어보기*
- **추상 팩토리 메소드**
  - 어떤 객체를 생성할 때 의존성있는 다른 객체도 생성해야만 만들어낼 수 있는 경우가 있다.
  - 의존관계 객체 사이에 라이프사이클 문제가 가장 어려운 문제이다.
  - 경우에 따라 팩토리만으로는 해결할 수 없고 DI로 발전되기도 한다.
  - 빌더와 추상 팩토리 메소드는 문제를 해결하는 방식이 서로 비슷하다. 그래서 모든 팩토리 계열의 패턴은 결국 빌더로 통합되고 있다.
- **빌더와 DSL, value class**
  - 빌더는 의존관계의 객체 주입, 속성 설정, 초기화, 특정 절차 수행 등 모든걸 포함할 수 있다.
  - 대부분의 객체 생성 시
    - **속성 설정** : 밸리데이션 등을 통해 정합성을 검사해야 한다.
    - **의존객체** : 그 객체를 얻는 방법, 라이프사이클을 맞추는 법 등
    - **절차** : 순서를 강제하는 것은 매우 어려운 일이다.
  - **빌더란 복잡한 헬퍼 객체를 동원해 위의 3가지 규칙을 어길 수 없게 디자인하는 모든 것이다.**
- **데코레이터**
  - 기능을 추상화하여 인터페이스를 생성한다.
  - 이 추상화된 기능을 개별 타입이 구현한다.
  - 결국 어떤 도메인을 협력할 수 있는 작업으로 나눌 수 있고 그 작업들을 관통하는 추상화(일반화)를 할 수 있다면 데코레이터 패턴을 쓸 수 있다.
  - 데코레이터는 큰 결과물에 참여자가 나름대로 기여하는 **기여모델** 과 자기가 해보고 아니면 패스하는 **게이트 모델** 이 존재한다.
- **브릿지**
  - 합성을 통해 상속조합 폭발을 피할 수 있다.
  - 합성객체란? 외부에서 해당 객체의 API가 타입에 따라 모두 노출되어 있는 객체. 예를 들어, 계층관계를 가진 객체를 합성객체라고 볼 수 있다.
  - 필드로 다른 객체들을 주입받은 객체는 집합객체라고 볼 수 있다.
  - `class StormTrooper(weapon: Weapon, leg: Leg): Weapon by weapon, Leg by leg` 처럼 인터페이스 위임으로 간단히 해결된다.
  - 만약 Weapon과 Leg가 서로 협력한다면 퍼사드라고 볼 수 있다.
- **코틀린 리플렉션**


# 2주차 : 구조 패턴, 동작패턴

1. **합성 패턴과 방문자 패턴**
   1. 합성 패턴을 그냥 쓰면 너무 한정적이라 방문자 패턴이랑 같이 쓰는게 좋다.
   2. 합성 패턴은 어떤 도메인을 요소(element)의 조합으로 바라볼 수 있다면 사용 가능하다.
2. **합성 패턴의 구성 요소란?**
   1. 같은 추상화를 구상한 하위타입
   2. 구성요소 추상층에서 수행해야 하는 일을 기술한다.
3. 이터레이터와 컴포지트는 순회를 추상화하는데 집중하고 비지터는 순회할 때 실행을 집중한다. [예제](https://github.com/jdalma/kotlin-playground/blob/main/src/main/kotlin/_50_DesginPatterns/behavioral/Composite%26Visitor.kt)
4. **프록시와 플레이스홀더**
   1. 프록시는 외부에서 보기에 대리인지 실체인지 구분이 안된다.
   2. 플레이스홀더는 홀더(실체) 부분이 명확히 분리되어 공개되어 있다.
   3. 플레이스홀더는 클라이언트에게 자신을 사용하는 책임을 모두 전가한다. 플레이스홀더는 책임을 지지 않는다.
5. **문의 문제와 문의 식화**
   1. ABC언어에서 문은 명령으로 번역되며 프로그램이 메모리에 적재되면 인스트럭션으로 소비된다.
   2. 즉, 적재 후 실행흐름에 맞게 소비되면 끝이다. 재현하거나 원하는 시점까지 지연할 수 없다. 이를 동기적 실행이라고 한다.
   3. 이에 비해 식은 프로그램이 메모리에 적재될 때 별도의 값 영역에 저장되므로 라이프사이클이나 스코프에 따라 런타임에 계속 유지되고 변경하거나 조회하는 등의 작업을 계속할 수 있다.
   4. **문에 식의 특성을 부여하면 런타임에 여러 번 호출하거나 식처럼 변경하거나 원할 때 꺼내서 사용할 수 있게 된다.**
   5. 가장 간단한 방법은 원하는 문의 그룹을 함수객체로 만들면 그 객체는 값이 되므로 객체를 원할 떄 호출할 수 있게 되어 값과 비슷한 특성을 갖는 문의 그룹이 만들어진다.
6. **전략패턴**
   1. 전략이란 문을 식으로 바꾸는 최소 단위를 의미하며 반드시 식(객체) 이어야 한다.
   2. 전략(객체)은 변수에 저장하거나 인자로 전달할 수 있으며 런타임에 재할당하거나 삭제할 수 있다. 또한 원할 때 원하는 만큼 호출하여 문을 재현할 수 있다.
   3. 템플릿 - 로직의 일부를 외부애서 온 전략에게 위임한다.
   4. 델리게이트 - 클라이언트에겐 홀더의 인터페이스를 노출하고 내부에서 동작은 런타임의 전략객체가 수행한다. (구조 패턴 대부분이 전략패턴이라고 볼 수 있다.)
   5. 전략객체와 홀더와 결합도가 전혀 없다면 단순한 유틸리티일 뿐이고, 결합도가 높다면 서브클래싱에 가까워 진다.
   6. **전략 객체와 홀더 사이의 적절한 의존성 관리를 하기 어렵다면 둘 사이를 중재할 인터페이스가 별도로 필요하게 된다.**
7. **이터러블 & 이터레이터**
   1. ABC언어의 반복은 오직 문을 사용할 때만 스택클리어가 일어난다.
   2. 반복문 자체를 제거할 수는 없으나 반복문의 요소를 객체화하는 것이 이터레이터 패턴이다.
8. **전략의 언어화**
   1. 어떤 문을 전략객체화 했다면 반대로 말해 전략객체가 문을 대체한다고 볼 수 있다.
   2. 따라서 모든 문을 전략객체로 감싸 이러한 전략객체를 통제하는 구조로 프로그램을 작성할 수 있다.
9. **옵저버와 퍼블리셔**
   1.  옵저버 패턴의 약점은 클라이언트가 서브젝트를 알고 있다는 점이다.
10. **의존성 관리 방식**
   1.  N:N은 관리할 수 없다.
   2.  facade
       1.  client 1 : 1 facade 1 : N dependency
       2.  facade는 다수의 의존성으로 인해 자주 수정된다.
       3.  기능적으로 브릿지에 가까우나 어댑터처럼 아예 다른 인터페이스로 클라이언트에 노출될 수록 유리하다.
   3.  mediator
       1.  client N : 1 mediator 1 : N client
       2.  모든 클라이언트는 mediator를 알고 있지만 클라이언트끼리는 모르게한다.
       3.  의존성 집중을 피하기 위해 미디에이터에 레이어를 두기도 한다.


***

# 코틀린 코루틴 시작하기

코루틴은 스레드를 통째로 멈추지 않고 자기 자신만 실행을 중단할 수 있다.  
그동안 스레드는 다른 코드를 실행할 수 있다.  

## 작업

비동기적으로 어떤 일을 시작했을 때 그 결과를 **작업** 이라고 부른다.  
코루틴의 `async`를 통하여 반환된 객체가 작업이다.  
  
이 **Job 객체** 는 실제 코루틴을 나타내며 아래의 4가지 상태를 가진다.  

1. **신규** : 생성됐으나 시작되지 않음
2. **활성** : `launch()` 함수 등에 의해 시작됨. 기본 상태
3. **완료** : 모든 것이 순조롭게 진행됨
4. **취소** : 무언가 잘못됨

자식이 있는 작업은 다음과 같은 두 가지 상태를 추가로 갖는다.  

1. **완료 중** : 완료하기 전에 자식이 실행되기를 기다리는 중
2. **취소 중** : 취소하기 전에 자식이 실행되기를 기다리는 중

```kotlin
runBlocking {
   fun fastUuidAsync() = GlobalScope.async {
      UUID.randomUUID()
   }
   val job = fastUuidAsync()
   println(job.await())
}
```

> runBlocking 함수는 모든 코루틴이 끝날 때까지 메인 스레드를 중지시킨다.

## 일시 중단 함수

`suspend` 키워드를 붙여서 일시 중단 함수로 만들 수 있다. 일시 중단 함수는 async처럼 blocking 방식보다 드라마틱하게 빨라지지 않는다.  
하지만 스레드를 멈추지 않기에 함수 하나의 성능은 달라지지 않지만 더 큰 그림을 봤을 때 같은 수의 스레드로 더 많은 요청을 처리할 수 있게 된다.  
  
코틀린 컴파일러가 `suspend` 키워드를 발견하면 함수를 쪼개서 재작성해준다.  

```kotlin
suspend fun profile(state: Int, id: String, context: ArrayList<Any>): Profile {
    when (state) {
        0 -> {
            context += fetchBioOverHttp(id) // takes 1s
            profile(1, id, context)
        }
        1 -> {
            context += fetchPictureFromDB(id) // takes 100ms
            profile(2, id, context)
        }
        2 -> {
            context += fetchFriendsFromDB(id) // takes 500ms
            profile(3, id, context)
        }
        3 -> {
            val (bio, picture, friends) = context
            return Profile(bio, picture, friends)
        }
    }
}
```

이렇게 여러 단계로 쪼개기 위해 **상태 패턴** 을 사용한다.  
**이를 통해 상태 기계의 각 단계를 실행할 때 코루틴을 실행하는 스레드 자원을 놓아줄 수 있다.**  
즉, 상태 기계 자체도 순차적이며 모든 단계를 수행하는 데에 blocking 방식과 동일한 시간이 걸린다.  
핵심은 일시 중단 함수를 통한 위의 예제는 어떤 단계도 스레드를 멈추지 않는다는 것이다.  
