
1. [x] **2장. 생성 패턴 사용하기**
   1. object 키워드를 통해 싱글톤 객체를 선언하거나, 클래스 내에서 `companion` 키워드와 함께 사용하여 정적 메서드를 모아놓기 위한 동반 객체를 만들 수도 있다.
   2. `apply()` 함수는 객체의 상태를 변경한 뒤에 그 객체를 반환하고자 할 때 사용한다.
2. [ ] **3장. 구조 패턴 이해하기**


# 1주차 : 객체 생성 패턴, 구조 패턴

- **싱글톤과 Enum 클래스의 관계**
  - 서비스 전체 라이프사이클에서 인스턴스가 1개만 계속 생존해야하는 경우
  - 상태를 갖지 않게 하거나 동시성에 대한 대비를 할 것
  - JVM 플랫폼에서 원천적으로 안전한 싱글톤 객체는 Enum이다
  - 전역 수준에 선언된 변수와 함수도 전부 싱글톤이다
- **팩토리 메서드**
  - 타입은 모든걸 규정할 수 있지만 유일하게 불가능 한 것이 생성자를 추상화할수는 없다.
  - JVM 플랫폼에서 팩토리 메서드 패턴이 계속 필요한 이유가 생성법을 추상화할 방법이 없기 떄문이다.
  - `KFunctionX`를 이용해서 `::클래스` 형식을 통해 생성자를 함수로 치환할 수 있긴 하다.
- **정적 팩토리 메서드**
  - 코틀린 생성자는 일반 함수에 비해 2가지 제약 조건이 있음
    - suspend로 생성할 수 없음
    - refied 제네릭을 사용할 수 없음
  - 이 제약을 피하려면 정적 팩토리를 제공하는 수 밖에 없다. *정적 팩토리 메서드로 팩토리를 만들어보기*
- **추상 팩토리 메소드**
  - 어떤 객체를 생성할 때 의존성있는 다른 객체도 생성해야만 만들어낼 수 있는 경우가 있다.
  - 의존관계 객체 사이에 라이프사이클 문제가 가장 어려운 문제이다.
  - 경우에 따라 팩토리만으로는 해결할 수 없고 DI로 발전되기도 한다.
  - 빌더와 추상 팩토리 메소드는 문제를 해결하는 방식이 서로 비슷하다. 그래서 모든 팩토리 계열의 패턴은 결국 빌더로 통합되고 있다.
- **빌더와 DSL, value class**
  - 빌더는 의존관계의 객체 주입, 속성 설정, 초기화, 특정 절차 수행 등 모든걸 포함할 수 있다.
  - 대부분의 객체 생성 시
    - **속성 설정** : 밸리데이션 등을 통해 정합성을 검사해야 한다.
    - **의존객체** : 그 객체를 얻는 방법, 라이프사이클을 맞추는 법 등
    - **절차** : 순서를 강제하는 것은 매우 어려운 일이다.
  - **빌더란 복잡한 헬퍼 객체를 동원해 위의 3가지 규칙을 어길 수 없게 디자인하는 모든 것이다.**
- **데코레이터**
  - 기능을 추상화하여 인터페이스를 생성한다.
  - 이 추상화된 기능을 개별 타입이 구현한다.
  - 결국 어떤 도메인을 협력할 수 있는 작업으로 나눌 수 있고 그 작업들을 관통하는 추상화(일반화)를 할 수 있다면 데코레이터 패턴을 쓸 수 있다.
  - 데코레이터는 큰 결과물에 참여자가 나름대로 기여하는 **기여모델** 과 자기가 해보고 아니면 패스하는 **게이트 모델** 이 존재한다.
- **브릿지**
  - 합성을 통해 상속조합 폭발을 피할 수 있다.
  - 합성객체란? 외부에서 해당 객체의 API가 타입에 따라 모두 노출되어 있는 객체. 예를 들어, 계층관계를 가진 객체를 합성객체라고 볼 수 있다.
  - 필드로 다른 객체들을 주입받은 객체는 집합객체라고 볼 수 있다.
  - `class StormTrooper(weapon: Weapon, leg: Leg): Weapon by weapon, Leg by leg` 처럼 인터페이스 위임으로 간단히 해결된다.
  - 만약 Weapon과 Leg가 서로 협력한다면 퍼사드라고 볼 수 있다.
- **코틀린 리플렉션**