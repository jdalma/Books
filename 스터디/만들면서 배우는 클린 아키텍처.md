
# 계층형 아키텍처의 문제점

```
웹 (컨트롤러) -> 도메인 (서비스) -> 영속성 (엔티티, 리포지토리)
```

1. **데이터베이스 주도 설계를 유도한다.**
   1. 상태를 바꾸는 주체인 행동을 중심으로 모델링하지만, 데이터베이스의 구조를 먼저 생각하고 이를 토대로 행동(도메인 로직)을 구현한다.
   2. **도메인 로직을 먼저 만들어야 스스로가 로직을 잘 이해했는지 확인할 수 있다.**
   3. 그리고 도메인 레이어의 서비스가 영속성 레이어의 엔티티에 접근할 수 있도록 열어놓는다면 두 레이어의 강한 결합이 생긴다.
   4. 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시 로딩 / 지연로딩, 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야만한다.
   5. 영속성 코드가 도메인 레이어에 녹아들면서 둘 중 하나만 바꾸는 것이 어려워진다.
2. **계층간 오염을 유발할 가능성이 높다.**
   1. 도메인 레이어를 제외하고는 자기 자신의 레이어에 존재하는 클래스에 의존하지 않고, 하위의 레이어에만 의존하도록하는 것이 원칙이다.
   2. 만약 특정 레이어가 상위 레이어에 의존해야 한다면 컴포넌트를 아래 계층으로 내려서 해결하게 될 가능성이 있다. 즉, 도메인 레이어가 헬퍼나 유틸리티 컴포넌트가 필요할 때 이 컴포넌트들을 영속성 레이어에 집어넣는 것이다.
   3. 아주 간단한 엔티티 조작을 요구하는 상황에도 웹 레이어에서 영속성 레이어로 직접 접근하여 해결하는 선택도 누군가는 할 수 있다.
3. **유스케이스를 숨긴다.**
   1. 도메인 로직이 웹 계층, 도메인 계층, 영속성 계층에 모두 존재할 수 있기 때문에 흩어지기 쉽다. 
   2. 도메인 서비스의 역할에 대한 규칙을 강제하지 않기 때문에, 여러 개의 유스케이스를 담당하는 괴물 서비스가 탄생하기 쉽다. 그렇기에 단일 유스케이스 단위로 작성하는 것이 좋다.
4. **동시 작업이 어려워진다.**

> 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.

# 의존성 역전하기

클라이언트 레이어에 인터페이스를 선언하고 하위 레이어가 이 인터페이스에 의존하게 되면 하위 레이어가 상위 레이어에 의존하는 의존성 역전을 꾀할 수 있다.  
이렇게 의존셩 역전을 통해 도메인 코드가 다른 것을 의존하는 것이 아니라 모든 의존성이 도메인 코드로 향하도록 하여 도메인 코드 변경의 취약점을 제거할 수 있다.  
  
이것이 로버트 마틴의 클린 아키텍처의 목표이다.  
도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 하는 대가가 따른다.  
즉, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다. 다른 계층도 마찬가지다.  
  
# 육각형 아키텍처

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.  
`주도하는 어댑터`에게는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출되는 인터페이스가 될 것이고, `주도되는 어댑터`에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.  

```
adapter.in.web (Controller) -> application.port.in (UseCase) -> application.service (UseCase Impl) -> application.port.out (Port) -> adapter.out.persistence (Port Impl)
```

**주도하는 어댑터가 서비스에 의해 구현된 인커밍 포트를 호출하고, 서비스는 어댑터에 의해 구현된 아웃고잉 포트를 호출한다.**  
그렇기에 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존하지 않아도 된다.  
  
> 클린 아키텍처, 육각형 아키텍처, 혹은 포트와 어댑터 아키텍처 중 무엇으로 불리든 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. 그리고 변경할 이유가 적을수록 유지보수성은 더 좋아진다.  

> **Q: 육각형 아키텍처로 얻을 수 있는 이점은 무엇인가?**  
> A: 어댑터와 포트를 통해 의존성 역전을 적용하여 도메인을 순수한 영역으로 만드는 것이다. 다른 계층에 의존하지 않기에 변경의 여파를 받지 않을 수 있고 추상화 영역이 도메인을 감싸고 있기에 계층 구현체를 바꾸기도 수월하다. 

## 유스케이스

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스 코드는 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안된다.  
하지만 **비즈니스 규칙을 검증하는 책임은 가질 수 있으며, 도메인 엔티티와 이 책임을 공유한다.**  
  
비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다.  
일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다.  
아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환한다.  

유스케이스마다 입력 모델을 분리하고 최소한의 출력 모델을 반환하는 것이 좋다.  
그리고 읽기 전용 유스케이스는 CQS (또는 CQRS)를 적용하여 입력 모델을 쿼리로 구분하는 것도 좋다.  

## 입력 유효성 검증은?

입력 유효성 검증은 유스케이스 클래스의 책임이 아니라고 했는데, 그럼 어댑터가 처리해야할까? 그렇지도 않다.  
입력 유효성 검증을 호출자가 모두 검증했다고 믿을 수 있을까? 그리고 하나 이상의 어댑터에서 호출될 텐데, 유효성 검증을 각 어댑터에서 구현하는 것도 괜찮을까?  
그렇기에 **유스케이스의 책임은 아니지만 애플리케이션 계층에서 입력 유효성 검증을 처리해야한다.**  
  
<h2>입력 모델인 Command 객체에서 검증하자</h2>

1. Command 클래스의 필드들을 불변으로 정의하고 Bean Validation API를 통해 `Validation.validate()` 결과로 검증할 수 있다.
2. 이렇게 잘못된 입력을 호출자에게 돌려주는 유스케이스 보호막을 정의할 수 있다.

## 비즈니스 규칙 검증은?

비즈니스 규칙은 애플리케이션의 핵심이기에 유스케이스 로직의 일부여야 한다.  
그렇다면 언제 입력 유효성을 검증하고 언제 비즈니스 규칙을 검증해야 할까?  
  
**둘 사이의 아주 실용적인 구분점은 비즈니스 규칙을 검증하는 것은 도메인 모델의 현재 상태에 접근해야 하는 반면, 입력 유효성 검증은 그럴 필요가 없다는 것이다.**  
입력 유효성을 검증하는 일은 `@NotNull` 어노테이션들을 작성하는 것과 같이 선언적으로 구분할 수 있지만, 비즈니스 규칙을 검증하는 일은 맥락이 필요하다.  
"출금 계좌는 초과 출금되어서는 안된다."와 같은 조건을 비즈니스 규칙이라고 볼 수 있다.  
  
이런 비즈니스 규칙을 비즈니스 로직 바로 옆에 규칙이 위치하도록 도메인 엔티티 안에 작성하는 것이 좋다.  
또는 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 검증해도 좋다.  
  
## 웹 어댑터

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증 (유스케이스의 입력 유효성 검증과 다른 맥락으로 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.)
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환

## 영속성 어댑터

`주도되는` 혹은 `아웃고잉` 어댑터 이며, 애플리케이션에 호출될 뿐, 애플리케이션을 호출하지는 않는다는 것을 이해해야 한다.  
애플리케이션 서비스와 영속성 코드 사이의 간접적인 계층이며 영속성 문제에 신경 쓰지 않고 도메인 코드를 개발하기 위해, 즉 **영속성 계층에 대한 의존성을 없애기 위한 이러한 간접 계층을 추가하고 있다.**  
이렇게 되면 영속성 코드를 리팩터링하더라도 코어 코드에 변경에 대한 영향을 끼치지 않을 것이다.  
(그렇기에 도메인 코드는 영속성 포트에 의해 정의된 명세를 어떤 클래스가 충족시키는지에 관심이 없다는 사실을 기억하라.)  

1. 입력을 받는다.
2. 입력을 데이터베이스 포맷으로 매핑한다.
3. 입력을 데이터베이스로 보낸다.
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.
5. 출력을 반환한다.

> 영속성 어댑터의 핵심은 **도메인 계층이 영속성 계층에 대한 의존성을 없애기 위해 아웃고잉 포트를 통해 영속성 어댑터에 접근하는 것** 과 **영속성 어댑터의 입력 모델이 영속성 어댑터 내부에 있는 것이 아니라 애플리케이션 코어에 두어 변경에 대한 영향을 끊어버린 것이다.**

하나의 아웃고잉 포트 인터페이스에 모든 데이터베이스 연산을 모아두면 실제로는 필요하지 않은 메서드에 의존하게 된다. 테스트 작성 시에도 많은 메서드를 구현하거나 모킹해야 할 것이다.  
애그리거트당 하나의 영속성 어댑터 접근 방식 또한 나중에 여러 개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기 위한 좋은 토대가 된다.  
바운디드 컨텍스트를 통해 payment 서비스가 wallet이나 ledger 서비스 컨텍스트의 영속성 어댑터에 접근하지 않고 무엇인가 필요로 한다면 REST 또는 이벤트로 통신해야 한다.  
  
이 영속성 어댑터의 테스트에는 단순히 어댑터의 로직만 검증하고 싶은 게 아니라 데이터베이스 매핑(트랜잭션 등)도 검증해야 하기 때문에 단위 테스트보다는 통합 테스트를 적용하는 것이 합리적이다.  
인메모리 데이터베이스 보다는 실제 데이터베이스를 대상으로 테스트하는 것이 좋다.

## 육각형 아키텍처 요소 테스트하기

1. 도메인 엔티티를 구현할 때는 단위 테스트로 커버하자
2. 유스케이스를 구현할 때는 단위 테스트로 커버하자
3. 어댑터를 구현할 때는 통합 테스트로 커버하자 (MockMvc, 실제 DB)
4. 사용자가 취할 수 있는 중요 애플리케이션 경로는 시스템 테스트로 커버하자 (TestRestTemplate)

## 경계 간 매핑하기

모든 계층 간 모델을 공유해서 사용한다면 도메인 모델 클래스에는 웹 계층에서 JSON으로 직렬화하기 위한 애너테이션, 영속성 계층에 필요한 ORM 애너테이션이 혼재될 수 밖에 없다.  
만약 모든 계층이 정확히 같은 구조의, 정확히 같은 정보를 필요로 한다면 `'매핑하지 않기'` 전략은 완벽한 선택지다. 간단한 기능을 위한 모델에는 애너테이션이 혼재하여도 그렇게 큰 문제가 되지 않을 것이기 때문이다.  
  
`'양방향 매핑'`(웹 모델 / 도메인 모델 / 영속성 모델) 전략은 각 계층이 모델을 각자 관리하기 때문에 원하는 데이터를 최적으로 표현할 수 있다.  
작성하는 코드는 많아지지만 매핑 책임이 명확하기에 간단하다.  
  
`'완전 매핑 전략'`(웹 모델 / 커맨드 또는 쿼리 / 도메인 모델 / 커맨드 또는 쿼라 / 영속성 모델)은 유스케이스의 전용 필드와 유효성 검증 로직을 가지는 전용 커맨드 객체를 추가하여 필드의 필수값 또는 널 가능성을 이해하기 쉬운 장점이 있다.  
이 전략은 웹 계층과 애플리케이션 계층 사이에서 상태 변경 유스케이스의 경계를 명확하게 할 때 가장 빛을 발한다. 애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 떄문에 추천되지 않는다.  
  
`'단방향 매핑 전략'`(웹 모델 / 도메인 모델 / 영속성 모델)은 모든 계층의 모델들이 같은 인터페이스를 구현하여 관련있는 특성에 대한 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화할 수 있는 장점이 있다.  
그리고 같은 타입의 인터페이스를 구현하기에 계층간에 매핑없이 전달할 수 있다. 바깥 계층에서는 이 인터페이스 타입을 이용할지 또는 전용 모델로 매핑할지 결정할 수 있다.  
하지만 매핑이 계층을 넘나들며 퍼져 있기 때문에 개념적으로 어렵다.  
그렇기에 계층 간의 모델이 비슷할 때 가장 효과적이다.  
  
각 매핑 전략은 장단점이 있기에 전역 규칙으로 정의하기는 힘들지만 가이드라인은 세울 수 있을 것이다.  
1. **변경 유스케이스를 작업하고 있다면 웹 계층과 애플리케이션 계층 사이에는 유스케이스간의 결합을 제거하기 위해 완전 매핑 전략을 선택하는 것이 좋다.**
    - 유스케이스별 유효성 검증 규칙이 명확해지고 특정 유스케이스에서 필요하지 않은 필드를 다루지 않아도 된다.
2. **변경 유스케이스를 작업하고 있다면 애플리케이션과 영속성 계층 사이에서는 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해서 매핑하지 않기 전략을 선택하는 것이 좋다.**
    - 애플리케이션에서 영속성 문제를 다뤄야 하게 되면 양방향 매핑 전략을 사용하는 것이 좋다.
3. **쿼리 작업을 하면 매핑 오버헤드를 줄이고 빠르게 코드를 짜기 위해 매핑하지 않기 전략을 선택하는 것이 좋다.**
    - 웹 계층이나 영속성 계층에서 특정 기능 또는 조건이 필요한 경우 양방향 매핑 전략을 사용할 수 있다.

## 아키텍처 경계 강제하기

일정 규모 이상의 모든 프로젝트에서는 시간이 지나면서 아키텍처가 서서히 무너지게 된다.  
계층 간의 경계가 약화되고, 코드는 점점 더 테스트하기 어려워지고, 새로운 기능을 구현하는 데 점점 더 많은 시간이 든다.  
archunit 또는 멀티 모듈을 통해 계층간 경계를 강제할 수 있다.

# 질문

1. 아웃고잉 어댑터와 유스케이스 사이에는 포트를 넣어 의존성 역전 원칙을 통해 의존성 방향을 바꿔 유스케이스에 대한 변경을 제한할 수 있지만 인커밍 어댑터와 유스케이스 사이에 포트가 왜 필요할까?
   1. 웹 소켓이 적용된 어댑터라면 out포트에 웹 소켓 컨트롤러가 존재할 수 있다.
   2. 인커밍 포트는 의존성 역전에 필수적인 요소는 아니지만 애플리케이션 중심에 접근하는 진입점을 정의하기에 한 눈에 진입점을 식별할 수 있다.
2. 애플리케이션 레이어를 건너뛰고 인커밍 어댑터에서 아웃고잉 어댑터를 바로 이용하는 것은 어떤가?
   1. 엔티티 모델을 모든 레이어에 사용하게 되며, 적절한 시점에 애플리케이션 레이어를 추가하지 않고 비즈니스 로직이 어댑터에 존재할 확률이 높다.