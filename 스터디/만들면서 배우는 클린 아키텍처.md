
# 계층형 아키텍처의 문제점

1. **데이터베이스 주도 설계를 유도한다.**
   1. 상태를 바꾸는 주체인 행동을 중심으로 모델링하지만, 데이터베이스의 구조를 먼저 생각하고 이를 토대로 행동(도메인 로직)을 구현한다.
   2. **도메인 로직을 먼저 만들어야 스스로가 로직을 잘 이해했는지 확인할 수 있다.**
   3. 그리고 도메인 레이어의 서비스가 영속성 레이어의 엔티티에 접근할 수 있도록 열어놓는다면 두 레이어의 강한 결합이 생긴다.
   4. 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 이로 인해 도메인 로직뿐만 아니라 즉시 로딩 / 지연로딩, 트랜잭션, 캐시 플러시 등등 영속성 계층과 관련된 작업들을 해야만한다.
   5. 영속성 코드가 도메인 레이어에 녹아들면서 둘 중 하나만 바꾸는 것이 어려워진다.
2. **계층간 오염을 유발할 가능성이 높다.**
   1. 도메인 레이어를 제외하고는 자기 자신의 레이어에 존재하는 클래스에 의존하지 않고, 하위의 레이어에만 의존하도록하는 것이 원칙이다.
   2. 만약 특정 레이어가 상위 레이어에 의존해야 한다면 컴포넌트를 아래 계층으로 내려서 해결하게 될 가능성이 있다. 즉, 도메인 레이어가 헬퍼나 유틸리티 컴포넌트가 필요할 때 이 컴포넌트들을 영속성 레이어에 집어넣는 것이다.
   3. 아주 간단한 엔티티 조작을 요구하는 상황에도 웹 레이어에서 영속성 레이어로 직접 접근하여 해결하는 선택도 누군가는 할 수 있다.
3. **유스케이스를 숨긴다.**
   1. 도메인 로직이 웹 계층, 도메인 계층, 영속성 계층에 모두 존재할 수 있기 때문에 흩어지기 쉽다. 
   2. 도메인 서비스의 역할에 대한 규칙을 강제하지 않기 때문에, 여러 개의 유스케이스를 담당하는 괴물 서비스가 탄생하기 쉽다. 그렇기에 단일 유스케이스 단위로 작성하는 것이 좋다.
4. **동시 작업이 어려워진다.**

> 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는 데 도움이 될 것이다.

# 의존성 역전하기

클라이언트 레이어에 인터페이스를 선언하고 하위 레이어가 이 인터페이스에 의존하게 되면 하위 레이어가 상위 레이어에 의존하는 의존성 역전을 꾀할 수 있다.  
이렇게 의존셩 역전을 통해 도메인 코드가 다른 것을 의존하는 것이 아니라 모든 의존성이 도메인 코드로 향하도록 하여 도메인 코드 변경의 취약점을 제거할 수 있다.  
  
이것이 로버트 마틴의 클린 아키텍처의 목표이다.  
도메인 계층이 영속성이나 UI 같은 외부 계층과 철저하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 하는 대가가 따른다.  
즉, 도메인 계층과 영속성 계층이 데이터를 주고받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다. 다른 계층도 마찬가지다.  
  
# 육각형 아키텍처

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.  
`주도하는 어댑터`에게는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출되는 인터페이스가 될 것이고, `주도되는 어댑터`에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.  

```
adapter.in.web (Controller) -> application.port.in (UseCase) -> application.service (UseCase Impl) -> application.port.out (Port) -> adapter.out.persistence (Port Impl)
```

**주도하는 어댑터가 서비스에 의해 구현된 인커밍 포트를 호출하고, 서비스는 어댑터에 의해 구현된 아웃고잉 포트를 호출한다.**  
그렇기에 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존하지 않아도 된다.  
  
> 클린 아키텍처, 육각형 아키텍처, 혹은 포트와 어댑터 아키텍처 중 무엇으로 불리든 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. 그리고 변경할 이유가 적을수록 유지보수성은 더 좋아진다.  

> **Q: 육각형 아키텍처로 얻을 수 있는 이점은 무엇인가?**  
> A: 어댑터와 포트를 통해 의존성 역전을 적용하여 도메인을 순수한 영역으로 만드는 것이다. 다른 계층에 의존하지 않기에 변경의 여파를 받지 않을 수 있고 추상화 영역이 도메인을 감싸고 있기에 계층 구현체를 바꾸기도 수월하다. 

## 유스케이스

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스 코드는 도메인 로직에만 신경 써야 하고 입력 유효성 검증으로 오염되면 안된다.  
하지만 **비즈니스 규칙을 검증하는 책임은 가질 수 있으며, 도메인 엔티티와 이 책임을 공유한다.**  
  
비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다.  
일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다.  
아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환한다.  

유스케이스마다 입력 모델을 분리하고 최소한의 출력 모델을 반환하는 것이 좋다.  
그리고 읽기 전용 유스케이스는 CQS (또는 CQRS)를 적용하여 입력 모델을 쿼리로 구분하는 것도 좋다.  

## 입력 유효성 검증은?

입력 유효성 검증은 유스케이스 클래스의 책임이 아니라고 했는데, 그럼 어댑터가 처리해야할까? 그렇지도 않다.  
입력 유효성 검증을 호출자가 모두 검증했다고 믿을 수 있을까? 그리고 하나 이상의 어댑터에서 호출될 텐데, 유효성 검증을 각 어댑터에서 구현하는 것도 괜찮을까?  
그렇기에 **유스케이스의 책임은 아니지만 애플리케이션 계층에서 입력 유효성 검증을 처리해야한다.**  
  
<h2>입력 모델인 Command 객체에서 검증하자</h2>

1. Command 클래스의 필드들을 불변으로 정의하고 Bean Validation API를 통해 `Validation.validate()` 결과로 검증할 수 있다.
2. 이렇게 잘못된 입력을 호출자에게 돌려주는 유스케이스 보호막을 정의할 수 있다.

## 비즈니스 규칙 검증은?

비즈니스 규칙은 애플리케이션의 핵심이기에 유스케이스 로직의 일부여야 한다.  
그렇다면 언제 입력 유효성을 검증하고 언제 비즈니스 규칙을 검증해야 할까?  
  
**둘 사이의 아주 실용적인 구분점은 비즈니스 규칙을 검증하는 것은 도메인 모델의 현재 상태에 접근해야 하는 반면, 입력 유효성 검증은 그럴 필요가 없다는 것이다.**  
입력 유효성을 검증하는 일은 `@NotNull` 어노테이션들을 작성하는 것과 같이 선언적으로 구분할 수 있지만, 비즈니스 규칙을 검증하는 일은 맥락이 필요하다.  
"출금 계좌는 초과 출금되어서는 안된다."와 같은 조건을 비즈니스 규칙이라고 볼 수 있다.  
  
이런 비즈니스 규칙을 비즈니스 로직 바로 옆에 규칙이 위치하도록 도메인 엔티티 안에 작성하는 것이 좋다.  
또는 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 검증해도 좋다.  
  
## 웹 어댑터

1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증 (유스케이스의 입력 유효성 검증과 다른 맥락으로 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있다는 것을 검증해야 한다.)
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답을 반환

# 질문

1. 아웃고잉 어댑터와 유스케이스 사이에는 포트를 넣어 의존성 역전 원칙을 통해 의존성 방향을 바꿔 유스케이스에 대한 변경을 제한할 수 있지만 인커밍 어댑터와 유스케이스 사이에 포트가 왜 필요할까?
   1. 웹 소켓이 적용된 어댑터라면 out포트에 웹 소켓 컨트롤러가 존재할 수 있다.