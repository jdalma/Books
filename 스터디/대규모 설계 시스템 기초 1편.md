
# 1장. 사용자 수에 따른 확장성

1. **비관계형 데이터베이스가 바람직한 경우**
   1. 아주 낮은 응답 지연시간이 요구됨
   2. 다루는 데이터가 비정형이라 관계형 데이터가 아님
   3. 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면됨
   4. 아주 많은 양의 데이터를 저장할 필요가 있음
2. **로드밸런서**
   1. 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다. 더 나은 보안을 위해, 로드밸런서와 서버 간 통신에는 사설 IP 주소가 이용된다.
   2. 웹 계층의 가용성을 보장할 수 있다.
   3. 고정 세션 (sticky session)
3. **데이터베이스 다중화와 샤딩(수평적 확장)**
   1. 샤딩 키(파티션 키) 전략에 대한 고민 : 유명인사 문제, 핫스팟 키 문제
   2. 샤딩을 적용한 후에 데이터가 샤드의 크기를 넘어간다면 재 샤딩에 대한 고려가 필요하다.
   3. 여러 샤드 간에는 데이터를 조인하기 힘들기 때문에 DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것도 방법이다.
4. **응답 시간 개선 방법**
   1. **캐시 계층**
      1. 읽기 주도형 캐시 전략 : 캐시 미스가 발생한다면 DB에서 데이터를 직접 찾아 저장한 뒤 클라이언트에게 반환한다.
      2. 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택해야 한다.
      3. 데이터 갱신은 자주 일어나지 않지만 참조는 자주 일어나는가?
      4. 영속적으로 보관하지 않아도 될 데이터인가?
      5. 만료 기간과 기준은 어떻게 정할 것인가?
      6. 데이터 일관성은 어떻게 제공할 것인가?
      7. 캐시 서버의 장애에 대한 대응은 어떻게 할 것인가?
      8. 캐시가 꽉 찼을 때 데이터 방출 정책은 무엇인가? (LRU, LFU)
   2. **콘텐츠 전송 네트워크 (CDN)**
      1. 사용자에게 가장 가까운 CDN 서버가 정적 컨텐츠를 제공하며, 만약 CDN 서버에 정적 컨텐츠가 없다면 원본 서버에 요청하여 응답한다.
      2. 컨텐츠에는 TTL이 지정되어 있다.
      3. CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다.
      4. 만료 시점을 잘 정해야 한다.
      5. 아직 만료되지 않은 컨텐츠라도 컨텐츠를 무효화할 수 있는 방법을 만들어 놓아야 한다.
5. **무상태 웹 계층**
   1. 스케일 아웃을 위해 웹 계층에는 사용자 세션 데이터와 같은 상태 정보가 존재해서는 안된다.

# 2장. 개략적인 규모 추정
1. [Latency Numbers Every Programmer Should Know](https://gist.github.com/jboner/2841832), [visualize](https://colin-scott.github.io/personal_website/research/interactive_latency.html)
2. QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 개략적으로 추정할 때는 딱 맞는 결과값 보다는 문제 해결 능력이 중요하다.

# 3장. 시스템 설계 면접 공략법

> 면접은 퀴즈 쇼가 아니며, 정답 따위는 없다는 걸 상기하자.

1. **1단계 : 문제 이해 및 설계 범위 확정**
   1. 엔지니어가 가져야 할 가장 중요한 기술 중 하나는 `올바른 질문`을 하는 것, `적절한 가정`을 하는 것, `시스템 구축에 필요한 정보를 모으는 것`이다.
2. **2단계 : 개략적인 설계안 제시 및 동의 구하기**
   1. 최초 청사진을 제시하고 의견을 구하라. 면접관을 마치 팀원인 것 처럼 대하라.
   2. 핵심 컴포넌트를 포함하는 다이어그램을 그려라.
3. **3단계 : 상세 설계**
   1. 시스템에서 전반적으로 달성해랴 할 목표와 기능 범위 확인
   2. 전체 설계의 개략적 청사진 마련
   3. 해당 청사진에 대한 면접관의 의견 청취
   4. 상세 설계에서 집중해야 할 영역들 확인
4. **4단계 : 마무리**
   1. 병목구간, 좀 더 개선 가능한 지점

# 4장. 처리율 제한 장치의 설계

1. 네트워크 시스템에서 처리율 제한 장치는 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치다.
2. 예를 들어, 특정 기간 내에 전송되는 클라이언트의 HTTP 요청 횟수를 제한하여 횟수에 범어나는 요청은 처리하지 않는 것이다.
   1. 초당 2회 이상 새 글 작성 못함, 같은 IP 주소로는 하루에 10개 이상의 계정을 생성 못함, 같은 디바이스로는 주당 5회 이상 보상을 요청 못함
3. DoS 예방 방지 + 비용 절감 + 서버 과부하 방지
4. **처리율 제한 알고리즘**
   1. 토큰 버킷 : 각 요청은 처리될 때 마다 하나의 토큰을 사용하며, 일정 주기로 토큰을 보급한다.
   2. 누출 버킷 : 요청을 처리할 큐를 준비하여 큐의 사이즈만큼 처리한다. 큐가 다 차있다면 새로 들어온 요청은 버려진다.
   3. 고정 윈도 카운터 : 고정된 간격의 윈도(시간)동안 설정된 임계치에 도달하면 요청은 새 윈도가 열릴 때 까지 버려진다.
   4. 이동 윈도 로그 : 요청의 타임스탬프를 기준으로 판단한다.
   5. 이동 윈도 카운터

# 5장. 안정 해시 설계

1. 수평적 규모 확장성을 달성하기 위해 부하 분산의 기준이 중요하다. 부하 분산을 위한 이 안정 해시의 기술이 중요하다.
2. **안정 해시** : 해시 테이블 크기가 조정될 때 평균적으로 오직 `k/n`개의 키만 재배치하는 해시 기술이다. 대부분의 전통적 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다.
3. **해시 키 재배치 문제를 해결하는 방법**
   1. **해시 공간과 해시 링** : 배열의 양 끝을 연결한 링 구조를 통해 배열에 서버와 키를 모두 저장하여 키의 위치로부터 시계 방향으로 링을 탐색해 만나는 첫 번째 서버가 주인이다.

# 6장. 키-값 저장소 설계

1. **단일 서버 키-값 저장소**를 사용할 때 모든 데이터를 메모리에 적재하기 힘든 경우 '데이터 압축' 또는 '자주 쓰는 데이터만 메모리에 두고 나머지는 디스크에 저장'할 수 있다.
2. 하지만 많은 데이터를 저장하려면 **분산 키-값 저장소**를 만들 필요가 있다.
   1. 분산 해시 테이블이라고도 불리며, 키-값 쌍을 여러 서버에 분산시키는 것이다.
   2. 분산 시스템을 설계할 때는 **CAP 정리(Consistency, Availability, Partition Tolerance theorem)**를 이해하고 있어야 한다.
   3. **CP 시스템**, **AP 시스템**, CA 시스템 : 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 하기에 CA 시스템은 존재하지 않는다고 보면 된다.
   4. 파티션 문제가 발생하면 일관성과 가용성 사이에서 하나를 선택해야 한다.
3. **시스템 컴포넌트**
   1. **데이터 파티션** : 전체 데이터를 한 대의 서버에 저장할 수 없는 경우 고려할 수 있다. 이때 안정해시를 사용하여 규모 확장 자동화, 가상 노드를 통해 다양성을 지킬 수 있다.
      1. 데이터를 여러 서버에 고르게 분산할 수 있는가?
      2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?
   2. **데이터 다중화** : HA와 안정성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.
   3. **데이터 일관성** : 다중화된 데이터는 적절한 동기화가 필요하다. 정족수 합의(Quorum Consensus)프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
      1. N = 사본 개수
      2. W = 쓰기 연산에 대한 정족수 (쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다.)
      3. R = 읽기 연산에 대한 정족수 (읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.)
      4. **W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형적인 과정이다.**
      5. `R = 1, W = N` : 빠른 읽기 연산에 최적화된 시스템
      6. `W = 1, R = N` : 빠른 쓰기 연산에 최적화된 시스템
      7. `W + R > N` : 강한 일관성이 보장됨 (보통 N = 3, W,R = 2)
      8. `W + R <= N` : 강한 일관성이 보장되지 않음
   4. **일관성 불일치 해소**
      1. **강한 일관성** : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다. (즉, 절대 낡은 데이터를 보지 못한다) 모든 사본에 현재 쓰기 연산의 결과가 반영될 때 까지 해당 데이터에 대한 읽기/쓰기를 금지하는 것이다.
      2. **약한 일관성** : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
      3. **최종 일관성** (다이나모, 카산드라 등) : 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델이다. 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨질 수 있다. 이 문제는 클라이언트가 해결해야 한다.
         1. **비 일관성 해소 기법**으로 데이터 버저닝 및 벡터 시계를 사용한 충돌 해소
   5. **장애 감지**
      1. 가십 프로토콜 같은 분산형 장애 감지 : 각 노드는 멤버십 목록을 유지하며, 주기적으로 무작위 노드에게 하트비트 목록을 보낸다. 이 하트비트 목록을 받은 노드는 멤버십 목록을 갱신하는 것이다. 특정 노드의 하트비트 값이 갱신되지 않으면 해당 노드는 장애 상태인것으로 간주한다.
   6. **쓰기 경로** (카산드라)
      1. 쓰기 요청이 커밋 로그 파일에 기록된다.
      2. 데이터가 메모리 캐시에 기록된다.
      3. 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 SSTable(Sorted-String Table)에 기록된다.
   7. **읽기 경로** (카산드라)
      1. 데이터가 메모리에 있는지 검사하며, 없다면
      2. 블룸 필터를 검사한다.
      3. 블룸 필터를 통해 SSTable에 키가 보관되어 있는지 알아낸다.
      4. SSTable에서 데이터를 가져온다.
      5. 해당 데이터를 클라이언트에게 반환한다.

> **CAP 정리** : 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것을 의미한다.  
> - 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
> - 가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
> - 파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.  
> **통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다. 그러므로 실세계에 CA 시스템은 존재하지 않는다.**  

# 7장. 분산 시스템을 위한 유일 ID 생성기 설계

1. **문제 이해 및 설계 범위 확정**
   1. ID의 특성 (유일성, 정렬 가능, 구성 정보 등)
   2. ID를 필요로 하는 시스템 규모 (초당 10000ID를 생성)
2. **개략적 설계안 제시 및 동의 구하기**
   1. UUID : 128비트 짜리 수를 만드는 것은 단순하며 서버 사이의 동기화 이슈도 없기에 규모 확장도 쉽다. 하지만 128비트로 사이즈가 길며 ID를 시간 순으로 정렬할 수 없고 숫자가 아닌 값이 포함되어 있다.
   2. 티켓 서버 : 유일한 ID를 만들어내는 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다. 구현하기 쉽고 중소 애플리케이션에 적합하지만, SPOF 문제 때문에 티켓 서버가 고가용성을 제공해야한다. 그러면 또 데이터 동기화에 대한 문제가 발생한다.
   3. 트위터 스노플레이크 접근법 : 사인 1비트, 타임스탬프 41비트, 데이타센터ID 5비트, 서버ID 5비트, 일련번호 12비트를 할당한다.
3. **마무리**
   1. 시계 동기화 : NTP
   2. 스노플레이크의 각 절의 길이 최적화

# 8장. URL 단축기 설계

1. **문제 이해 및 설계 범위 확정**
   1. URL 단축기가 어떻게 동작해야 하는지?
   2. 트래픽 규모는? (매일 1억개를 만들어야 한다.)
      1. 초당 쓰기 연산 : 1억 / 24 / 3600 = 1160
      2. 초당 읽기 연산 : 쓰기 연산과 비율이 10:1이라고 하면 11600
      3. 10년간 운영한다면 1억 * 365 * 10 = 3650억 개의 레코드를 보관
      4. 평균 길이를 100이라고할 때 3650억 * 100바이트 = 36.5TB
   3. 단축 URL의 길이는? (짧으면 짧을수록 좋다.)
   4. 단축 URL을 구성하는 조건은? (숫자와 영문자만 가능)
   5. 생성된 URL을 삭제하거나 갱신할 수 없다.
2. **개략적 설계안 제시 및 동의 구하기**
   1. tiny url을 만드는 엔드포인트 (origin url -> tiny url, code 301) 및 tiny url의 리디렉션 엔드포인트 설계 (tiny url -> origin url)
      1. 301 Permanently Model : 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답이다. 영구적이기에 브라우저는 이 응답을 캐시한다. 부하를 줄이기 위해서는 이 응답이 유리하다.
      2. 302 Found : 주어진 URL로의 요청이 '일시적으로' Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다. 따라서 요청은 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 되어야 한다. 트래픽 분석이 중요할 때는 이 응답이 유리하다.
   2. **URL 단축** : 긴 URL을 해시 값으로 대응시킬 해시 함수가 관건이다. 양방향으로 복원되어야 하며 origin url이 다르면 해시 값도 달라야 한다.
3. **상세 설계**
   1. **tiny url로 변경할 hash value의 길이 산정** : 사용할 수 있는 문자는 10 + 26 + 26 = 62개다. 62<upper>n</upper> >= 3650억인 n의 최솟값을 찾아야 한다. 62<upper>7</upper>
   2. **해시 후 충돌 해소 방법** : 만약 변환된 hash value가 충돌한다면 origin url뒤에 salt를 추가하여 다시 해시 함수를 실행하는 것이다. 또는 수의 표현 방식이 서로 다른 두 시스템이 같은 수를 공유하여야 하는 경우에 유용한 base-62 진법 변환을 사용할 수 있다.(사용할 수 있는 문자가 62개이기 때문에) 유일한 ID를 생성하여 이 ID를 62진법으로 변환하여 tiny url로 쓸 수 있다.

# 9장. 웹 크롤러 설계

1. 수집 대상 서버로 짧은 시간안에 너무 많은 요청을 보내지 않기 위해 큐 라우터, 큐 매핑 테이블, 큐 선택기, 작업 스레드 등을 고려할 수 있다.

# 10장. 알림 시스템 설계

1. **문제 이해 및 설계 범위 확정**
   1. 어떤 종류의 알림인가?
   2. 실시간인가?
   3. 지원해야하는 단말의 종류는 무엇인가?
   4. 사용자에게 보낼 알림은 누가 만들어 내나?
   5. 사용자가 알림을 거부할 수 있나?
   6. 하루에 몇 건의 알림을 전송하나?
2. **개략적 설계안 제시**
   1. iOS 푸시 알림 : 알림 제공자를 통해 APNS로 알림 전송
   2. 안드로이드 푸시 알림 : APNS 대신 FCM을 사용
   3. SMS 메시지 : 트윌리오, 넥스모 같은 다른 서비스를 이용
   4. 이메일 : 센드그리드, 메일침프 같은 다른 서비스를 이용
   5. 알림을 보내기 위한 연락처 정보를 저장해야 한다.
   6. **N개의 서비스 -> 알림 시스템 -> 제 3자 서비스를 이용한 알림 전송**
      1. 알림 서버에서 전달하는 알림 정보를 단말 종류마다 푸시 알림 작업 메세지 큐와 작업 서버를 추가하여 병목 문제를 개선할 수 있다.
3. **상세 설계**
   1. 데이터 손실 방지 : 알림이 지연되거나 순서가 틀려도 괜찮지만 손실되지 않기 위해 재시도 메커니즘을 구현 (알림 로그 데이터베이스, 리트라이 큐 등)
   2. 알림 중복 전송 방지 : 이벤트 ID로 중복 알림인지 확인한다
   3. 알림 템플릿
   4. 알림 설정 : 사용자가 알림 설정을 상세히 조정할 수 있도록 기능을 제공하여 불편하지 않도록 한다. (알림의 빈도, 알림 활성화 여부 등)

# 11장. 뉴스피드 시스템 설계

1. **문제 이해 및 설계 범위 확정**
   1. 어떤 플랫폼을 위한 시스템인가? (웹, 앱)
   2. 중요한 기능은 무엇인가? (사용자가 새로운 스토리를 올려 다른 사용자가 볼 수 있는 기능)
   3. 뉴스 피드의 조회 정렬 기준은? (최신 포스트, 토픽 점수, 가까운 친구, 시간 흐름 등)
   4. 한 명의 사용자는 최대 몇 명의 친구를 가지나? (5000명)
   5. 트래픽 규모는? (매일 천만 명 방문)
   6. 피드에 올리는 정보의 종류는? (이미지나 비디오 등의 정보도 업로드 할 수 있나?)
2. **개략적 설계안**
   1. **피드 발행** : 사용자가 스토리를 포스팅하면 데이터를 캐시와 DB에 기록한다. 새 포스팅은 친구의 뉴스 피드에도 전송된다.
      1. 포스팅 저장 서비스 (+ 포스팅 캐시, 포스팅 데이터베이스) : 새 포스팅을 데이터베이스와 캐시에 저장한다.
      2. 포스팅 전송 서비스 (+ 피드 캐시) : 새 포스팅을 친구의 뉴스 피드에 푸시한다. 뉴스 피드 데이터는 캐시에 보관하여 빠르게 읽어갈 수 있도록 한다.
      3. 알림 서비스 : 친구들에게 새 포스팅이 올라왔음을 알리거나, 푸시 알림을 보내는 역할을 한다.
   2. **뉴스 피드 생성**
      1. 뉴스 피드 서비스 (+ 뉴스 피드 캐시) : 캐시에서 뉴스 피드를 가져온다.
      2. 뉴스 피드 캐시는 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관한다.
3. **상세 설계**
   1. **포스팅 전송(팬아웃) 서비스**
      1. 쓰기 시점에 팬아웃 (푸시 모델) : 새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신하기에 실시간으로 갱신될 수 있지만 친구가 많은 경우 많은 시간이 소요될 수 있으며 (hotkey 문제), 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 자원이 낭비된다.
      2. 읽기 시점에 팬아웃 (풀 모델) : 피드를 읽어야 하는 시점에 뉴스 피드를 갱신하기에, 서비스를 자주 사용하지 않는 사용자가 많은 경우 이 모델이 유리하다. 데이터를 친구 각각에 푸시하는 작업이 필요 없으므로 hotkey 문제가 발생하지 않지만 뉴스 피드를 읽는데 많은 시간이 소요될 수 있다.
   2. **캐시 구조**
   
# 12장. 채팅 시스템 설계

1. **문제 이해 및 설계 범위 확정**
   1. 1:1 채팅 앱인지? 그룹 채팅 앱인지?
   2. 어떤 플랫폼을 위한 시스템인가? (웹, 앱)
   3. 처리해야 하는 트래픽 규모는 어느정도인가? (DAU기준 5천만 명)
   4. 그룹 채팅의 경우에 인원 제한이 있는가? (최대 100명)
   5. 중요 기능은 어떤 것이 있는가? (첨부파일, 1:1채팅, 그룹채팅, 사용자 접속상태 표시 등)
   6. 메시지 길이에 제한이 있는가? (100,000자)
   7. 종단 간 암호화를 지원해야 하는가?
   8. 채팅 이력은 얼마나 보관되어야 하는가?
2. **개략적 설계안 제시**
   1. 클라이언트는 서로 직접 통신하지 않고 채팅 서비스와 통신한다.
   2. 클라이언트들로부터 메시지를 수신하고 메시지 수신자 결정 및 전달
   3. 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메세지 보관
   4. 네트워크 통신 프로토콜 결정
      1. **폴링** : 클라이언트가 주기적으로 서버에게 확인
      2. **롱 폴링** : 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지한다. 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.
         1. 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수도 있다. 즉, 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
         2. 서버 입장에서는 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.
         3. 여전히 비효율적이다. 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속할 것이다.
      3. **웹소켓** : 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.
         1. 클라이언트가 시작으로 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드된다.
         2. 이 항구적인 연결이 맺어지고나면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있다.
         3. **웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 한다는 것이다.** (클라이언트는 보통 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않는다.)
   5. 새 메시지를 받았다면 앱이 진행 중이지 않더라도 알림을 전달하기 위한 푸시 알림 서비스도 굉장히 중요하다.
   6. 채팅 이력을 어떻게 보관할지 결정하려면 읽기/쓰기 연산 패턴을 이해해야 한다.
      1. 채팅 이력의 데이터 양은 엄청나다.
      2. 주로 최근에 주고 받은 메세지를 조회한다.
      3. 최근 메세지가 많이 조회되긴 하지만 검색이나 특정 사용자가 언급된 메세지를 보거나, 특정 메세지로 점프하거나 하여 무작위적인 데이터 접근을 하게 되는 일도 있다.
      4. 1:1 채팅 앱의 경우 읽기:쓰기 비율은 대략 1:1 정도다.
      5. 그렇기에 **키-값 저장소**를 추천한다.
         1. 수평적 규모확장이 쉬우며, 데이터 접근 지연시간이 낮다.
         2. RDB는 데이터 가운데 롱 테일에 해당하는 부분을 잘 처리하지 못하는 경향이 있다. 인덱스가 커지면 데이터에 대한 무작위적 접근을 처리하는 비용이 늘어난다.
      6. 서비스 탐색 기능을 통해 클라이언트에게 클라이언트의 위치, 서버의 용량 등에 따라 적합한 채팅 서버를 추천한다. 대표적으로 아파치 주키퍼를 떠올릴 수 있다.
         1. 사용 가능한 모든 채팅 서버를 여기 등록시켜 두고, 클라이언트가 접속을 시도하면 최적의 채팅 서버를 골라주는 것이다.
   7. **1:1 채팅 메시지 처리 흐름**
      1. A가 채팅을 전송하면 메시지 동기화 큐로 전송되고 큐는 키-값 저장소에 채팅을 저장한 후에 사용자 B가 접속 중이라면 접속해있는 채팅 서버에 채팅을 전송하고 아니면 푸시 알림 서버에 전송한다.
   8. **여러 단말 사이의 메시지 동기화**
      1. 한 사용자의 여러 단말기들은 가장 최신 메세지의 ID를 추적하기 위해 cur_max_message_id를 유지한다.
   9. **소규모 그룹 채팅에서의 메시지 흐름**
      1. 사용자 A,B,C가 있다고 가정하자. 사용자 A가 메시지를 전송하면 사용자 B와C의 메시지 동기화 큐에 복사된다. (이 큐를 사용자 각각에 할당된 메시지 수신함 같은 것으로 생각해도 무방하다.)
      2. 자기자신을 제외한 나머지 사용자들의 메시지 동기화 큐에 채팅을 계속 복사하는 것이다.
      3. 하지만 많은 사용자가 포함되는 환경에서는 메세지를 각 사용자의 수신함에 복사하는 방법은 바람직하지 않다.
   10. **접속 상태 표시**
       1.  접속상태 서버를 통해 사용자의 상태를 관리한다. 이 접속상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스의 일부이다.
       2.  서비스 탐색을 통해 사용자가 최초 로그인을 하면 last_active_at 타임스탬프 값을 키-값 저장소에 보관하여 이 절차가 끝나면 사용자는 접속 중인 것으로 표시된다.
       3.  짧은 시간 동안 인터넷 연결이 끊어졌다 복구되는 일이 흔하다. 이런 경우 웹소켓 같은 지속성 연결도 끊어지기에 사용자의 접속 상태가 자주 변경되는 문제가 있다.
       4.  이 문제를 하트비트 검사를 통해 해결할 수 있다. 주기적으로 하트비트 이벤트를 접속상태 서버로 보내도록하고, 마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 사용자의 접속상태를 온라인으로 하는 것이다.
   11. **상태 정보의 전송**
       1.  발행-구독 모델을 통해, 각 친구의 관계마다 채널을 하나씩 두는 것이다.
       2.  만약 사용자 A의 접속상태가 변경되면 나머지 A-B,A-C의 채널에 변경된 접속상태를 발행하는 것이다.
       3.  한 그룹에 많은 사용자(100,000)가 존재할 수 있다면, 상태변화 1건당 100,000개의 이벤트 메시지가 발행되기에 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 친구 리스트에 있는 사용자의 접속상태를 갱신하고 싶으면 수동으로 하도록 유도하는 것이다.
3. **마무리 단계의 추가 논의**
   1. 비디오나 미디어의 컨텐츠를 저장하는 방법
   2. 종단 간 암호화
   3. 캐시
   4. 로딩 속도 개선
   5. 채팅 서버 하나에 수십만 사용자가 접속해 있는 상황에 채팅 서버가 죽는다면 서비스 탐색 기능이 동작하여 클라이언트에게 새로운 서버를 배정하는 방법?
   6. 메시지 재전송을 통해 채팅 메시지 유실을 막는 방법

# 질문 목록

1. 지리적 라우팅(geoDNS)은 DNS 목록을 갱신하는 것인가? 장애가 없는 데이터 센터는 어떻게 알아낼 수 있나?
2. HTML을 다운받으려면 왜 도메인 접속으로 다운받지 못하는건가?
   1. DNS에 IP를 조회하는 부하를 막기위해 IP를 미리 리스트업하는 것
3. 중복 전송을 100% 방지하기 힘든 이유? [You Cannot Have Exactly-Once Delivery](https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/)
   2. 분산 시스템은 장단점이 모두 존재하는데 단점 중 하나가 분산 시스템에서는 정확히 한 번만 메시지를 전달할 수 없다는 것이다.
   3. 기본적으로 `최대 한 번`, `최소 한 번`만이 실현 가능하고 널리 사용된다.