
# 1장. 사용자 수에 따른 확장성

1. **비관계형 데이터베이스가 바람직한 경우**
   1. 아주 낮은 응답 지연시간이 요구됨
   2. 다루는 데이터가 비정형이라 관계형 데이터가 아님
   3. 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면됨
   4. 아주 많은 양의 데이터를 저장할 필요가 있음
2. **로드밸런서**
   1. 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다. 더 나은 보안을 위해, 로드밸런서와 서버 간 통신에는 사설 IP 주소가 이용된다.
   2. 웹 계층의 가용성을 보장할 수 있다.
   3. 고정 세션 (sticky session)
3. **데이터베이스 다중화와 샤딩(수평적 확장)**
   1. 샤딩 키(파티션 키) 전략에 대한 고민 : 유명인사 문제, 핫스팟 키 문제
   2. 샤딩을 적용한 후에 데이터가 샤드의 크기를 넘어간다면 재 샤딩에 대한 고려가 필요하다.
   3. 여러 샤드 간에는 데이터를 조인하기 힘들기 때문에 DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것도 방법이다.
4. **응답 시간 개선 방법**
   1. **캐시 계층**
      1. 읽기 주도형 캐시 전략 : 캐시 미스가 발생한다면 DB에서 데이터를 직접 찾아 저장한 뒤 클라이언트에게 반환한다.
      2. 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략을 선택해야 한다.
      3. 데이터 갱신은 자주 일어나지 않지만 참조는 자주 일어나는가?
      4. 영속적으로 보관하지 않아도 될 데이터인가?
      5. 만료 기간과 기준은 어떻게 정할 것인가?
      6. 데이터 일관성은 어떻게 제공할 것인가?
      7. 캐시 서버의 장애에 대한 대응은 어떻게 할 것인가?
      8. 캐시가 꽉 찼을 때 데이터 방출 정책은 무엇인가? (LRU, LFU)
   2. **콘텐츠 전송 네트워크 (CDN)**
      1. 사용자에게 가장 가까운 CDN 서버가 정적 컨텐츠를 제공하며, 만약 CDN 서버에 정적 컨텐츠가 없다면 원본 서버에 요청하여 응답한다.
      2. 컨텐츠에는 TTL이 지정되어 있다.
      3. CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금을 낸다.
      4. 만료 시점을 잘 정해야 한다.
      5. 아직 만료되지 않은 컨텐츠라도 컨텐츠를 무효화할 수 있는 방법을 만들어 놓아야 한다.
5. **무상태 웹 계층**
   1. 스케일 아웃을 위해 웹 계층에는 사용자 세션 데이터와 같은 상태 정보가 존재해서는 안된다.

# 2장. 개략적인 규모 추정
1. [Latency Numbers Every Programmer Should Know](https://gist.github.com/jboner/2841832), [visualize](https://colin-scott.github.io/personal_website/research/interactive_latency.html)
2. QPS, 최대 QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 개략적으로 추정할 때는 딱 맞는 결과값 보다는 문제 해결 능력이 중요하다.

# 3장. 시스템 설계 면접 공략법

> 면접은 퀴즈 쇼가 아니며, 정답 따위는 없다는 걸 상기하자.

1. **1단계 : 문제 이해 및 설계 범위 확정**
   1. 엔지니어가 가져야 할 가장 중요한 기술 중 하나는 `올바른 질문`을 하는 것, `적절한 가정`을 하는 것, `시스템 구축에 필요한 정보를 모으는 것`이다.
2. **2단계 : 개략적인 설계안 제시 및 동의 구하기**
   1. 최초 청사진을 제시하고 의견을 구하라. 면접관을 마치 팀원인 것 처럼 대하라.
   2. 핵심 컴포넌트를 포함하는 다이어그램을 그려라.
3. **3단계 : 상세 설계**
   1. 시스템에서 전반적으로 달성해랴 할 목표와 기능 범위 확인
   2. 전체 설계의 개략적 청사진 마련
   3. 해당 청사진에 대한 면접관의 의견 청취
   4. 상세 설계에서 집중해야 할 영역들 확인
4. **4단계 : 마무리**
   1. 병목구간, 좀 더 개선 가능한 지점

# 4장. 처리율 제한 장치의 설계

1. 네트워크 시스템에서 처리율 제한 장치는 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치다.
2. 예를 들어, 특정 기간 내에 전송되는 클라이언트의 HTTP 요청 횟수를 제한하여 횟수에 범어나는 요청은 처리하지 않는 것이다.
   1. 초당 2회 이상 새 글 작성 못함, 같은 IP 주소로는 하루에 10개 이상의 계정을 생성 못함, 같은 디바이스로는 주당 5회 이상 보상을 요청 못함
3. DoS 예방 방지 + 비용 절감 + 서버 과부하 방지
4. **처리율 제한 알고리즘**
   1. 토큰 버킷 : 각 요청은 처리될 때 마다 하나의 토큰을 사용하며, 일정 주기로 토큰을 보급한다.
   2. 누출 버킷 : 요청을 처리할 큐를 준비하여 큐의 사이즈만큼 처리한다. 큐가 다 차있다면 새로 들어온 요청은 버려진다.
   3. 고정 윈도 카운터 : 고정된 간격의 윈도(시간)동안 설정된 임계치에 도달하면 요청은 새 윈도가 열릴 때 까지 버려진다.
   4. 이동 윈도 로그 : 요청의 타임스탬프를 기준으로 판단한다.
   5. 이동 윈도 카운터

# 5장. 안정 해시 설계

1. 수평적 규모 확장성을 달성하기 위해 부하 분산의 기준이 중요하다. 부하 분산을 위한 이 안정 해시의 기술이 중요하다.
2. **안정 해시** : 해시 테이블 크기가 조정될 때 평균적으로 오직 `k/n`개의 키만 재배치하는 해시 기술이다. 대부분의 전통적 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다.
3. **해시 키 재배치 문제를 해결하는 방법**
   1. **해시 공간과 해시 링** : 배열의 양 끝을 연결한 링 구조를 통해 배열에 서버와 키를 모두 저장하여 키의 위치로부터 시계 방향으로 링을 탐색해 만나는 첫 번째 서버가 주인이다.

# 6장. 키-값 저장소 설계

1. **단일 서버 키-값 저장소**를 사용할 때 모든 데이터를 메모리에 적재하기 힘든 경우 '데이터 압축' 또는 '자주 쓰는 데이터만 메모리에 두고 나머지는 디스크에 저장'할 수 있다.
2. 하지만 많은 데이터를 저장하려면 **분산 키-값 저장소**를 만들 필요가 있다.
   1. 분산 해시 테이블이라고도 불리며, 키-값 쌍을 여러 서버에 분산시키는 것이다.
   2. 분산 시스템을 설계할 때는 **CAP 정리(Consistency, Availability, Partition Tolerance theorem)**를 이해하고 있어야 한다.
   3. **CP 시스템**, **AP 시스템**, CA 시스템 : 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 하기에 CA 시스템은 존재하지 않는다고 보면 된다.
   4. 파티션 문제가 발생하면 일관성과 가용성 사이에서 하나를 선택해야 한다.
3. **시스템 컴포넌트**
   1. **데이터 파티션** : 전체 데이터를 한 대의 서버에 저장할 수 없는 경우 고려할 수 있다. 이때 안정해시를 사용하여 규모 확장 자동화, 가상 노드를 통해 다양성을 지킬 수 있다.
      1. 데이터를 여러 서버에 고르게 분산할 수 있는가?
      2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?
   2. **데이터 다중화** : HA와 안정성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있다.
   3. **데이터 일관성** : 다중화된 데이터는 적절한 동기화가 필요하다. 정족수 합의(Quorum Consensus)프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
      1. N = 사본 개수
      2. W = 쓰기 연산에 대한 정족수 (쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 한다.)
      3. R = 읽기 연산에 대한 정족수 (읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 한다.)
      4. **W, R, N의 값을 정하는 것은 응답 지연과 데이터 일관성 사이의 타협점을 찾는 전형적인 과정이다.**
      5. `R = 1, W = N` : 빠른 읽기 연산에 최적화된 시스템
      6. `W = 1, R = N` : 빠른 쓰기 연산에 최적화된 시스템
      7. `W + R > N` : 강한 일관성이 보장됨 (보통 N = 3, W,R = 2)
      8. `W + R <= N` : 강한 일관성이 보장되지 않음
   4. **일관성 불일치 해소**
      1. **강한 일관성** : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다. (즉, 절대 낡은 데이터를 보지 못한다) 모든 사본에 현재 쓰기 연산의 결과가 반영될 때 까지 해당 데이터에 대한 읽기/쓰기를 금지하는 것이다.
      2. **약한 일관성** : 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
      3. **최종 일관성** (다이나모, 카산드라 등) : 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델이다. 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨질 수 있다. 이 문제는 클라이언트가 해결해야 한다.
         1. **비 일관성 해소 기법**으로 데이터 버저닝 및 벡터 시계를 사용한 충돌 해소
   5. **장애 감지**
      1. 가십 프로토콜 같은 분산형 장애 감지 : 각 노드는 멤버십 목록을 유지하며, 주기적으로 무작위 노드에게 하트비트 목록을 보낸다. 이 하트비트 목록을 받은 노드는 멤버십 목록을 갱신하는 것이다. 특정 노드의 하트비트 값이 갱신되지 않으면 해당 노드는 장애 상태인것으로 간주한다.
   6. **쓰기 경로** (카산드라)
      1. 쓰기 요청이 커밋 로그 파일에 기록된다.
      2. 데이터가 메모리 캐시에 기록된다.
      3. 메모리 캐시가 가득차거나 사전에 정의된 어떤 임계치에 도달하면 데이터는 디스크에 있는 SSTable(Sorted-String Table)에 기록된다.
   7. **읽기 경로** (카산드라)
      1. 데이터가 메모리에 있는지 검사하며, 없다면
      2. 블룸 필터를 검사한다.
      3. 블룸 필터를 통해 SSTable에 키가 보관되어 있는지 알아낸다.
      4. SSTable에서 데이터를 가져온다.
      5. 해당 데이터를 클라이언트에게 반환한다.

> **CAP 정리** : 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다는 것을 의미한다.  
> - 데이터 일관성 : 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
> - 가용성 : 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
> - 파티션 감내 : 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다.

# 7장. 분산 시스템을 위한 유일 ID 생성기 설계

1. **문제 이해 및 설계 범위 확정**
   1. ID의 특성 (유일성, 정렬 가능, 구성 정보 등)
   2. ID를 필요로 하는 시스템 규모 (초당 10000ID를 생성)
2. **개략적 설계안 제시 및 동의 구하기**
   1. UUID : 128비트 짜리 수를 만드는 것은 단순하며 서버 사이의 동기화 이슈도 없기에 규모 확장도 쉽다. 하지만 128비트로 사이즈가 길며 ID를 시간 순으로 정렬할 수 없고 숫자가 아닌 값이 포함되어 있다.
   2. 티켓 서버 : 유일한 ID를 만들어내는 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다. 구현하기 쉽고 중소 애플리케이션에 적합하지만, SPOF 문제 때문에 티켓 서버가 고가용성을 제공해야한다. 그러면 또 데이터 동기화에 대한 문제가 발생한다.
   3. 트위터 스노플레이크 접근법 : 사인 1비트, 타임스탬프 41비트, 데이타센터ID 5비트, 서버ID 5비트, 일련번호 12비트를 할당한다.
3. **마무리**
   1. 시계 동기화 : NTP
   2. 스노플레이크의 각 절의 길이 최적화

# 8장. URL 단축기 설계

1. **문제 이해 및 설계 범위 확정**
   1. URL 단축기가 어떻게 동작해야 하는지?
   2. 트래픽 규모는? (매일 1억개를 만들어야 한다.)
      1. 초당 쓰기 연산 : 1억 / 24 / 3600 = 1160
      2. 초당 읽기 연산 : 쓰기 연산과 비율이 10:1이라고 하면 11600
      3. 10년간 운영한다면 1억 * 365 * 10 = 3650억 개의 레코드를 보관
      4. 평균 길이를 100이라고할 때 3650억 * 100바이트 = 36.5TB
   3. 단축 URL의 길이는? (짧으면 짧을수록 좋다.)
   4. 단축 URL을 구성하는 조건은? (숫자와 영문자만 가능)
   5. 생성된 URL을 삭제하거나 갱신할 수 없다.
2. **개략적 설계안 제시 및 동의 구하기**
   1. tiny url을 만드는 엔드포인트 (origin url -> tiny url, code 301) 및 tiny url의 리디렉션 엔드포인트 설계 (tiny url -> origin url)
      1. 301 Permanently Model : 해당 URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답이다. 영구적이기에 브라우저는 이 응답을 캐시한다. 부하를 줄이기 위해서는 이 응답이 유리하다.
      2. 302 Found : 주어진 URL로의 요청이 '일시적으로' Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답이다. 따라서 요청은 언제나 단축 URL 서버에 먼저 보내진 후에 원래 URL로 리디렉션 되어야 한다. 트래픽 분석이 중요할 때는 이 응답이 유리하다.
   2. **URL 단축** : 긴 URL을 해시 값으로 대응시킬 해시 함수가 관건이다. 양방향으로 복원되어야 하며 origin url이 다르면 해시 값도 달라야 한다.
3. **상세 설계**
   1. **tiny url로 변경할 hash value의 길이 산정** : 사용할 수 있는 문자는 10 + 26 + 26 = 62개다. 62<upper>n</upper> >= 3650억인 n의 최솟값을 찾아야 한다. 62<upper>7</upper>
   2. **해시 후 충돌 해소 방법** : 만약 변환된 hash value가 충돌한다면 origin url뒤에 salt를 추가하여 다시 해시 함수를 실행하는 것이다. 또는 수의 표현 방식이 서로 다른 두 시스템이 같은 수를 공유하여야 하는 경우에 유용한 base-62 진법 변환을 사용할 수 있다.(사용할 수 있는 문자가 62개이기 때문에) 유일한 ID를 생성하여 이 ID를 62진법으로 변환하여 tiny url로 쓸 수 있다.

# 질문 목록

1. 지리적 라우팅(geoDNS)은 DNS 목록을 갱신하는 것인가? 장애가 없는 데이터 센터는 어떻게 알아낼 수 있나?