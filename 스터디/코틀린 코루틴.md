
2023.11.23 

# 1주차 - 5장까지

> 컴파일러가 코루틴 인스턴스를 만드는 방법과 Contiuation에 대한 이해

1. 전체적으로 젯브레인에서는 suspend를 직접 다루지 않고 CoroutineScope레벨로 감싼 추상층에서 코루틴을 사용하길 권장하며, 대부분의 문서와 예제도 이 수준을 기반으로 한다.
2. 비선점형 멀티태스킹
3. Continuation Passing Style(이하 CPS)
4. 하나의 suspend함수는 Continuation을 상속하고 label이란 속성을 갖는 클래스로 번역된다. 지역변수나 인자는 전부 이 클래스의 속성으로 바뀌고 suspend함수 내부의 코드는 전부 `resumeWith(result)` 형태의 메소드 안으로 들어간다.
5. 하나의 suspend함수가 Continuation을 상속한 클래스가 되는 것을 볼 수 있습니다. `suspend함수 → Continuation객체`
   - `suspend` 없이도 논블로킹을 실행할 수 있다. 왜나햐면 중단 함수는 `Continuation`을 인자로 받는 함수이기 때문이다.
   - `suspend`가 붙으면 `resumeXXX`을 호출해주기 전까지 항상 중단된다.
6. 코루틴은 **중단 함수를 실행할 수 있는 상황** , **중단 함수를 감싼 그 무언가**
   - **즉 suspend함수로부터 컴파일러가 생성한 Continuation클래스의 인스턴스를 바로 코틀린에서는 Coroutine(코루틴)이라고 부르고 있다.**
7. returnPoint가 필요하기 때문에 모든 컨티뉴에이션이 생성될 때 다른 컨티뉴에이션을 인자로 요구하는 이유이다
8. 참고
   - [Worker Thread 패턴](http://www.gisdeveloper.co.kr/?p=10330)
   - [코틀린 코루틴 완벽 가이드 #1](https://www.bsidesoft.com/8656)
   - [코틀린 코루틴 완벽 가이드 #2](https://www.bsidesoft.com/8663)
   - [RunSuspend.kt](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/src/kotlin/coroutines/jvm/internal/RunSuspend.kt)
   - [KEEP coroutines](https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md)