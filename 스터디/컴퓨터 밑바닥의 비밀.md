
# 2장. 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

CPU는 사실 스레드, 프로세스, 운영 체제 같은 개념을 전혀 알지 못한다. 단지 두 가지 사항만 알 뿐이다.

1. **메모리에서 명령어(instruction)를 하나 가져온다.(dispatch)**
2. **이 명령어를 실행(execute)한 후 다시 1번으로 돌아간다.**

즉, 명령어를 인출하고 명령어를 실행하고 다음 명령어를 인출하는 반복의 연속이다.

실행 중인 모든 프로그램은 필요한 상황 정보를 기록할 수 있는 구조체여야 한다. 이 구조체가 프로세스이다.  
그렇기 때문에 프로세스를 원하는 대로 일시 중지하거나 다시 시작할 수 있다.  
프로세스의 주소 공간은 4개의 영역으로 나눌 수 있습니다.

1. **코드 영역 (code segment)** : 코드를 컴파일하여 생성된 기계 명령어가 저장된다. 스레드 입장에서는 이 영역은 읽기   전용이기 때문에 변경할 수 없다.
2. **데이터 영역 (data segment)** : 전역 변수 등이 저장된다. 
3. **힙 영역 (heap segment)** : malloc 함수가 요청을 반환한 메모리가 여기에 할당된다.
4. **스택 영역 (stack segment)** : 함수의 실행 시간 스택이다.
   1. 실제로 스레드의 추상화 측면에서 바라보면 스택은 스레드 전용 공간이다. 하지만 실제 구현 측면에서 보면 스택 영역은 엄밀하게 격리된 스레드 전용 공간은 아니다.
   2. 서로 다른 프로세스의 주소 공간은 서로 격리되어 있으며, 가상 메모리 시스템은 매우 특별한 경우를 제외하고 다른 프로세스의 주소 공간에 속한 데이터에 직접 접근하지 못하도록 보장한다.
   3. 서로 다른 스레드의 스택 영역 간에는 이런 보호를 위한 작동 방식이 존재하지 않기에 

## 프로세스에서 스레드로 진화 (스레드 탄생 배경)

프로세스의 주소 공간에는 CPU가 실행하는 기계 명령어와 함수가 실행될 때 스택 정보가 저장된다.  
그리고 우리가 프로세스를 실행하려면 main 함수의 첫 번째 기계 명령어 주소를 PC 레지스터에 기록해야 한다. 이 과정을 거치면 명령어 흐름이 형성된다.  
  
프로세스 단점은 진입 함수가 main 함수 하나 밖에 없어 프로세스의 기계 명령어를 한 번에 하나의 CPU에서만 실행할 수 있다는 것이다.  
하지만 PC 레지스터가 main 함수를 가리키게 할 수 있듯이 PC 레지스터가 다른 어떤 함수라도 가리키게 할 수 있으며, 이를 통해 새로운 실행 흐름을 형성할 수 있다.  
이런 실행 흐름은 동일한 프로세스 주소 공간을 공유하므로, 더 이상 프로세스간 통신이 필요하지 않다는 것이다.  
즉, **하나의 프로세스에 속한 기계 명령어를 CPU 여러 개에서 동시 실행 할 수 있다. CPU의 PC 레지스터에 스레드의 진입 함수 주소를 지정하면 스레드를 실행 시킬 수 있다는 것이다.**  
  
이 실행 흐름을 스레드(경량 프로세스, LWP)라고 부른다.  

> CPU가 기계 명령어를 실행할 때도 실행 중인 기계 명령어가 어떤 스레드에 속해 있는지 인식하지 못한다.  

상태 변화 관점에서 보면 스레드는 사실 함수 실행이다. 함수 실행에는 항상 하나의 시작점(진입 함수)가 존재하며, CPU는 이 시작점에서 실행을 시작하여 하나의 실행 흐름을 생성하는 것이다.  
이 실행 흐름에 인위적으로 스레드라는 이름을 붙인 것에 불과하다.  
  
## 스레드 풀의 스레드 수

스레드 풀의 스레드가 너무 적다면 CPU를 최대한 활용할 수 없고, 너무 많은 스레드를 생성하면 반대로 시스템의 성능 저하, 메모리의 과다한 점유, 스레드 전환으로 생기는 부담 등 문제가 발생한다.  
스레드의 수를 결정하려면 스레드 풀에서 처리할 작업이 어떤 것인지 알 필요가 있다. CPU 집약적인 작업, 입출력 집약적인 작업으로 구분할 수 있다.  
  
작업을 처리할 때 외부 입출력에 의존할 필요없이 처리할 수 있는 CPU 집약적인 작업은 CPU의 코어 수와 스레드의 수가 동일하다면 CPU의 리소스를 충분히 활용할 수 있다.  
연산 부분이 차지하는 시간은 많지 않지만 대부분의 시간을 디스크 입출력이나 네트워크 입출력등에 소비하는 입출력 집약적인 작업인 경우 필요한 스레드의 수를 계산하기 복잡하다.  
**성능 테스트 도구를 사용하여 WT(wait time)이라는 입출력 대기 시간과 CT(computing time)이라는 CPU 연산에 필요한 시간을 평가해야 한다.**  
N개의 코어를 가진 시스템에서 적절한 스레드 수는 대략 `N * (1 + WT / CT)`이며, WT와 CT가 동일하다고 가정하면 대략 `2N`개의 스레드가 있어야 한다.  

## 동기 비동기 / 블로킹 논블로킹

동기는 넘어감
비동기 호출에 대한 작업 완료는 어떻게 처리해야 할까?

1. A -> B -> C -> DB 조회 -> D -> E -> F 순서로 진행될 때 **주 스레드의 DB 조회에 의한 지연이 발생한다면**
	1. 호출자가 실행 결과를 전혀 신경쓰지 않을 때는 주 스레드는 A,B,C를 처리하고 데이터베이스 스레드가 DB 조회부터 D -> E -> F를 실행하면 될 것이다. D, E, F에 대한 연산은 콜백 함수로 전달하는 것이 좋다.
	2. 호출자가 실행 결과를 반드시 알아야 할 때는 알림 작동 방식을 이용하여 작업 결과를 주 스레드로 전송해야 한다. 주 스레드는 메시지를 수신하면 이전 사용자 요청의 후반부를 계속 처리한다.
		1. 데이터베이스를 처리하는 시간 동안은 다른 사용자 요청을 처리하는 것이다.

## 함수 호출로 인해 호출자의 스레드나 프로스세가 운영 체제에 의해 일시 중지 될 수 있는 것은 어떤 경우인가?

블로킹 핵심은 스레드 또는 프로세스가 일시 중지되는 것이다.
일반적으로 디스크가 하나의 트랙 탐색 입출력 요청을 완료하는데 소요되는 시간은 `ms`단위 수준이지만 CPU의 클럭 주파수는 이미 GHz 단위 수준에 도달해 있기 때문에 디스크가 하나의 작업을 수행할 수 있는 ms 단위 시간이 CPU에 주어지면 대량의 기계 명령어 실행 작업을 수행할 수 있다.
그렇기에 **프로그램, 스레드 또는 프로세스가 이런 입출력 작업을 할 때는 CPU 제어권을 다른 스레드에게 넘겨 다른 작업을 할 수 있도록 해야 한다.**
이후 입출력 작업이 완료되면 다시 CPU 제어권을 넘겨받아 계속 다음 작업을 실행하는 것이다.

> 운영 체제는 CPU의 리소스를 최대한 활용할 수 있도록 각 스레드 간에 CPU 사용 시간을 효율적으로 할당해야 하는데, 이것이 바로 블로킹 입출력 방식이 필요한 핵심적인 이유이다.

이렇게 입출력 작업이 너무 느리다보니 관련 함수를 직접 호출하면 스레드 또는 프로세스가 블로킹되는 일이 생긴다.
그렇다면 호출 스레드가 일시 중지되지 않으면서 입출력 작업을 시작할 수 있는 방법은 없을까?

## 논블로킹과 비동기 입출력
데이터를 수신하는 함수인 recv가 논블로킹이라면 이 함수를 호출할 때 운영 체제는 스레드를 일시 중지 시키는 대신 recv 함수를 즉시 반환한다.
이후 호출 스레드는 자신의 작업을 계속 진행하며, 데이터 수신 작업은 커널이 처리한다. (이 두 가지 작업은 병행 처리 된다.)

요청이 전달된 후에 데이터가 언제 수신되었는지 어떻게 알 수 있을까?
1. 논블로킹 방식의 recv 함수 외에 결과를 확인하는 함수를 함께 제공하고, 해당 함수를 호출하여 수신된 데이터가 있는지 확인할 수 있다.
2. 데이터가 수신되면 스레드에 메시지나 신호 등을 전송하는 알림 작동 방식을 사용한다.
3. recv 함수를 호출할 때, 데이터 수신 처리름 담당하는 함수를 콜백 함수에 담아 매개변수로 전달할 수 있다. (이때 recv함수가 콜백을 지원해야 한다.)

이런 유형의 작업을 비동기 입출력이라고 한다.

> **논블로킹이 반드시 비동기를 의미하지 않는다.**

1. **동기와 블로킹**
   1. 동기 호출은 반드시 블로킹이 아닌 반면에 블로킹 호출은 모두 확실한 동기 호출이다.
   2. `sum()` 함수를 호출했다고 하면 함수에 대한 호출은 동기이지만 블로킹되거나 스레드가 일시 중지되지는 않는다.
   3. 반면에 어떤 함수가 블로킹 방식으로 호출된 경우 반드시 동기 호출이라는 것은 사실이다.
2. **비동기와 논블로킹**
   1. 네트워크 데이터를 수신하는 `recv` 함수에 콜백 함수를 지정할 수 있다면 비동기이자 논블로킹이라고 한다.
   2. 하지만 `recv`함수 호출 스레드가 호출 직후 `while(check(...))` 이와 같이 데이터를 확인하게 되면 동기 논블로킹이라고 한다.

***

1. 컴퓨터 시스템은 주기적으로 타이머 인터럽트를 생성하고, 인터럽트가 처리될 때마다 운영체제는 현재 스레드의 일시 중지 여부를 결정할 기회를 가진다. 하지만 사용자 상태에서는 타이머 인터럽트를 위한 작동 방식이 없기 때문에 코루틴의 `yield` 키워드를 사용하여 어디에서 일시 중지하고 CPU의 리소스를 내어 줄 것인지 명시적으로 지정해야 한다.