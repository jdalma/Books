
# **프록시 패턴**

프록시 패턴의 기본 기능은 **프록시 클래스를 생성하여 원본 클래스와 관련이 없는 기능을 추가하는 것** 이다.  
1. 주요 비즈니스와 관련 없는 요구 사항의 개발에 활용될 수 있다.
   - 모니터링, 통계, 인증, 트래픽 제한, 트랜잭션, 멱등성, 로깅과 같이 주요 비즈니스와 관련없는 요구 사항을 개발하는데 적합하다.
2. RPC에서 프록시 패턴을 적용할 수 있다.
   - RPC 프레임워크는 프록시 패턴의 응용 프로그램이다.
3. 캐시에 프록시 패턴을 적용할 수 있다.


## 인터페이스 기반의 프록시 패턴

프록시 패턴은 원본 클래스를 변경하지 않은 상태로 **프록시 클래스**를 도입하여 원본 클래스와 관련 없는 새로운 기능을 추가하는 것이다.  

```kotlin
class UserController(
  private val metricsCollector: MetricsCollector
) {
  
  fun login(tel: String, password: String) : UserVO {
    // 핵심 외 기능 : 실행 시작 시간 기록

    // 핵심 : 비즈니스 로직

    // 핵심 외 기능 : 실행 결과 시간 계산 및 Metric전달
  }
}
```

위의 예제를 보면 **성능 통계 코드가 비즈니스 코드를 침범해 밀접하게 결합되어 있다.**  
이후 `MetricsCollector`가 변경되어야 한다면 핵심 비즈니스 로직에도 수정이 일어날 확률이 높다.  
  
이때 비즈니스 코드에서 성능 통계 코드를 분리하기 위해 프록시 패턴이 유용하게 사용될 수 있다.  

```kotlin
interface IUserController {
    fun login(tel: String, password: String) : UserVO
}

class UserController: IUserController {
    override fun login(tel: String, password: String): UserVO {
        // 핵심 로직
    }
}

class UserControllerProxy (
    private val target: IUserController,
    private val metricsCollector: MetricsCollector
) : IUserController {
    override fun login(tel: String, password: String): UserVO {
        // 부가 기능
        target.login(tel, password)
        // 부가 기능
    }
}
```

위의 코드에서 클라이언트 코드는 `IUserController` 타입에 의존하지만 실제 구현체를 `UserControllerProxy`로 주입하게 되면 클라이언트 코드는 프록시의 기능 존재를 알아차릴 수 없다.  

## 상속 기반의 프록시 패턴

인터페이스 기반의 프록시 패턴에서는 원본 클래스와 프록시 클래스가 동일한 인터페이스를 구현했다.  
하지만 원본 클래스가 외부 라이브러리의 클래스일 뿐만 아니라 인터페이스를 정의하지 않고 있어서 클래스를 직접 수정할 수 없는 경우에 적합하다.  

```kotlin
open class UserController {
    open fun login(tel: String, password: String): UserVO {
        // 핵심 로직
    }
}

class UserControllerProxy (
    private val metricsCollector: MetricsCollector
) : UserController() {
    override fun login(tel: String, password: String): UserVO {
        // 부가 기능
        super.login(tel, password)
        // 부가 기능
    }
}
```

## 리플렉션 기반의 동적 프록시

앞의 예제는 프록시 클래스가 원본 클래스의 모든 메서드를 다시 구현해야하기 때문에 번거롭다.  
그리고 프록시 클래스가 늘어날수록 복잡도가 커진다.  
  
이 문제를 해결할 수 있는 방법은 **동적 프록시** 를 사용하여 각 원본 클래스에 대한 프록시 클래스를 미리 작성하는 대신, `코드를 실행하는 도중에 원본 클래스에 대한 프록시 클래스를 동적으로 생성하고, 코드 내의 원본 클래스를 프록시 클래스로 대체하는 것`을 말한다.  
통계적 성능이 필요한 클래스를 위해 프록시 클래스를 동적으로 생성해주는 `MetricsControllerProxy` 동적 프록시 클래스를 확인해보자.

```kotlin
fun main(args: Array<String>) {
    val proxy = MetricsControllerProxy()
    val controller: IUserController = proxy.createProxy(UserController()) as IUserController
    controller.hello("first")
    controller.bye("second")
}

interface IUserController {
    fun hello(name: String) : String
    fun bye(name: String) : String
}

class UserController : IUserController {
    override fun hello(name: String) = "hello $name"
    override fun bye(name: String) = "bye $name"
}

class MetricsControllerProxy {

    fun createProxy(proxiedObject: Any) : Any {
        val interfaces : Array<Class<*>> = proxiedObject.javaClass.interfaces
        val dynamicProxyHandler = DynamicProxyHandler(proxiedObject)
        return newProxyInstance(
            proxiedObject.javaClass.classLoader,
            interfaces,
            dynamicProxyHandler
        )
    }

    private class DynamicProxyHandler (
        private val proxiedObject: Any
    ) : InvocationHandler {
        override fun invoke(proxy: Any, method: Method, args: Array<out Any>): Any {
            val startTimeStamp = System.currentTimeMillis()

            val result = method.invoke(proxiedObject, args[0])

            val endTimeStamp = System.currentTimeMillis()
            val responseTime = endTimeStamp - startTimeStamp

            // responseTime Metric 기록
            println("response time : $responseTime, result : $result")

            return result
        }
    }
}
```

***

# **[데코레이터 패턴](https://github.com/jdalma/design-patterns/commit/9537c45bc4b9c53e0f9af0d4bd48c7503998fc2d)**

**기존 코드를 변경하지 않고 부가 기능을 추가하는 패턴**   
Java의 `IO 클래스 라이브러리`가 가지고 있는 기본 설계 사상을 분석하여 데코레이터 패턴을 설명할 수 있다.  

```java
InputStream bin = new BufferedInputStream(new FileInputStream("text.txt"))
```

![](imgs/structureRelated/inputStream.png)

이렇게 사용할 바에는 **FileInputStream** 클래스를 확장하여 캐싱을 지원하는 **BufferedFileInputStream** 클래스를 설계하는 것이 더 낫지 않을까?  
아래와 같이 말이다.

```java
InputStream bin = new BufferedFileInputStream("text.txt")
```

상속 구조가 비교적으로 간단하면 문제가 되지 않지만, InputStream 클래스에 수많은 하위 클래스가 존재하기 때문에, 모든 하위 클래스에 버퍼 기반의 읽기를 추가하게 되면 `Buffered`로 시작하는 수많은 하위의 하위 클래스를 파생시켜야 한다. [Hierarchy For Package java.io](https://docs.oracle.com/javase/8/docs/api/java/io/package-tree.html)  
추가로 기본 데이터 유형에 따라 데이터 캐싱과 읽기를 모두 지원하는 클래스가 필요하다면 다시 **BufferedData** 로 시작하는 수많은 하위 클래스를 만들어야 할 것이다.  
이러한 이유로 인해 **Java IO 클래스 라이브러리가 너무 커질 수 있기 때문에 상속이 아닌 `합성`을 사용했다.**  
  
그럼 데코레이터 패턴은 단순히 상속을 합성으로 대체하는 데 사용되는 패턴이라고 생각할 수도 있지만, 그렇지 않다.  
Java IO 클래스 라이브러리 설계에서 데커레이터 패턴이 사용된 이유는 합성 관계와 아래와 같은 차이점이 있다.  

<h3>데코레이터 클래스가 원본 클래스와 동일한 상위 클래스를 상속하기 때문에, 원본 클래스 내에 여러 개의 데코레이터 클래스를 중첩할 수 있다는 점</h3>

`FileInputStream`클래스에 대해 두 개의 데코레이터 클래스인 `Buffered`와 `Data` InputStream을 중첩하여 **기본 데이터 유형에 따라 버퍼 기반의 읽기와 데이터 읽기를 모두 지원하고 있다는 것을 알 수 있다.**  

```java
FileInputStream fileInputStream = new FileInputStream("test.txt");
BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream);
DataInputStream dataInputStream = new DataInputStream(bufferedInputStream);
```

<h3>데코레이터 클래스의 기능이 원본 클래스의 기능을 향상시키는 점</h3>

프록시 패턴과 데코레이터 패턴은 매우 유사하지만, **프록시 패턴의 프록시 클래스는 원본 클래스와 관련이 없는 기능을 추가하는 반면, 데코레이터 패턴의 데코레이터 클래스는 원본 클래스와 관련이 깊은 기능을 추가한다.**  

```java
public interface IA {
    void f();
}

public class A implements IA {
    public void f() { ... }
}

public class ADecorator implements IA {
    private IA a;
    public ADecorator(IA a) {
        this.a = a;
    }

    public void f() {
        // 기능 향상 코드
        a.f();
        // 기능 향상 코드
    }
}
```

**데코레이터 클래스는 개선해야 하는 메서드만 구현하고, 다른 메서드는 데코레이터 상위 클래스의 기본 구현을 상속한다.**  
핵심은 **원본 클래스에 `향샹된 기능을 추가`하는 것이며, 이는 데코레이터 패턴 사용 여부를 판단하는 중요한 기준이기도 하다.**  

## 적용 예제

1. `InputStream`, `OutputStream`, `Reader`, `Writer`의 생성자를 활용한 랩퍼
2. `Collections`이 제공하는 데코레이터 메소드
   - `Collections.checkedXXX()`
   - `Collections.synchronizedXXX()`
   - `Collections.unmodifiableXXX()`
3. 웹플럭스 `ServerHttpRequestDecorator`, `ServerHttpResponseDecorator`
4. 빈 설정 데코레이터 `BeanDefinitionDecorator`

***

# **[어댑터 패턴](https://github.com/jdalma/design-patterns/tree/master/src/main/java/me/whiteship/designpatterns/_02_structural_patterns/_06_adapter)**
  
**조정에 따른 `적응 adaptation`에 사용되며, 호환되지 않는 인터페이스를 호환 가능한 인터페이스로 변환하여, 두 클래스를 함께 작동할 수 있게 한다.**  
**어댑터를 사용하는 큰 이유 중 하나는 클라이언트가 일관되게 사용하기 위함** 이므로 예를 들어 라이브러리 내부에 있는 메서드의 시그니처가 많은 파라미터를 받을 때 어댑터 패턴을 적용해서 파라미터를 클래스로 래핑해서 사용하도록 하는 것이다.  
`상속 관계`를 사용한 **클래스 어댑터** 와 `합성 관계`를 사용한 **객체 어댑터**에 대해 살펴보자.  
  
```kotlin
interface ITarget {
    fun f1()
    fun f2()
    fun fc()
}

open class Adaptee {
    fun fa() { TODO() }
    fun fb() { TODO() }
    fun fc() { TODO() }
}

class InheritanceAdaptor : Adaptee(), ITarget {
    override fun f1() {
        // do something
        super.fa()
        // do something
    }
    override fun f2() {
        // do something
        super.fb()
        // do something
    }
}

class CompositeAdaptor(
    private val adaptee: Adaptee
) : ITarget {
    override fun f1() {
        adaptee.fa()
    }
    override fun f2() {
        adaptee.fb()
    }
    override fun fc() {
        adaptee.fc()
    }
}
```

위의 예제처럼 **파라미터 자체가 없거나 파라미터가 동일한 경우에는 어댑터의 패턴이 큰 역할을 한다고 볼 수 없다.**  
**상속 기반 어댑터** 는 `fc`메소드를 추가적으로 구현해 줄 필요가 없는 것이 큰 차이점이다.  
  
그럼 어떤 것을 선택해야 할까?  
**`Adaptee` 수** 와 **`Adaptee` 와 `ITarget`인터페이스 간의 적합도** 를 비교해야 한다.  

1. Adaptee가 많지 않다면 두 방식 중 어느 것을 사용해도 무방하다.
2. Adaptee와 ITarget 인터페이스의 정의가 대부분 같다면 Adapter 클래스가 상위 클래스 Adaptee를 재사용할 수 있으므로 클래스 어댑터를 사용하는 것이 좋다. **실제로 객체 어댑터에 비해 클래스 어댑터의 코드가 더 작다.**
3. Adaptee와 ITarget 인터페이스의 정의가 대부분 다르다면, **상속 구조보다 유연한 합성 구조 기반의 객체 어댑터를 사용하는 것이 좋다.**

> "어댑터 패턴은 설계 결함을 **교정** 하는 **보상 패턴** 으로 볼 수 있다."  
> "이 패턴을 적용해야 한다는 것은 이미 **어쩔 수 없는 상황** 에 도달했다는 뜻이며, 설계 초기 단계에서 **인터페이스 비호환성 문제를 피할 수 있다면 이 패턴은 사용될 필요가 없다.**"

<h3>첫 번째. 결함이 있는 인터페이스 설계가 캡슐화된 경우</h3>

외부 시스템의 인터페이스 설계가 많은 정적 메서드를 포함하는 것과 같은 결함이 있다면, 코드의 테스트 용이성에 영향을 미치게 된다.  
설계 결함을 분리하기 위해 **외부 시스템에서 제공하는 인터페이스를 다시 캡슐화해 높은 사용성과 테스트 용이성을 인터페이스로 재구축하고 싶다면 해당 패턴이 적절하다.**  

```kotlin
open class ExternalLibraryClass {
    companion object {
        fun staticFunction() { TODO() }
    }
    fun function1(param1 : String, param2 : Int) { TODO() }
    fun function2(param1 : Int) { TODO() }
}

interface ITarget {
    data class ParamsWrapper (
        val param1: String,
        val param2: Int
    )
    fun function1(wrapper: ParamsWrapper)
    fun function2(param1: Int)
    fun function3()
}

class Adaptor : ExternalLibraryClass(), ITarget {
    override fun function1(wrapper: ITarget.ParamsWrapper) {
        super.function1(wrapper.param1, wrapper.param2)
    }
    override fun function3() {
        staticFunction()
    }
}
```

<h3>두 번째. 여러 클래스의 인터페이스 설계를 통합한 경우</h3>

어댑터 패턴을 통해 인터페이스를 통합하고 조정한 다음, 다형성을 사용하여 코드 논리를 재사용할 수 있다.  
예를 들어, 사용자가 입력한 텍스트에서 민감한 단어를 필터링해야 한다고 생각해보자.  
다양한 서드 파티 단어 필터링 시스템을 도입하여 가능한 많은 단어를 필터링 하려하는데, **서드 파티 시스템마다 제공하는 필터링 인터페이스가 다르다.**  


<h3>세 번째. </h3>

![](imgs/structureRelated/adapterDiagram.png)

![](imgs/structureRelated/adapter1.png)

- **UserDetail** , **UserDetailsService** 인터페이스가 `Target`에 해당한다
- **Account** 와 **AccountService**가 `Adaptee`에 해당한다
- 📌
  - 어떻게 **UserDetailsService**와 **AccountService**를 연결할 것 인가?
  - 어떻게 **Account**와 **UserDetails**를 연결할 것인가?

***

# **브리지 패턴**

// TODO