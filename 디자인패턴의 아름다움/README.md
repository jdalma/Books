
# 1주차 모임 - 2.3장까지 (55p)

- [켄트 백의 구현패턴](https://www.yes24.com/Product/Goods/2824034)
- 코드 설계를 배우는 이유는 코드의 품질을 올리기 위해서, 코드의 품질을 올리기 위해서는 어떤 코드가 품질이 높은지 구분할 수 있는 시각을 갖춰야한다.
- 좋은 코드란? 대부분의 분들은 일관성,가독성이라고 하신다.
- 여러 명에서 작업을 해도 `"딱 한 명이 작성한 것 처럼 보이면 될 것 같다."`
- 상시적 리팩토링과 비상시적 리팩토링을 구분한 사례가 있다.
  - 기능을 개발하면서 동시에 리팩토링하는 것과 리팩토링 작업을 할당하는 것
- **코드리뷰에 대한 시각**
  - 어떤 회사는 코드리뷰가 없기도 하고, 어디는 개발자가 PR 프로브 받기위해 다녀야하고, 24시간 룰을 정하고 강제로 하기도 한다.
  - 개발 인력, 리뷰 인력 밀어 넣으면 문제가 안된다. 결국은 비용이다.
  - [코드 리뷰 in 뱅크샐러드 개발 문화](https://blog.banksalad.com/tech/banksalad-code-review-culture/)에서 `Pn`룰도 좋을 것 같다는 의견
  - 절망편은 PR날렸는데 P1이 20개달리는 경우에는??
- 캡슐화, 추상화, 상속, 다형성이 **객체지향의 4대 요소**라는 근거를 찾을 수가 없다고 한다.
  - 하지만 이 책의 저자만 주장한 이야기는 아니고 많은 사람들이 얘기를 한다고 한다.
  - **추상화를 제대로 이해하냐 못하냐로 주니어와 시니어를 판별할 수 있을 정도로 중요하다고 하신다.**
  - **캡슐화**
    - (제한된 메소드 노출, 속성을 캡슐화) + 데이터 은닉 (접근제어)
    - 캡슐화를 사용하는 목적으로 `사용자의 학습 비용 감소`와 `사용 시 오류 확률 감소`이다.
    - 하지만 **사용자에게 노출할 비지니스의 범위를 개발자가 정할 수 있나?**
  - **추상화**
    - 메서드 내부 구현을 숨긴다.
    - 구현 정보를 분리해 인지적 복잡성을 낮춘다.
    - **추상적인 이름짓기**
    - `추상화 레벨을 어떻게 결정할꺼냐?`가 핵심이다.
    - **추상화기법 (인지이론)**
      - Modeling : `필요한 부분`만 추출
      - Categorizing : 특정 기준으로 동일하게 취급
      - Grouping : 임의의 집단으로 묶어서 관리
      - [생각의 탄생](https://www.yes24.com/Product/Goods/2535237) 책
        - 관찰 : 생각의 한 형태로 감각적 경험과 지적의식을 가깝에 연결하여 감각작용을 이해하는 것
        - 형상화 : 관찰의 결과를 시각적인 형태로 그려내는 것
        - 추상화 : 세부적인 내용을 이해하고 이를 제거하여 오직 전체를 대표할 수 있는 하나만 남기는 것
        - 패턴인식 : 추상화를 통해 단순화 된 것들 사이의 규칙을 찾아내고 더 나아가 여러 패턴들 사이를 연결하는 메타패턴도 찾아내는 것
        - 패턴형성 : 인식했던 패턴들을 다른 대상에게도 발견하여 적용하는 것
      - **추상화기법 (추상대수학)** (또잉)
      - **추상화기법 (컴퓨터언어론)**
        - 제어추상화 (sequential, selection, iteration, concurrency)
        - 데이터추상화 (type, variable)
        - **제어와 상태를 추상화하여 사용**
      - **추상화기법 (소프트웨어공학)**
        - 일반화와 특수화
        - 집합과 분해
        - 분류와 인스턴스화
  - **상속과 다형성**
    - **다형성**
      - **대체가능성** 구상형은 추상형으로 대체 가능하다.
        - 타입이 계층 구즈롤 가질 수 있다. 계층구조를 가지지 못하는 타입 시스템의 언어라면 객체지향 프로그래밍을 할 수 없다.
        - 타입을 신경쓰지 않고 메세지를 보내면 (자동적으로) 반응하는 시스템
      - **내적동질성** 생성형이 언제나 연산을 실행한다.
        - ```kotlin
          open class Parent {
              open fun print() = println(message())
              open fun message() = "parent"
          }

          class Child: Parent() {
              override fun message() = "child"
          }
          ```
        - 
      - 위의 두 가지를 만족하지 못하면 객체지향 언어가 아니라고 본다.
    - **상속**
      - 상속이 연쇄된 의존성을 만들어낸다.
      - 각 상속계에 구현을 재활용할 수 있음
      - 내적동질성의 런타임 유지에 큰 비용이 든다.
      - 하위 층이 상위 층에 의존하기 쉬워진다.
      - 대표적으로 **템플릿 메서드 패턴이 상속임에도 불구하고 사용되는 이유가 접근제어를 활용해서 의존성을 끊을 수 있기 때문이다.** (이해가 잘 안됨)
    - **인터페이스**
      - 1단계의 의존성만 만들어낸다
    - **트레이트** (뭔지 모르지만)
      - 인터페이스와 흡사하지만, 타입과 인터페이스의 연결을 별도로 정의한다.
      - 타입에 인터페이스를 추가하기 쉬워진다.
    - **타입계층**
      - 클라이언트 코드는 추상화된 연산에 의존하게 된다.
      - 추상화된 연산의 시그니처 변경이 매우 힘들다.

> **추상 데이터 타입**은 데이터 + 그 데이터에 대한 연산으로 데이터 구조를 추상적으로 정의하자는 개념입니다.  
> 스택을 예로 들자면 생성, 푸시, 팝, 탑이라는 연산 정의로 이뤄지죠.  
> 여기서 구현은 전혀 추상데이터 타입의 관심사항이 아닙니다.  
> 이 개념을 1970년대 바브라 리스코프 할머니가 이야기했죠(리스코프 치환의 그 리스코프)  
> **대수적 데이터 타입**은 합타입과 곱타입의 조합(따라서 타입의 대수)으로 데이터 타입을 정의하는 방식입니다.  
> 둘은 다른 개념.. 약자가 둘다 ADT라서.. 한쪽은  abstract이고 다른쪽은 algebraic 입니다.