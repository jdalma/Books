
<!-- TOC -->

- [주차 모임 - 2.3장까지](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---23%EC%9E%A5%EA%B9%8C%EC%A7%80)
- [주차 모임 - 2장 끝까지](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---2%EC%9E%A5-%EB%81%9D%EA%B9%8C%EC%A7%80)
- [주차 모임 - 3장 설계원칙](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---3%EC%9E%A5-%EC%84%A4%EA%B3%84%EC%9B%90%EC%B9%99)

<!-- /TOC -->

# 1주차 모임 - 2.3장까지

- [켄트 백의 구현패턴](https://www.yes24.com/Product/Goods/2824034)
- 코드 설계를 배우는 이유는 코드의 품질을 올리기 위해서, 코드의 품질을 올리기 위해서는 어떤 코드가 품질이 높은지 구분할 수 있는 시각을 갖춰야한다.
- 좋은 코드란? 대부분의 분들은 일관성,가독성이라고 하신다.
- 여러 명에서 작업을 해도 `"딱 한 명이 작성한 것 처럼 보이면 될 것 같다."`
- 상시적 리팩토링과 비상시적 리팩토링을 구분한 사례가 있다.
  - 기능을 개발하면서 동시에 리팩토링하는 것과 리팩토링 작업을 할당하는 것
- **코드리뷰에 대한 시각**
  - 어떤 회사는 코드리뷰가 없기도 하고, 어디는 개발자가 PR 프로브 받기위해 다녀야하고, 24시간 룰을 정하고 강제로 하기도 한다.
  - 개발 인력, 리뷰 인력 밀어 넣으면 문제가 안된다. 결국은 비용이다.
  - [코드 리뷰 in 뱅크샐러드 개발 문화](https://blog.banksalad.com/tech/banksalad-code-review-culture/)에서 `Pn`룰도 좋을 것 같다는 의견
    - 절망편은 PR날렸는데 P1이 20개달리는 경우에는??
  - 개인적인 생각으로는 회사가 코드리뷰라는 비용을 감당할 수 있으며 그 비용을 아깝게 생각하지 않는 것이 중요하지 않을까 싶다.
  - 생존이 먼저인 회사에 들어가서 코드리뷰 안한다고, TDD 안한다고 뺴애엑 거리는 것은 동네 식당가서 호텔 수준의 음식을 기대하는 것이 아닐까싶다.
- 캡슐화, 추상화, 상속, 다형성이 **객체지향의 4대 요소**라는 근거를 찾을 수가 없다고 한다.
  - 하지만 이 책의 저자만 주장한 이야기는 아니고 많은 사람들이 얘기를 한다고 한다.
  - **추상화를 제대로 이해하냐 못하냐로 주니어와 시니어를 판별할 수 있을 정도로 중요하다고 하신다.**
  - **캡슐화**
    - (제한된 메소드 노출, 속성을 캡슐화) + 데이터 은닉 (접근제어)
    - 캡슐화를 사용하는 목적으로 `사용자의 학습 비용 감소`와 `사용 시 오류 확률 감소`이다.
    - 하지만 **사용자에게 노출할 비지니스의 범위를 개발자가 정할 수 있나?**
  - **추상화**
    - 메서드 내부 구현을 숨긴다.
    - 구현 정보를 분리해 인지적 복잡성을 낮춘다.
    - **추상적인 이름짓기**
    - `추상화 레벨을 어떻게 결정할꺼냐?`가 핵심이다.
    - **추상화기법 (인지이론)**
      - Modeling : `필요한 부분`만 추출
      - Categorizing : 특정 기준으로 동일하게 취급
      - Grouping : 임의의 집단으로 묶어서 관리
      - [생각의 탄생](https://www.yes24.com/Product/Goods/2535237) 책
        - 관찰 : 생각의 한 형태로 감각적 경험과 지적의식을 가깝에 연결하여 감각작용을 이해하는 것
        - 형상화 : 관찰의 결과를 시각적인 형태로 그려내는 것
        - 추상화 : 세부적인 내용을 이해하고 이를 제거하여 오직 전체를 대표할 수 있는 하나만 남기는 것
        - 패턴인식 : 추상화를 통해 단순화 된 것들 사이의 규칙을 찾아내고 더 나아가 여러 패턴들 사이를 연결하는 메타패턴도 찾아내는 것
        - 패턴형성 : 인식했던 패턴들을 다른 대상에게도 발견하여 적용하는 것
      - **추상화기법 (추상대수학)** (또잉)
      - **추상화기법 (컴퓨터언어론)**
        - 제어추상화 (sequential, selection, iteration, concurrency)
        - 데이터추상화 (type, variable)
        - **제어와 상태를 추상화하여 사용**
      - **추상화기법 (소프트웨어공학)**
        - 일반화와 특수화
        - 집합과 분해
        - 분류와 인스턴스화
  - **상속과 다형성**
    - **다형성**
      - **대체가능성** 구상형은 추상형으로 대체 가능하다.
        - 타입이 계층 구즈롤 가질 수 있다. 계층구조를 가지지 못하는 타입 시스템의 언어라면 객체지향 프로그래밍을 할 수 없다.
        - 타입을 신경쓰지 않고 메세지를 보내면 (자동적으로) 반응하는 시스템
      - **내적동질성** 생성형이 언제나 연산을 실행한다.
        - ```kotlin
          open class Parent {
              open fun print() = println(message())
              open fun message() = "parent"
          }

          class Child: Parent() {
              override fun message() = "child"
          }
          ```
        - 
      - 위의 두 가지를 만족하지 못하면 객체지향 언어가 아니라고 본다.
    - **상속**
      - 상속이 연쇄된 의존성을 만들어낸다.
      - 각 상속계에 구현을 재활용할 수 있음
      - 내적동질성의 런타임 유지에 큰 비용이 든다.
      - 하위 층이 상위 층에 의존하기 쉬워진다.
      - 대표적으로 **템플릿 메서드 패턴이 상속임에도 불구하고 사용되는 이유가 접근제어를 활용해서 의존성을 끊을 수 있기 때문이다.** (이해가 잘 안됨)
    - **인터페이스**
      - 1단계의 의존성만 만들어낸다
    - **트레이트** (뭔지 모르지만)
      - 인터페이스와 흡사하지만, 타입과 인터페이스의 연결을 별도로 정의한다.
      - 타입에 인터페이스를 추가하기 쉬워진다.
    - **타입계층**
      - 클라이언트 코드는 추상화된 연산에 의존하게 된다.
      - 추상화된 연산의 시그니처 변경이 매우 힘들다.

> **추상 데이터 타입**은 데이터 + 그 데이터에 대한 연산으로 데이터 구조를 추상적으로 정의하자는 개념입니다.  
> 스택을 예로 들자면 생성, 푸시, 팝, 탑이라는 연산 정의로 이뤄지죠.  
> 여기서 구현은 전혀 추상데이터 타입의 관심사항이 아닙니다.  
> 이 개념을 1970년대 바브라 리스코프 할머니가 이야기했죠(리스코프 치환의 그 리스코프)  
> **대수적 데이터 타입**은 합타입과 곱타입의 조합(따라서 타입의 대수)으로 데이터 타입을 정의하는 방식입니다.  
> 둘은 다른 개념.. 약자가 둘다 ADT라서.. 한쪽은  abstract이고 다른쪽은 algebraic 입니다.

# 2주차 모임 - 2장 끝까지

- 절차지향 프로그래밍
- 객체지향도 상태가 시간순으로 변경되지만 상태는 격리와 은닉을 지킨다면 각 객체로 격리된다.
- **if문은 도메인이기 때문에 절대 제거할 수 없다. if문 분기를 타입 분기로 해결한다.**
- **Getter,Setter 남용**
  - 불변 속성 사용 시 대부분의 문제는 해결되므로 값 객체를 쓰자는 의견 : `값파`
    - 함수형 프로그래밍으로 값 컨텍스트를 사용하여 필드는 불변이기 떄문에 문제를 해결한다.
    - **값을 다루는 컨텍스트로 전체적인 설계가 변화된다.**
  - 철저히 캡슐화된 메소드만 노출하자는 의견 : `객체지향파`
    - 객체지향은 Immutable을 사용하지 않는다.
    - **[헐리우드 원칙](https://johngrib.github.io/wiki/hollywood-principle/)을 잘 따르게 되고 객체지향에 심화된 설계로 변화**
  - **노출하는 속성이 외부 타입인 경우(객체처럼) [디미터법칙](https://johngrib.github.io/wiki/jargon/law-of-demeter/) 위반으로 이어져 의존성을 사방으로 전파시키게됨**
  - lazy하게 주입해야할 경우에는 Setter를 통한 DI대응은 어디까지 허용해야할까?
    - 어노테이션 프로세서 등 컴파일 타임 플러그인 의존만 허용
    - 지연 할당을 위한 런타임 DI 대응을 위해 코딩 규약을 쓰자
- **Convert의 책임은 어디서?**
  - `walletBO = walletEntity.convert()`
    - 레포가 도메인에 맞춰 끼워 넣어줌
    - 도메인을 레포에 의존하지 않고 애플리케이션에서 주도
  - `walletBO = new WalletBO().convert(walletEntity)`
    - 도메인이 레포를 해석함
    - ERD등이 도메인 중심인 경우 고려해볼만 하다
  - `walletBO = walletService.convert(walletEntity)`
    - 프로젝트가 보다 대규모라 레포와 도메인 양쪽을 중계하는게 더 효율적인 경우는 고려해볼만 하다.
  - `convert()`함수를 가진 쪽이 수정에 유연하고, `convert`당하는 쪽은 수정에 딱딱하다.
- **Service의 책임**
  - 어디까지 Service가 중계해야 하는가?
  - 변환, 메세지 중계, 중간 상태 관리, 트랜잭션 중계 등 협력 구현 Facade를 써서 절차적으로 지향을 하던지
  - 협력은 각 객체가 구현하고 의존성은 DI컨테이너가 처리, 서비스는 진입점 역할 및 로깅 등 별도의 관심사만 처리하기 위해 존재
  - **풍성한 도메인 모델은 해당 모델에서 도메인 지식과 처리단계를 소유하므로 서비스 역할을 축소시킴**
- **풍성한 도메인 모델과 RDB**
  - SQL은 곧 ERD의 결과다. 따라서 빈약한 도메인 모델은 정규화된 ERD 구조에 의존하는 서비스라 간접적으로 시사함
  - 풍성한 도메인은 주요 로직이 애플리케이션에 탑재되므로 이론 상 저장소는 어떤 구조로 가져도 상관없고 도메인 모델을 잘 저장할수만 있으면 됨
  - **풍성한 도메인 모델을 쓰면서 정교하게 모델링된 ERD와의 관계를 어떻게 설정할 것인가?**
- **추상클래스와 인스턴스**
  - 추상 클래스는 격리된 상태를 추가로 사용함
  - private을 제외한 속성이나 메소드에 의존하면 프로시저 지향
  - 추상 클래스의 속성을 은닉,캡슐화 하지 않는다면 절차지향적이라고 볼 수 있다.
  - 상태를 사용하지 않는 추상층의 메소드는 보통 유틸 함수이다
  - 추상 클래스를 사용할지 말지는 타입 계층을 이용할지 말지가 가장 중요한 문제다.
  - 계층이 깊어질수록 각 계층의 구현 내용을 이해하기가 힘들고, 새 기능 추가 시 적합한 계층을 판정하기가 힘들다
  - **인터페이스는 깊어지지 않고 넓어짐**
    - 기능 단위로 분리된 인터페이스 여러 개를 implement하면 단일책임규칙을 위반할 위험이 있다.
    - implement 구현 시 조합이 가능하지만 사용 시점에는 조합할 수 없다.
    - 실제 intersection type을 지원하지 않으면 결국 인터페이스 조합만큼의 구상 타입을 만들어야 한다.
    - 코틀린에서는 interface에 속성을 넣기도 한다 구현체는 getter를 구현하니까
  - 스칼라의 형선언을 확인해봐라 JVM 언어와 달리 인터페이스 선언 합성과 사용 합성도 가능하다.
- **상향식과 하향식**
  - 추상클래스가 상향식일까?
    - 구상클래스의 교집합을 묶을 때 인터페이스로 묶을 수도 있음
    - 구현 시 상태가 개입하는 경우도 외부 전략객체를 가져오면 됨
    - 상태를 추상층과 구상층이 공유하면 절차지향 프로그래밍이다
  - 그렇다면 추상 클래스의 의미와 가치는? 계층 구조를 만들어야되는 이유가 뭘까?
    - 인지적인 카테고리를 제공한다.
    - 인터페이스는 어떤 타입도 구상할 수 있는데 비해 추상 클래스의 기능은 오직 해당 타입 계층에게만 제공되게 제약됨
    - 결국 기능의 묶음은 인터페이스나 추상클래스나 동일하게 제공할 수 있지만 사용할 수 있는 타입을 제약할 것인가 아닌가에 달려있다
    - 기능이 일반화될 수 있는 것인가? (인터페이스),  아니면 특정 타입 계층에서만 의미있는가? (추상 클래스) 
- **위임객체와 본객체의 가시성**
  - 위임객체가 본객체의 내부 가시성을 전혀 접근할 수 없는 경우
    - 본객체의 인터페이스로 위임객체를 지정할 이유가 없음
    - 본객체의 인터페이스 구현이 위임객체와 본객체의 상태를 섞어서 구현하는 경우 굳이 위임객체가 해당 인터페이스가 될 이유가 없음 (어짜피 개별 구상 클래스마다 따로 구현해야 하니까)
  - 위임객체가 본객체의 public 미만의 가시성에 접근가능한 경우
    - 위임객체를 위해 본객체가 public으로 승격하면 캡슐화 붕괴
  - **위임객체가 의미있으려면 위임객체와 본객체 간에 추가적인 교환 인터페이스가 필요하다.**
  
**질문**  
- 합성위임패턴을 쓰는 이유가 뭐가 있을까?
- BO가 ERD 테이블과 직접 관계가 있는걸까??난 Entity만 관계 있는 것 같은데, BO는 서비스 레이어에서 필요한 데이터들의 집합 아닌가?

# 3주차 모임 - 3장 설계원칙

- 전략 객체는 사용되는 곳과 대화를 해야한다. 대화를 하지 않으면 util일 뿐이다.
- SOLID를 어떻게 이해하고 실무에 적용하는지는 사람마다 다 제각각이다.
  - 사람마다 단일책임원칙이 가장 다르다.
- 스스로의 주관을 가져야한다.
- **단일책임이란 무엇인가?**
  - 책임 또는 기능으로 생각하면 프로그래밍적 사고를 하게됨
  - 함수이거나 behavior
  - 실제 설계에서 중요한 것은 유지보수 및 확장 즉 변화임
  - **확장이나 변화에 대해서 어떻게 대응할것인가?** 책임이란것은 이 코드가 변화하는 이유가 한 가지로 만들도록 코드를 몰아놓는 것
  - 변화의 이유는 다양하다. 변화율을 하나만 내포하는 단위가 흔하지 않다.
    - 개발적인 문제 : 프레임워크 변화, 언어, 라이브러리 버전
    - 팀 내의 프로토콜, 채택하고 있는 개발 프로세스
    - 도메인의 변화가능성
  - 도메인 통제권이 개발자에게 없는데 어떻게 코드상으로 SRP를 구현하지?
- **개방폐쇄원칙이란?** [57p](https://bertrandmeyer.com/wp-content/upLoads/OOSC.pdf)
  - 수정에 닫혀있고
    - 코드 내에 해석(if(을 추가,수정하는 경우
    - 객체, 함수 등의 외적,내적,의미 변경으로 사용하는 코드를 변경 수정에 닫히게 하는 방법
  - 코드 내에 해석(if)를 제거하고 최대한 의미나 시그니쳐의 변화를 억제한다.
    - if는 도메인 그 자체라서 제거가 불가하다.
    - 도메인 기능의 일반화를 통해(변화율이 다른 것을 찾아내기) 함수밖으로 밀어낼 수는 있다.
    - 도메인에서 필요한 if문은 계속 밖으로 밀어낼 수 있긴하지만 레이어 종단층까지 밀어내서 DI를 받을 수 있을 것이다.
- **리스코프치환원칙 위반하는 상황?**
  - (138p 첫 번째 문제를 해결하려면,상속에 문제가 없으려면) 추상클래스가 제공하는 abstract를 제외한 어떤 기능도 override를 금지하면 해결 가능
  - (138p 두 번째 문제를 해결하려면) 예외를 코드에 포함시키는 것을 통제할 방법이 없음. 예외를 쓰지말자라는 사내 컨벤션 방법밖에 없지 않을까? 코드레벨에서 강제시킬 수가 없으니 이 문제는 막을 수 없다...
  - (138p 세 번째 문제를 해결하려면) 템플릿메서드 또는 전략 패턴 등으로 하위를 강제하게하는 방법이 있다.
  - throw를 쓰지 않는 예외로 프로그래밍하지 않는 세계에서는 Result, Either로 성공과 실패를 값으로 프로그래밍하는 세계도 있다.
- **인터페이스 분리 원칙이 성립하나?**
  - 단일책임을 갖는 인터페이스를 여러 개 갖는 타입이 단일책임일 수 있나?
  - 합성으로 여러 인터페이스를 구현하는 것이 아니라 위임으로 개발해야 하는 것 아닌가?
- 대부분의 행동 패턴은 제어 반전이다.
- **무엇이 어려운 코드인가?**
  - 3.6.2 부분에서 어떤 코드가 쉬워보이나?
  - 구성원 지식 수준에 따라 같은 코드가 어렵기도 쉽기도 하다.
  - 구성원의 지식 수준을 맞출 수 있는가?
  - 그렇다면 최저선에 맞추는 것은 맞는가?
  - 지식수준을 팀의 결정권자가 올리도록 요구하는 것이 맞나?
  - **지식수준을 결정하는 근거**
    - 성능
    - 특정 개인의 취향 또는 판단 (혹은 수준)
    - 남이 쓴다는 이유
    - KISS 원칙 기준은 주관적일 수 밖에 없기 때문에 개인적인 차원으로 느껴진다. 그래서 범용화하고 공용화하려 비용과 에너지를 들이지 않겠다.
    - YAGNI 원칙은 도메인 문제로 느껴진다.
  - **어려운 코드의 제약은 어느 수준의 레이어까지 적용하나?**
    - 기저 레이어의 c++로 된 JNI 모듈도 자바로 고치나?
    - 성능이 중요해지면 기준은 바뀌나?
  - LoD안에 디미터의 법칙
    - LoD : 알 것만 알아라
    - 디미터의 법칙 : 의도치 않게 의존성이 노출될 수 있으니 조심해라
  - 양방향은 제어할 수 없다. **의존성을 단방향으로만 흐르게 해라**
- **읽어보기**
  - [Thread exception handler](https://github.com/HomoEfficio/dev-tips/blob/master/Java-Thread%EB%82%B4%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-Exception-%EC%B2%98%EB%A6%AC.md)


<h3>모듈간 의존 역전이 필요한 이유</h3>

```kotlin
// moduleA
class Runner(val func: Func1) {
  fun exec() {...}
}

// moduleB
class Func1
fun main() {
  Runner(Func1()).exec()
}

// ......

// moduleA
class Runner(val func: Func) {
  fun exec() {..}
}
interface Func

// moduleB
class Func1:Func

fun main() {
  Runner(Func1()).exec()
}
```