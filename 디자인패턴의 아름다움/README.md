
<!-- TOC -->

- [주차 모임 - 2.3장까지](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---23%EC%9E%A5%EA%B9%8C%EC%A7%80)
- [주차 모임 - 2장 끝까지](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---2%EC%9E%A5-%EB%81%9D%EA%B9%8C%EC%A7%80)
- [주차 모임 - 3장 설계원칙](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---3%EC%9E%A5-%EC%84%A4%EA%B3%84%EC%9B%90%EC%B9%99)
- [주차 모임 - 5장](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---5%EC%9E%A5)
- [주차 모임 - 6장. 생성 디자인 패턴](#%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84---6%EC%9E%A5-%EC%83%9D%EC%84%B1-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4)

<!-- /TOC -->

# 1주차 모임 - 2.3장까지

- [켄트 백의 구현패턴](https://www.yes24.com/Product/Goods/2824034)
- 코드 설계를 배우는 이유는 코드의 품질을 올리기 위해서, 코드의 품질을 올리기 위해서는 어떤 코드가 품질이 높은지 구분할 수 있는 시각을 갖춰야한다.
- 좋은 코드란? 대부분의 분들은 일관성,가독성이라고 하신다.
- 여러 명에서 작업을 해도 `"딱 한 명이 작성한 것 처럼 보이면 될 것 같다."`
- 상시적 리팩토링과 비상시적 리팩토링을 구분한 사례가 있다.
  - 기능을 개발하면서 동시에 리팩토링하는 것과 리팩토링 작업을 할당하는 것
- **코드리뷰에 대한 시각**
  - 어떤 회사는 코드리뷰가 없기도 하고, 어디는 개발자가 PR 프로브 받기위해 다녀야하고, 24시간 룰을 정하고 강제로 하기도 한다.
  - 개발 인력, 리뷰 인력 밀어 넣으면 문제가 안된다. 결국은 비용이다.
  - [코드 리뷰 in 뱅크샐러드 개발 문화](https://blog.banksalad.com/tech/banksalad-code-review-culture/)에서 `Pn`룰도 좋을 것 같다는 의견
    - 절망편은 PR날렸는데 P1이 20개달리는 경우에는??
  - 개인적인 생각으로는 회사가 코드리뷰라는 비용을 감당할 수 있으며 그 비용을 아깝게 생각하지 않는 것이 중요하지 않을까 싶다.
  - 생존이 먼저인 회사에 들어가서 코드리뷰 안한다고, TDD 안한다고 뺴애엑 거리는 것은 동네 식당가서 호텔 수준의 음식을 기대하는 것이 아닐까싶다.
- 캡슐화, 추상화, 상속, 다형성이 **객체지향의 4대 요소**라는 근거를 찾을 수가 없다고 한다.
  - 하지만 이 책의 저자만 주장한 이야기는 아니고 많은 사람들이 얘기를 한다고 한다.
  - **추상화를 제대로 이해하냐 못하냐로 주니어와 시니어를 판별할 수 있을 정도로 중요하다고 하신다.**
  - **캡슐화**
    - (제한된 메소드 노출, 속성을 캡슐화) + 데이터 은닉 (접근제어)
    - 캡슐화를 사용하는 목적으로 `사용자의 학습 비용 감소`와 `사용 시 오류 확률 감소`이다.
    - 하지만 **사용자에게 노출할 비지니스의 범위를 개발자가 정할 수 있나?**
  - **추상화**
    - 메서드 내부 구현을 숨긴다.
    - 구현 정보를 분리해 인지적 복잡성을 낮춘다.
    - **추상적인 이름짓기**
    - `추상화 레벨을 어떻게 결정할꺼냐?`가 핵심이다.
    - **추상화기법 (인지이론)**
      - Modeling : `필요한 부분`만 추출
      - Categorizing : 특정 기준으로 동일하게 취급
      - Grouping : 임의의 집단으로 묶어서 관리
      - [생각의 탄생](https://www.yes24.com/Product/Goods/2535237) 책
        - 관찰 : 생각의 한 형태로 감각적 경험과 지적의식을 가깝에 연결하여 감각작용을 이해하는 것
        - 형상화 : 관찰의 결과를 시각적인 형태로 그려내는 것
        - 추상화 : 세부적인 내용을 이해하고 이를 제거하여 오직 전체를 대표할 수 있는 하나만 남기는 것
        - 패턴인식 : 추상화를 통해 단순화 된 것들 사이의 규칙을 찾아내고 더 나아가 여러 패턴들 사이를 연결하는 메타패턴도 찾아내는 것
        - 패턴형성 : 인식했던 패턴들을 다른 대상에게도 발견하여 적용하는 것
      - **추상화기법 (추상대수학)** (또잉)
      - **추상화기법 (컴퓨터언어론)**
        - 제어추상화 (sequential, selection, iteration, concurrency)
        - 데이터추상화 (type, variable)
        - **제어와 상태를 추상화하여 사용**
      - **추상화기법 (소프트웨어공학)**
        - 일반화와 특수화
        - 집합과 분해
        - 분류와 인스턴스화
  - **상속과 다형성**
    - **다형성**
      - **대체가능성** 구상형은 추상형으로 대체 가능하다.
        - 타입이 계층 구즈롤 가질 수 있다. 계층구조를 가지지 못하는 타입 시스템의 언어라면 객체지향 프로그래밍을 할 수 없다.
        - 타입을 신경쓰지 않고 메세지를 보내면 (자동적으로) 반응하는 시스템
      - **내적동질성** 생성형이 언제나 연산을 실행한다.
        - ```kotlin
          open class Parent {
              open fun print() = println(message())
              open fun message() = "parent"
          }

          class Child: Parent() {
              override fun message() = "child"
          }
          ```
        - 
      - 위의 두 가지를 만족하지 못하면 객체지향 언어가 아니라고 본다.
    - **상속**
      - 상속이 연쇄된 의존성을 만들어낸다.
      - 각 상속계에 구현을 재활용할 수 있음
      - 내적동질성의 런타임 유지에 큰 비용이 든다.
      - 하위 층이 상위 층에 의존하기 쉬워진다.
      - 대표적으로 **템플릿 메서드 패턴이 상속임에도 불구하고 사용되는 이유가 접근제어를 활용해서 의존성을 끊을 수 있기 때문이다.** (이해가 잘 안됨)
    - **인터페이스**
      - 1단계의 의존성만 만들어낸다
    - **트레이트** (뭔지 모르지만)
      - 인터페이스와 흡사하지만, 타입과 인터페이스의 연결을 별도로 정의한다.
      - 타입에 인터페이스를 추가하기 쉬워진다.
    - **타입계층**
      - 클라이언트 코드는 추상화된 연산에 의존하게 된다.
      - 추상화된 연산의 시그니처 변경이 매우 힘들다.

> **추상 데이터 타입**은 데이터 + 그 데이터에 대한 연산으로 데이터 구조를 추상적으로 정의하자는 개념입니다.  
> 스택을 예로 들자면 생성, 푸시, 팝, 탑이라는 연산 정의로 이뤄지죠.  
> 여기서 구현은 전혀 추상데이터 타입의 관심사항이 아닙니다.  
> 이 개념을 1970년대 바브라 리스코프 할머니가 이야기했죠(리스코프 치환의 그 리스코프)  
> **대수적 데이터 타입**은 합타입과 곱타입의 조합(따라서 타입의 대수)으로 데이터 타입을 정의하는 방식입니다.  
> 둘은 다른 개념.. 약자가 둘다 ADT라서.. 한쪽은  abstract이고 다른쪽은 algebraic 입니다.

# 2주차 모임 - 2장 끝까지

- 절차지향 프로그래밍
- 객체지향도 상태가 시간순으로 변경되지만 상태는 격리와 은닉을 지킨다면 각 객체로 격리된다.
- **if문은 도메인이기 때문에 절대 제거할 수 없다. if문 분기를 타입 분기로 해결한다.**
- **Getter,Setter 남용**
  - 불변 속성 사용 시 대부분의 문제는 해결되므로 값 객체를 쓰자는 의견 : `값파`
    - 함수형 프로그래밍으로 값 컨텍스트를 사용하여 필드는 불변이기 떄문에 문제를 해결한다.
    - **값을 다루는 컨텍스트로 전체적인 설계가 변화된다.**
  - 철저히 캡슐화된 메소드만 노출하자는 의견 : `객체지향파`
    - 객체지향은 Immutable을 사용하지 않는다.
    - **[헐리우드 원칙](https://johngrib.github.io/wiki/hollywood-principle/)을 잘 따르게 되고 객체지향에 심화된 설계로 변화**
  - **노출하는 속성이 외부 타입인 경우(객체처럼) [디미터법칙](https://johngrib.github.io/wiki/jargon/law-of-demeter/) 위반으로 이어져 의존성을 사방으로 전파시키게됨**
  - lazy하게 주입해야할 경우에는 Setter를 통한 DI대응은 어디까지 허용해야할까?
    - 어노테이션 프로세서 등 컴파일 타임 플러그인 의존만 허용
    - 지연 할당을 위한 런타임 DI 대응을 위해 코딩 규약을 쓰자
- **Convert의 책임은 어디서?**
  - `walletBO = walletEntity.convert()`
    - 레포가 도메인에 맞춰 끼워 넣어줌
    - 도메인을 레포에 의존하지 않고 애플리케이션에서 주도
  - `walletBO = new WalletBO().convert(walletEntity)`
    - 도메인이 레포를 해석함
    - ERD등이 도메인 중심인 경우 고려해볼만 하다
  - `walletBO = walletService.convert(walletEntity)`
    - 프로젝트가 보다 대규모라 레포와 도메인 양쪽을 중계하는게 더 효율적인 경우는 고려해볼만 하다.
  - `convert()`함수를 가진 쪽이 수정에 유연하고, `convert`당하는 쪽은 수정에 딱딱하다.
- **Service의 책임**
  - 어디까지 Service가 중계해야 하는가?
  - 변환, 메세지 중계, 중간 상태 관리, 트랜잭션 중계 등 협력 구현 Facade를 써서 절차적으로 지향을 하던지
  - 협력은 각 객체가 구현하고 의존성은 DI컨테이너가 처리, 서비스는 진입점 역할 및 로깅 등 별도의 관심사만 처리하기 위해 존재
  - **풍성한 도메인 모델은 해당 모델에서 도메인 지식과 처리단계를 소유하므로 서비스 역할을 축소시킴**
- **풍성한 도메인 모델과 RDB**
  - SQL은 곧 ERD의 결과다. 따라서 빈약한 도메인 모델은 정규화된 ERD 구조에 의존하는 서비스라 간접적으로 시사함
  - 풍성한 도메인은 주요 로직이 애플리케이션에 탑재되므로 이론 상 저장소는 어떤 구조로 가져도 상관없고 도메인 모델을 잘 저장할수만 있으면 됨
  - **풍성한 도메인 모델을 쓰면서 정교하게 모델링된 ERD와의 관계를 어떻게 설정할 것인가?**
- **추상클래스와 인스턴스**
  - 추상 클래스는 격리된 상태를 추가로 사용함
  - private을 제외한 속성이나 메소드에 의존하면 프로시저 지향
  - 추상 클래스의 속성을 은닉,캡슐화 하지 않는다면 절차지향적이라고 볼 수 있다.
  - 상태를 사용하지 않는 추상층의 메소드는 보통 유틸 함수이다
  - 추상 클래스를 사용할지 말지는 타입 계층을 이용할지 말지가 가장 중요한 문제다.
  - 계층이 깊어질수록 각 계층의 구현 내용을 이해하기가 힘들고, 새 기능 추가 시 적합한 계층을 판정하기가 힘들다
  - **인터페이스는 깊어지지 않고 넓어짐**
    - 기능 단위로 분리된 인터페이스 여러 개를 implement하면 단일책임규칙을 위반할 위험이 있다.
    - implement 구현 시 조합이 가능하지만 사용 시점에는 조합할 수 없다.
    - 실제 intersection type을 지원하지 않으면 결국 인터페이스 조합만큼의 구상 타입을 만들어야 한다.
    - 코틀린에서는 interface에 속성을 넣기도 한다 구현체는 getter를 구현하니까
  - 스칼라의 형선언을 확인해봐라 JVM 언어와 달리 인터페이스 선언 합성과 사용 합성도 가능하다.
- **상향식과 하향식**
  - 추상클래스가 상향식일까?
    - 구상클래스의 교집합을 묶을 때 인터페이스로 묶을 수도 있음
    - 구현 시 상태가 개입하는 경우도 외부 전략객체를 가져오면 됨
    - 상태를 추상층과 구상층이 공유하면 절차지향 프로그래밍이다
  - 그렇다면 추상 클래스의 의미와 가치는? 계층 구조를 만들어야되는 이유가 뭘까?
    - 인지적인 카테고리를 제공한다.
    - 인터페이스는 어떤 타입도 구상할 수 있는데 비해 추상 클래스의 기능은 오직 해당 타입 계층에게만 제공되게 제약됨
    - 결국 기능의 묶음은 인터페이스나 추상클래스나 동일하게 제공할 수 있지만 사용할 수 있는 타입을 제약할 것인가 아닌가에 달려있다
    - 기능이 일반화될 수 있는 것인가? (인터페이스),  아니면 특정 타입 계층에서만 의미있는가? (추상 클래스) 
- **위임객체와 본객체의 가시성**
  - 위임객체가 본객체의 내부 가시성을 전혀 접근할 수 없는 경우
    - 본객체의 인터페이스로 위임객체를 지정할 이유가 없음
    - 본객체의 인터페이스 구현이 위임객체와 본객체의 상태를 섞어서 구현하는 경우 굳이 위임객체가 해당 인터페이스가 될 이유가 없음 (어짜피 개별 구상 클래스마다 따로 구현해야 하니까)
  - 위임객체가 본객체의 public 미만의 가시성에 접근가능한 경우
    - 위임객체를 위해 본객체가 public으로 승격하면 캡슐화 붕괴
  - **위임객체가 의미있으려면 위임객체와 본객체 간에 추가적인 교환 인터페이스가 필요하다.**
  
**질문**  
- 합성위임패턴을 쓰는 이유가 뭐가 있을까?
- BO가 ERD 테이블과 직접 관계가 있는걸까??난 Entity만 관계 있는 것 같은데, BO는 서비스 레이어에서 필요한 데이터들의 집합 아닌가?

# 3주차 모임 - 3장 설계원칙

- 전략 객체는 사용되는 곳과 대화를 해야한다. 대화를 하지 않으면 util일 뿐이다.
- SOLID를 어떻게 이해하고 실무에 적용하는지는 사람마다 다 제각각이다.
  - 사람마다 단일책임원칙이 가장 다르다.
- 스스로의 주관을 가져야한다.
- **단일책임이란 무엇인가?**
  - 책임 또는 기능으로 생각하면 프로그래밍적 사고를 하게됨
  - 함수이거나 behavior
  - 실제 설계에서 중요한 것은 유지보수 및 확장 즉 변화임
  - **확장이나 변화에 대해서 어떻게 대응할것인가?** 책임이란것은 이 코드가 변화하는 이유가 한 가지로 만들도록 코드를 몰아놓는 것
  - 변화의 이유는 다양하다. 변화율을 하나만 내포하는 단위가 흔하지 않다.
    - 개발적인 문제 : 프레임워크 변화, 언어, 라이브러리 버전
    - 팀 내의 프로토콜, 채택하고 있는 개발 프로세스
    - 도메인의 변화가능성
  - 도메인 통제권이 개발자에게 없는데 어떻게 코드상으로 SRP를 구현하지?
- **개방폐쇄원칙이란?** [57p](https://bertrandmeyer.com/wp-content/upLoads/OOSC.pdf)
  - 수정에 닫혀있고
    - 코드 내에 해석(if(을 추가,수정하는 경우
    - 객체, 함수 등의 외적,내적,의미 변경으로 사용하는 코드를 변경 수정에 닫히게 하는 방법
  - 코드 내에 해석(if)를 제거하고 최대한 의미나 시그니쳐의 변화를 억제한다.
    - if는 도메인 그 자체라서 제거가 불가하다.
    - 도메인 기능의 일반화를 통해(변화율이 다른 것을 찾아내기) 함수밖으로 밀어낼 수는 있다.
    - 도메인에서 필요한 if문은 계속 밖으로 밀어낼 수 있긴하지만 레이어 종단층까지 밀어내서 DI를 받을 수 있을 것이다.
- **리스코프치환원칙 위반하는 상황?**
  - (138p 첫 번째 문제를 해결하려면,상속에 문제가 없으려면) 추상클래스가 제공하는 abstract를 제외한 어떤 기능도 override를 금지하면 해결 가능
  - (138p 두 번째 문제를 해결하려면) 예외를 코드에 포함시키는 것을 통제할 방법이 없음. 예외를 쓰지말자라는 사내 컨벤션 방법밖에 없지 않을까? 코드레벨에서 강제시킬 수가 없으니 이 문제는 막을 수 없다...
  - (138p 세 번째 문제를 해결하려면) 템플릿메서드 또는 전략 패턴 등으로 하위를 강제하게하는 방법이 있다.
  - throw를 쓰지 않는 예외로 프로그래밍하지 않는 세계에서는 Result, Either로 성공과 실패를 값으로 프로그래밍하는 세계도 있다.
- **인터페이스 분리 원칙이 성립하나?**
  - 단일책임을 갖는 인터페이스를 여러 개 갖는 타입이 단일책임일 수 있나?
  - 합성으로 여러 인터페이스를 구현하는 것이 아니라 위임으로 개발해야 하는 것 아닌가?
- 대부분의 행동 패턴은 제어 반전이다.
- **무엇이 어려운 코드인가?**
  - 3.6.2 부분에서 어떤 코드가 쉬워보이나?
  - 구성원 지식 수준에 따라 같은 코드가 어렵기도 쉽기도 하다.
  - 구성원의 지식 수준을 맞출 수 있는가?
  - 그렇다면 최저선에 맞추는 것은 맞는가?
  - 지식수준을 팀의 결정권자가 올리도록 요구하는 것이 맞나?
  - **지식수준을 결정하는 근거**
    - 성능
    - 특정 개인의 취향 또는 판단 (혹은 수준)
    - 남이 쓴다는 이유
    - KISS 원칙 기준은 주관적일 수 밖에 없기 때문에 개인적인 차원으로 느껴진다. 그래서 범용화하고 공용화하려 비용과 에너지를 들이지 않겠다.
    - YAGNI 원칙은 도메인 문제로 느껴진다.
  - **어려운 코드의 제약은 어느 수준의 레이어까지 적용하나?**
    - 기저 레이어의 c++로 된 JNI 모듈도 자바로 고치나?
    - 성능이 중요해지면 기준은 바뀌나?
  - LoD안에 디미터의 법칙
    - LoD : 알 것만 알아라
    - 디미터의 법칙 : 의도치 않게 의존성이 노출될 수 있으니 조심해라
  - 양방향은 제어할 수 없다. **의존성을 단방향으로만 흐르게 해라**
- **읽어보기**
  - [Thread exception handler](https://github.com/HomoEfficio/dev-tips/blob/master/Java-Thread%EB%82%B4%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-Exception-%EC%B2%98%EB%A6%AC.md)


<h3>모듈간 의존 역전이 필요한 이유</h3>

```kotlin
// moduleA
class Runner(val func: Func1) {
  fun exec() {...}
}

// moduleB
class Func1
fun main() {
  Runner(Func1()).exec()
}

// ......

// moduleA
class Runner(val func: Func) {
  fun exec() {..}
}
interface Func

// moduleB
class Func1:Func

fun main() {
  Runner(Func1()).exec()
}
```

# 4주차 모임 - 5장 

- 팀원들에게 좋은 코드를 작성해야겠다는 동기를 어떻게 심어줄 수 있나?
- 테스트 코드의 품질은 어느정도?
  - "비지니스 로직이 변경되는 때마다, 단위테스트들을 전부 대응해줘야 하는데 테스트 코드의 중복을 제거하겠다고 만들어놓은 계층들이 있으면 그걸 분석해서 테스트 케이스를 다시 변경 해야 되는 비용이 더 크다고 생각해요. 테스트 케이스의 반복되는 중복은 허용하는 편 입니다."
  - 테스트 코드는 한 눈에 읽히고 문서를 대신해야 한다.
  - 내가 작성한 함수의 모든 케이스 진리표를 알고 테스트 코드를 작성하냐?
    - 이걸 모르고 테스트 코드를 작성하면 불필요한 케이스를 적거나 커버리지만 채우는 것에 신경쓰게 될 것이다.
  - **내가 작성한 코드의 경우의 수를 인지하는 것이 제일 중요하다.**
- 테스트하기 좋은 코드, 클린 코드는 결국 내부 로직들을 밖으로 다 끄집어내서 외부에서 주입하도록 하는 것

# 5주차 모임 - 6장. 생성 디자인 패턴

- 객체지향에서 생성자는 굉장히 특이하다
  - 생성자 메서드는 추상화할 수 없으니 생성자를 위한 패턴이 필요하다.
  - 가장 중요한 패턴은 커맨드 패턴이다. 추상 팩터리 메서드 패턴,전략 패턴, 컴포지트 패턴도 중요하다.
  - 나머지는 다 비슷하다.
- 디자인 패턴을 UML로 보면 **추상 레퍼, 추상 결과물, 구상 레퍼, 구상 결과물**들이 보일 것이다.
- 타입 시스템은 타입을 추상화할 수 있지만 생성자를 추상화하려면 특정 패턴을 사용할 수 밖에 없다.
  - 자식이나 구현하는 클래스의 생성자 파라미터를 강제할 수가 없기 때문이다.
  - 리플렉션으로 다른 클래스를 생성할 때 파라미터가 없는 생성자가 필요한 것과 같은 패턴
  - 생성자 추상화가 된다면 어떤 모습일까?
  - ```kotlin
    class Test override constructor(val a:Int):ConstructInterface
    ```
- 자바는 언어들 중 동적 로딩에 대해 깊게 연구한 언어다.
- **코드는 짧을수록 좋다.** 어떤 클래스나 함수가 너무 가벼워 보이는 것은 괜찮은 것이다.
  - 무거운 객체가 되지말자.
- **싱글톤 패턴**
  - **지연로딩, 이중잠금**
    - java static이라고 시스팀에 기동할 때 만들어지는 것은 아니다
    - 만약 해당 클래스가 싱글톤 전용 클래스라면 어차피 사용하기 전까지는 로딩되지 않으므로 굳이 복잡한 지연 생성을 구현할 필요가 있나?
  - **열거**
    - 가장 추천되는 것은 enum 싱글톤이다
    - static 보다도 더 먼저 초기화되기 때문에 여러 의존관계를 갖는 싱글톤인 경우 더욱 안전함
    - 인스턴스 개수를 컴파일 타임에 확정짓고 싶을 때 enum을 쓴다
  - **싱글톤 패턴의 대안**
    - 핵심은 언제나 인스턴스 컨텍스트를 유지하는 것
    - 싱글톤 객체는 자원의 유일성을 의미하는 것
    - 싱글톤 객체는 의존성이 코드를 직접 보지 않으면 알 수 없다.
    - 싱글톤 객체를 외부에서 아무나 사용할 수 있게 개방하기 보다는 내부로 감추는 것이 더 좋은 방법이다. 클래스로 한 번 더 감싸라
    - 싱글톤 객체는 외부로 노출되면 의존성 그래프를 다 꺠뜨리고 다닌다.
  - 다중 인스턴스 패턴은 플라이웨이트 패턴이랑 비슷하니 플라이웨이트 패턴을 보는 것을 추천
- **팩터리 패턴**
  - swift에서는 생성자를 강제할 수 있기 떄문에 팩터리 패턴이 필요없다.
  - **단순 팩터리 패턴**
    - 모든 의존성을 코드로 내장한 함수
    - 라우팅테이블로 수렴되며 외부에 Put을 노출
    - OCP의 기본 구현
    - 한 클래스내에 의존성이 너무 많다면 그 `의존성을 클래스로 분리해보라`
  - **팩터리 메소드 패턴**
    - 생성자는 추상화되지 않으므로 인스턴스를 반환하는 함수를 추상화함
    - **각 팩터리 메소드가 개별 구상 객체 생성에 대한 지식을 갖는다.**
    - 사용측에서는 구상 객체 생성에 대한 (거대한)지식을 생략할 수 있다.
    - 엄밀하게는 new 대신 해당 인스턴스를 얻는 인터페이스에 대한 지식만 갖게 하는게 핵심이다.
    - 따라서 팩터리 메소드 내부에 어댑터 객체를 만들거나 미디에이터를 만드는 등의 작동을 내장해도 어차피 외부에는 정해진 인터페이스형을 반환하기만 하면 된다.
    - (DI와 같이) **생성 제어 역전**이라고 보면된다.
    - 팩터리 메소드 패턴이 중요한 것이 아니라 **팩터리 메소드**가 중요하다.
  - **추상 팩터리 (메소드) 패턴**
    - 팩터리 메소드를 다시 한번 추상화하여 여러 인스턴스를 생성하거나 부가 서비스를 추가함
    - 추상 팩터리에 맡길 책임은 매우 다양하다
      - 여러 타입의 인스턴스 생성
      - 내부적인 미디에이터 생성
      - 내부적인 퍼사드 생성
  - **빌더 패턴**
    - 빌더 패턴은 문제를 런타임으로 옮긴다.
    - 안티패턴이다 (맹대표님은 빌더 패턴을 법으로 금지해야 한다.) 
    - 컴파일 타임으로 가져오려면 빌더 조합만큼의 타입을 만들면됨
    - primitive 타입을 받게 되면 해당 인자의 검증을 생성자에서 해야하지만, 참조 타입이라면 해당 값을 검증하는 책임은 참조 타입에 넘어간다.
  - **프로토 타입 패턴**
    - clone을 위임하는 것
    - 불변객체를 지향해라
    - 코틀린에는 프로토타입이 내장되어 있다. data class의 copy 메소드

***

- 파일 경로를 받아 `xml`, `json`, `yaml` 등 확장자에 맞는 parser를 선택하여 옵션 정보를 읽어내는 기능으로 클래스와 함수의 시그니처로 토론을 하는 스터디다.
- 코틀린의 value 클래스 inline 클래스 ❓
- array를 복사하는 것이 빠른 이유가 JNI로 malloc으로 복사하기 때문에 빠르다. 이것을 hotspot을 거친다고 표현한다.