
# 이벤트 소싱

데이터의 상태 변화 전체를 상세히 기록할 수 있다면 데이터의 활용 가치는 훨씬 높아지고 비즈니스에 다양한 기회를 제공할 수 있다.  
고객이 카트에 어떤 물품을 담고 어떤 물품 구매를 망설이는지 확인할 수 있는 것처럼 말이다.  
하지만 데이터를 기록하는 기능을 신중하게 고민하지 않고 설계하면 데이터 분석에 한계가 있음을 알 수 있다.  
  
감사 기능과 이력 기능을 구분해야 한다. 무었을 바꿨는가를 상세하게 기록하기 위해 이전 상태를 분리해서 기록해둔 후 필요할 때 현재 상태와 비교해야 한다.  

1. **단일 테이블에 시퀀스를 이용**하여 변경 전 정보는 그대로 두고 새로운 정보를 시퀀스를 증가시켜 저장하는 방법이다. 추가,삭제,수정을 구분하기 위해 구분 컬럼과 일자를 추가할 수 있다.
2. **상태 테이블과 이력 테이블을 분리**하여 현재 데이터를 이력 테이블에 복사한 후 현재 데이터를 변경하는 방법이다.
3. 위 두 가지 방법은 변경하지 않은 속성을 포함한 데이터의 전체 복사본을 저장하는 단점이 있기에 **변경한 속성 이름과 값의 목록 (delta)만 기록** 하는 방법도 있다.
   - 변경한 속성 목록을 생성하는 로직은 애그리게이트가 최적의 후보다.
   - 변경을 요청한 사용자와 처리 시간도 함께 기록하므로 기본적인 감사 요구사항도 충족한다.

위의 세 가지 방법은 복잡하지 않고 특별한 기법을 사용하지 않으면서 변경한 속성과 값을 정확하게 기록해 현재와 이전 값을 비교할 수 있다.  
하지만 이 방법은 `"누가, 언제, 무엇"`을 변경했는지 비교해 추적할 수 있지만, `어떤 비즈니스 케이스로 상태를 변경했는지`는 알 수 없다.  
  
도메인 주도 설계는 **"도메인 이벤트"** 를 강조한다.  
도메인 이벤트는 앞서 설명한 변경 값을 기록하는 것은 같지만 **변경의 단위를 비즈니스 처리 과정에서 발생한 결과로 정의한다.**  
즉, 이벤트는 사용자가 무엇인가 처리하도록 시스템에 요청한 것임을 알 수 있는 힌트이면서 변경이 발생한 이유임을 알 수 있다.  
예를 들어 고객이 비밀번호 변경을 요청하면 변경 결과를 `Map<String, String>` 따위가 아니라 `PasswordChanged`라는 이벤트 클래스로 정의하는 것이다.  
  
**"이벤트 소싱"**은 도메인에서 발생하는 이벤트를 시스템의 상태 변화로 간주한다.  
이벤트 소싱은 도메인 주도 설계에서 설명한 불변식 유지 단위인 애그리게이트에서 발생한 모든 이벤트를 데이터베이스에 기록한다. (이 이벤트를 저장하는 것 또한 원자적이어야 한다.)  
그렇기에 기록한 도메인 이벤트를 리플레이하면 현재 상태로 다시 복원할 수 있다.  

> 이벤트 소싱은 마이바티스나 자바 영속성 API와 같은 일반적인 데이터베이스 접근 방법과 달리 도메인 객체에 새로운 속성을 추가할 때 데이터베이스 테이블에도 컬럼을 추가해야 하는 [임피던스 불일치](https://sungsoo.github.io/2013/08/21/impedance-mismatch.html)가 없는 장점도 있다.

## 이벤트 소싱 구현

도메인 이벤트를 기록하고 리플레이하는 메커니즘은 애그리게이트에서 이벤트를 처리하는 몇 가지 코딩 규칙이 필요하다.  

> 이벤트 소싱에서는 이벤트를 기록해 놓은 데이터베이스나 파일 시스템을 이벤트 저장소라고 한다.  
> 따라서 일관성을 유지하기 위해 여러 리포지토리를 주입받아 애그리게이트 단위의 트랜잭션을 보장하는 Store를 사용할 수 있다.  

1. 이벤트 소싱은 애그리게이트의 속성을 컬럼으로 관리하지 않고 애그리게이트에서 발생한 도메인 이벤트만 기록한다.  
2. 애그리게이트가 제공하는 메소드를 호출하면 실행 결과인 도메인 이벤트 인스턴스를 생성하고 이벤트 저장소(DB테이블)에 저장하기 전까지는 애그리게이트가 임시로 보관한다.
3. 도메인 이벤트는 과거에 발생한 사건으로 변경할 수 없는 객체여야 하므로 setter는 제공되지 않으며 생성자의 파라미터로 모든 속성을 전달해야 하고 식별자도 생성자에서 할당해야 한다. 재수화를 진행할 때 역직렬화할 이벤트 타입도 같이 저장해야 한다.
4. 애그리게이트는 일관성을 유지해야 하는 단위이므로 Store는 애그리게이트에서 발생한 이벤트를 한 번에 저장하거나 조회해서 애그리게이트를 반환하는 메소드를 제공해야 한다.

## 커맨드와 이벤트

소프트웨어가 어떤 일을 수행하게 하는 의도(목표)를 **커맨드**라고 하고 수행한 결과를 **이벤트**라고 한다.  

- **커맨드**
  - 동기로 처리한다.
  - 행위를 실행하는 방법이다.
  - 사이드 이펙트가 있는 작업이며, 시스템 상태를 변경하는 의도를 가진 메시지이다.
  - 사용자 또는 시스템의 다른 부분에서 생성한다.
  - 주로 동사로 네이밍한다.
  - 유효성 검사를 기술이 아닌 도메인 영역으로 정의하면 커맨드에서 유효성을 검사해 응집도를 높일 수 있다.  
- **이벤트**
  - 비동기로 처리한다.
  - 이미 발생한 사실에 관한 설명이다.
  - 발생한 것이므로 과거형으로 네이밍한다.
  - 이벤트는 시스템 내에서 발생한 것이다.
  - 메소드가 반환한 것이 아닌 명령을 실행한 결과이다.

변경에 따른 영향도를 낮추는 것뿐만 아니라 설계 의도를 명확하게 표현하기 위해 커맨드 객체를 사용하는 것이 좋다.  
즉, 애플리케이션 서비스가 애그리게이트에게 커맨드를 전달하고 처리가 끝나면 애그리게이트에 일시적으로 보관한 이벤트를 이벤트 저장소에 저장하는 처리 흐름이다.  

> 이벤트 소싱은 생각보다 많은 커맨드와 이벤트를 선언해야 하고 커맨드와 이벤트에 속성을 중복으로 선언해야 하는 단점이 있다.

커맨드와 이벤트가 기술 종속적인 요소인가 아니면 기술에 중립적인 요소인가는 논쟁의 대상이다.  
두 객체를 기술적인 요소로 간주하면 모듈간 복잡한 의존성 관리, 도메인 객체로 요청을 전달하는 호출 흐름에서 타입 변환처럼 아키텍처에서 고려해야하는 추가적인 이슈를 해결해야 한다.  
반면 도메인 요소로 분류하면 이런 다양한 이슈의 상당한 부분을 해소할 수 있다. 그러나 완전한 도메인 요소로 분리하는데 한계가 있다.  

## 재수화 (이벤트 리플레이)

도메인 이벤트를 데이터베이스에 빠짐없이 기록했으면 이벤트를 리플레이해 애그리게이트의 현재 상태로 복원할 수 있다.  
재수화를 위해 도메인 이벤트를 애그리게이트에 반영해 현재 상태로 복원하는 코딩 규칙도 필요하다.  
  
시스템은 쓰기보다 읽기 빈도가 훨씬 높은데 이벤트 소싱을 적용하면 다양한 조건으로 데이터를 조회할 때 한계가 있다.  

> 조회 성능과 개발 편의성을 해소하기 위해 도메인 이벤트에서 조회 전용 데이터를 미리 만드는 것을 **"프로젝션"**이라고 한다.

재수화를 실행하기 위해 JPO에서 이벤트 객체로 역직렬화를 해야하는데, 역직렬화의 책임은 대체적으로 JPO가 수행한다.  
도메인 이벤트를 정상적으로 조회하여 역직렬화되었으면 도메인 애그리게이트의 리플레이 메소드인 **이벤트 핸들러**를 통해 실행할 수 있다.  

> 이벤트 소싱에서 이벤트에 반응하는 메소드를 **이벤트 핸들러**라 하고 명령을 처리하는 메서드를 **커맨드 핸들러**라고 한다.

이벤트 소싱을 적용한 마이크로서비스의 핵심 모듈은 `aggregate`, `command`, `event`, `service`, `store` 패키지로 구분한다.  
[예제 패키지 구조](https://github.com/AcornPublishing/microservices-eventsourcing/tree/main/08-commerce/cart/backend/src/main/java/io/cosmos/cart)를 참고하면 된다.  

# 이벤트 소싱 대표적인 문제와 해결 방법

이벤트 개수가 많아질수록 리플레이 시간이 증가하고 메모리 제약으로 모든 이벤트를 조회하는데 한계가 있다.  
또한 같은 애그리게이트를 동시에 변경하는 경우 마지막 커밋이 이전 커밋을 덮어쓰는 문제도 여전히 존재한다.  
마이크로서비스 아키텍처에서 여러 서비스간 변경 요청으로 속성을 추가하거나 삭제하는 이벤트 타입의 변화 또한 고려해야 한다.  
  
## 동시성과 이벤트 충돌

애그리게이트가 제공하는 커맨드 핸들러를 동시에 호출해 발생한 이벤트가 같은 속성을 덮어쓰는 결과를 만들어 내기도 하지만 서로 다른 이벤트가 같은 속성을 덮어써서 일관성을 유지하지 못하기도 한다.  
이벤트 소싱에서 이와 같은 현상을 **이벤트 충돌** 이라고 한다.  
데이터베이스에서 제공하는 비관적 잠금 또는 낙관적 잠금으로 해결한다.  
  
낙관적 잠금을 사용하려면 변경 요청 시 사용자 인터페이스가 애그리게이트의 현재 버전 값을 알고 있어야 한다.  
따라서 첫 번째로 사용자가 애그리게이트를 조회하면 현재 버전 값을 포함한 결과를 반환해야 한다.  
두 번째로 사용자가 애그리게이트 내용을 확인하고 변경을 요청하면 사용자 인터페이스는 애그리게이트의 버전을 커맨드에 포함하여 백엔드에 전달한다.  
그래서 커맨드에 포함된 버전 값과 애그리게이트의 현재 버전 값을 비교하여 서로 다르면 예외를 발생시킨다. (HTTP 500 or 409)  
서로 같으면 비즈니스를 처리하고 버전 값을 증가시킨 후 데이터베이스에 저장한다.  

## 재수화 성능과 스냅샷

재수화는 애그리게이트에서 발생한 도메인 이벤트가 많을수록 시간이 증가하기 때문에 성능에 직접적인 영향을 준다.  
또한 모든 도메인 이벤트 인스턴스를 메모리에 올려야하기 때문에 OOM 우려도 있다.  
재수화 성능을 향상시키면서 메모리를 효율적으로 사용하기 위한 방법이 **스냅샷**이다.  
  
특정 이벤트까지 리플레이한 결과를 별도로 저장해 놓은 일종의 **메모이제이션**이다.  
Snapshot 도메인 클래스를 추가하여 Snapshot 생성에 사용한 마지막 도메인 이벤트 발생시간을 포함시킨다.  
(최근 Snapshot만 관리할 수도 있지만 여러 개의 Snapshot을 관리할 수도 있다.)  
이 Snapshot 클래스를 루트 JPO에 속성으로 추가하고 테이블 컬럼도 추가한다.  
  
`rehydration` 속성을 Event 추상 클래스에 추가하고 JPO에 매핑하여 리플레이 대상 이벤트를 구별할 수 있다.  
  
스냅샷 생성 전략이 있다.  
1. 주기적인 시간
2. 매 N번째 이벤트
3. **도메인 이벤트**
   - 모든 이벤트에 대해 스냅샷을 생성하지 않고 설계 시 스냅샷을 생성할 이벤트를 결정하는 방법
   - 주문은 배송을 완료하면 더 이상 이벤트가 발생하지 않지만 반품/교환처럼 일부 주문에서만 이후 프로세스와 연관된 이벤트가 발생하기 때문에 배송 완료에 이벤트를 생성하는 것이다.
   - 구매 가격의 일부를 포인트로 변환하는 도메인 로직이 있을 때 포인트로 변환하는 적립율은 시간에 따라 변할 수 있는 상수가 될 확률이 높다. 이렇게 변화가 필요한 지점은 코드의 복잡성을 줄이기 위해 도메인 이벤트에 해당 상수를 포함시키는 것을 고려할 수 있다. 아니면 적립 금액 계산 결과를 넣을 수도 있다.

> 도메인 이벤트의 속성을 추가하거나 삭제하는 경우에는 생각보다 많은 것을 고려해야 한다.  
> **업캐스팅**: 이벤트 스토어에 기록한 변경 불가능한 과거 버전의 도메인 이벤트를 현재 버전으로 변환하는 것  
> **업캐스터**: 과거 버전의 이벤트를 현재 버전의 이벤트로 변환하는 책임을 가진 매퍼 클래스  
> (업캐스터를 직접 구현하지 않고 Protocol Buffers와 같이 버저닝을 지원하는 라이브러리를 사용할 수 있다.)  
