
- [`johngrib.github.io` Factory](https://johngrib.github.io/wiki/pattern/factory/)
- [`johngrib.github.io` Static Factory Method](https://johngrib.github.io/wiki/pattern/static-factory-method/)
- [`sumini.dev` Factory Pattern 개념부터 적용까지](https://sumini.dev/til/014-factory/)
- [`culttt.com` What are `Factories` in Domain Driven Design?](https://www.culttt.com/2014/12/24/factories-domain-driven-design/)
- [`culttt.com` What are `Aggregates` in Domain Driven Design?](https://www.culttt.com/2014/12/17/aggregates-domain-driven-design)
- [`martinfowler` DDD_Aggregate](https://martinfowler.com/bliki/DDD_Aggregate.html)
  
![](./imgs/dddOverview.png)
- [출처](https://velog.io/@cks8483/DDDDomain-Driven-Design)

***

# **유비쿼터스 언어**

도메인 전문가, 도메인 분석가 또는 설계자, 개발자가 도메인과 관련된 공통의 언어를 사용하여 한 단어에 대한 생각을 모두 일치시키는 것이다.  
**도메인 용어에 맞지 않는 단어를 사용하면 코드는 도메인과 점점 멀어지게 된다**  


```java
public enum OrderState{
  STEP1,STEP2,STEP3,STEP4,STEP5,STEP6;
}

public enum OrderState{
  PAYMENT_WAITING,PREPARING,SHIPPED,DELIVERING,DELIVERY_COMPLETED;
}
```

# **모델**

모델이란 **대상 도메인에 대한 내부적 표현으로서 설계와 개발 프로세스 내내 반드시 필요하다.**

# **계층형 아키텍처**

```
사용자 인터페이스 | 애플리케이션 | 도메인 | 인프라스트럭처
```
- **애플리케이션 레이어** 는 업무 로직을 포함하지 않는 얇은 레이어다. 비즈니스 객체의 상태를 보관하지 않지만, **애플리케이션 작업의 처리 상태는 보관한다.**
- **도메인 레이어** 는 업무 소프트웨어의 심장에 해당한다. 비즈니스 객체의 상태를 포함한다.
- **인프라스트럭처** 는 다른 레이어 모두를 지원하는 라이브러리로 동작한다. 레이어 간의 통신을 제공하고 비즈니스 객체의 영속성을 구현한다.
  
복잡한 프로그램을 **레이어** 로 분할해야 한다.  
각 레이어 내부에서 설계를 수행하여 응집도 높고 **자기 하위 레이어에만 의존하도록 만들어야 한다.**  
예를 들어, 하나의 레이어에 도메인과 관련된 모든 코드를 집중시켜서, 사용자 인터페이스, 애플리케이션, 인프라스터럭처 코드로부터 독립적으로 만들어야 한다.  
  
**도메인 객체들은 스스로 정보를 보여주고 저장하고 애플리케이션 작업을 관리하는 등의 부가적인 책임에서 자유롭게 두고, 대신 도메인 모델 자체를 표현하는 것에만 집중할 수 있도록 한다.**  

# **도메인**
- 소프트웨어로 해결하고자 하는 **문제 영역**
- 한 도메인은 다시 하위 도메인으로 나눌 수 있다
  - 한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공
- **도메인 모델 패턴**
  1. `Presentation`**표현** *또는 사용자 인터페이스*
     - 클라이언트의 요청을 처리 또는 응답
  2. `Application` **응용**
     - 요청한 기능을 실행
     - `업무로직을 직접 구현하지 않고` **도메인 계층을 조합해서 기능을 실행**
  3. `Domain` **도메인**
     - 도메인 모델의 핵심 로직을 구현
  4. `Infrastructure` **인프라스트럭처**
     - DB나 메시징 시스템과 같은 외부 시스템과의 연동
     - *[Drools](http://www.opennaru.com/jboss/dynamically-create-rules-using-drools/)*

- 도메인의 복잡도에 따라 **응용**계층이 **인프라스트럭처**계층에 의존하기도 한다
  - 이런 의존은 `테스트 어려움` , `기능 확장의 어려움` 두 가지 문제가 발생한다

<br>

- **도메인 모델**이란?
  - 도메인 자체를 표현하는 개념적인 모델을 의미하지만,
  - 도메인 계층을 구현할 때 사용하는 객체 모델을 언급할 때에도 사용한다

<br>

- **도메인 모델에서 `Getter` , `Setter`는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다**
  - 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 `생성 시점에 필요한 것을 전달해 주어야 한다`
- 도출한 모델은 크게 **엔티티**와 **밸류**로 구분할 수 있다


# **엔티티**

엔티티는 도메인 모델에서 매우 중요한 객체들이고, 모델링 작업을 시작할 때부터 깊이 고민해야 할 부분이다.  
  
소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 **식별자** 를 지니는 유형의 객체이다.  
**식별자가 같은 두 객체는 같다고 간주한다.** 만약 이러한 전제가 만족되지 못한다면 전체 시스템은 오류에 빠진다.  


# **값 객체**

하나의 객체가 도메인의 어떠한 측면을 표현하는 데 사용되지만 식별자가 없는 경우에 이것을 **값 객체** 라고 부른다.  
식별자가 없는 값 객체는 쉽게 생성되고 폐기할 수 있다.  
값 객체 자체의 설계는 단순하게 만들며, 값 객체의 속성은 불변이어야 한다.  

# **서비스**

우리가 도메인을 분석하여 모델을 구성하는 주요 객체를 정의하려고 할 때 도메인의 어떤 부분들은 객체로 쉽게 매핑될 수 없다는 것을 알게된다.  
객체는 속성과 객체가 관리하는 내부 상태 정보와 밖으로 드러나는 행위를 가지고 있다.  
  
서비스는 도메인 레이어에서 사용되기도 하며, 서비스는 서비스를 수행하는 객체 자신이 아니라 **오퍼레이션이 수행되는 대상이나, 목적이 되는 객체와 관련이 있다.**  
서비스는 이러한 방식으로 많은 객체가 관계를 맺는 지점이 된다.  
  
1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다.
2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.
3. 오퍼레이션은 상태를 저장하지 않는다.

도메인에서 주요 처리나 변경을 수행하는 작업을 발견헀는데, 엔티티나 값 객체의 책임은 아니라면, 이를 서비스로서 독립적인 인터페이스의 오퍼레이션으로 추가한다.  
**서비스를 사용할 때 도메인 레이어를 분리시켜야 한다는 점은 매우 중요하다.**  
  
서비스는 도메인 레이어, 인프라스트럭처 레이어, 애플리케이션 레이어 어디에도 존재할 수 있는데, 도메인 레이어에 존재하는 서비스들과 구분하기는 매우 어렵다.  
중요한 점은 서비스가 **어떤 성격을 띄고 어떤 책임을 가지는지** 잘 구분해야 한다.  

# **모듈**

규모가 큰 애플리케이션인 경우 모델은 점점 더 커지게 된다.  
이때 모델은 모듈로 나누어 구조화할 필요가 있다.  
**모듈화란, 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다.**  
설계에서 모듈을 사용할 때는 응집도는 높이고 결합도는 낮추는 방향으로 적용해야 한다.  
  
> **통신 응집도** 는 모듈의 일부가 같은 데이터를 다룰 때 얻을 수 있다. 관계가 견고하기 때문에 그룹핑하는 것이 당연하다.  
> **기능 응집도** 는 모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어지며, 이것은 최고의 응집도라 할 수 있다.

# **집합**

