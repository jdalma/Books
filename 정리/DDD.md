
- [`johngrib.github.io` Factory](https://johngrib.github.io/wiki/pattern/factory/)
- [`johngrib.github.io` Static Factory Method](https://johngrib.github.io/wiki/pattern/static-factory-method/)
- [`sumini.dev` Factory Pattern 개념부터 적용까지](https://sumini.dev/til/014-factory/)
- [`culttt.com` What are `Factories` in Domain Driven Design?](https://www.culttt.com/2014/12/24/factories-domain-driven-design/)
- [`culttt.com` What are `Aggregates` in Domain Driven Design?](https://www.culttt.com/2014/12/17/aggregates-domain-driven-design)
- [`martinfowler` DDD_Aggregate](https://martinfowler.com/bliki/DDD_Aggregate.html)
  
![](./imgs/dddOverview.png)
- [출처](https://velog.io/@cks8483/DDDDomain-Driven-Design)

***

# **유비쿼터스 언어**

도메인 전문가, 도메인 분석가 또는 설계자, 개발자가 도메인과 관련된 공통의 언어를 사용하여 한 단어에 대한 생각을 모두 일치시키는 것이다.  
**도메인 용어에 맞지 않는 단어를 사용하면 코드는 도메인과 점점 멀어지게 된다**  


```java
public enum OrderState{
  STEP1,STEP2,STEP3,STEP4,STEP5,STEP6;
}

public enum OrderState{
  PAYMENT_WAITING,PREPARING,SHIPPED,DELIVERING,DELIVERY_COMPLETED;
}
```

# **모델**

모델이란 **대상 도메인에 대한 내부적 표현으로서 설계와 개발 프로세스 내내 반드시 필요하다.**

# **계층형 아키텍처**

```
사용자 인터페이스 | 애플리케이션 | 도메인 | 인프라스트럭처
```
- **애플리케이션 레이어** 는 업무 로직을 포함하지 않는 얇은 레이어다. 비즈니스 객체의 상태를 보관하지 않지만, **애플리케이션 작업의 처리 상태는 보관한다.**
- **도메인 레이어** 는 업무 소프트웨어의 심장에 해당한다. 비즈니스 객체의 상태를 포함한다.
- **인프라스트럭처** 는 다른 레이어 모두를 지원하는 라이브러리로 동작한다. 레이어 간의 통신을 제공하고 비즈니스 객체의 영속성을 구현한다.
  
복잡한 프로그램을 **레이어** 로 분할해야 한다.  
각 레이어 내부에서 설계를 수행하여 응집도 높고 **자기 하위 레이어에만 의존하도록 만들어야 한다.**  
예를 들어, 하나의 레이어에 도메인과 관련된 모든 코드를 집중시켜서, 사용자 인터페이스, 애플리케이션, 인프라스터럭처 코드로부터 독립적으로 만들어야 한다.  
  
**도메인 객체들은 스스로 정보를 보여주고 저장하고 애플리케이션 작업을 관리하는 등의 부가적인 책임에서 자유롭게 두고, 대신 도메인 모델 자체를 표현하는 것에만 집중할 수 있도록 한다.**  

# **엔티티**

엔티티는 도메인 모델에서 매우 중요한 객체들이고, 모델링 작업을 시작할 때부터 깊이 고민해야 할 부분이다.  
  
소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 **식별자** 를 지니는 유형의 객체이다.  
**식별자가 같은 두 객체는 같다고 간주한다.** 만약 이러한 전제가 만족되지 못한다면 전체 시스템은 오류에 빠진다.  


# **값 객체**

하나의 객체가 도메인의 어떠한 측면을 표현하는 데 사용되지만 식별자가 없는 경우에 이것을 **값 객체** 라고 부른다.  
식별자가 없는 값 객체는 쉽게 생성되고 폐기할 수 있다.  
값 객체 자체의 설계는 단순하게 만들며, 값 객체의 속성은 불변이어야 한다.  

# **서비스**

우리가 도메인을 분석하여 모델을 구성하는 주요 객체를 정의하려고 할 때 도메인의 어떤 부분들은 객체로 쉽게 매핑될 수 없다는 것을 알게된다.  
객체는 속성과 객체가 관리하는 내부 상태 정보와 밖으로 드러나는 행위를 가지고 있다.  
  
서비스는 도메인 레이어에서 사용되기도 하며, 서비스는 서비스를 수행하는 객체 자신이 아니라 **오퍼레이션이 수행되는 대상이나, 목적이 되는 객체와 관련이 있다.**  
서비스는 이러한 방식으로 많은 객체가 관계를 맺는 지점이 된다.  
  
1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다.
2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.
3. 오퍼레이션은 상태를 저장하지 않는다.

도메인에서 주요 처리나 변경을 수행하는 작업을 발견헀는데, 엔티티나 값 객체의 책임은 아니라면, 이를 서비스로서 독립적인 인터페이스의 오퍼레이션으로 추가한다.  
**서비스를 사용할 때 도메인 레이어를 분리시켜야 한다는 점은 매우 중요하다.**  
  
서비스는 도메인 레이어, 인프라스트럭처 레이어, 애플리케이션 레이어 어디에도 존재할 수 있는데, 도메인 레이어에 존재하는 서비스들과 구분하기는 매우 어렵다.  
중요한 점은 서비스가 **어떤 성격을 띄고 어떤 책임을 가지는지** 잘 구분해야 한다.  

# **모듈**

규모가 큰 애플리케이션인 경우 모델은 점점 더 커지게 된다.  
이때 모델은 모듈로 나누어 구조화할 필요가 있다.  
**모듈화란, 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다.**  
설계에서 모듈을 사용할 때는 응집도는 높이고 결합도는 낮추는 방향으로 적용해야 한다.  
  
> **통신 응집도** 는 모듈의 일부가 같은 데이터를 다룰 때 얻을 수 있다. 관계가 견고하기 때문에 그룹핑하는 것이 당연하다.  
> **기능 응집도** 는 모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어지며, 이것은 최고의 응집도라 할 수 있다.

# **집합**

**도메인 객체의 생명주기를 다루는 것으로, 이것은 모델링의 또 다른 면에 속한 도전과제라 할 수 있다.**  
도메인 객체는 생명주기 동안 여러 가지 상태를 거치게 되는데 이 생명주기 관리라는 과제를 잘 다루기 위하여 세 가지 패턴을 소개한다.  

1. **Aggregate 집합**
   1. 설계를 하게되면 수많은 객체들이 복잡하게 연관되어 관계망이 형성된다.
   2. 양방향 관계는 단방향 관계로 대체될 수 있으니 객체들간의 관계는 단순화를 유지해야한다.
   3. 불변식을 따르도록 강제해야 한다.
   4. **집합은 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체들의 집합이다.**
   5. **집합은 하나의 객체의 외부와 내부를 가르는 경계를 정해 구분한다.**
   6. 각 집합은 하나의 `root`를 가지고, `root`는 엔티티이고 외부에서 접근할 수 있는 창구다.
   7. `root`는 집합된 다른 객체들에 대한 참조를 담고 있으며, 다른 객체들은 서로 관계를 맺고 있다.
   8. **객체의 외부에서는 `root` 객체를 통해서만 참조할 수 있다.**
2. **Factory 팩토리**
   1. 엔티티와 집합은 종종 `root` 엔티티의 생성자를 통해 생성하기에는 너무 크고 복잡하다.
   2. 복잡한 집합을 자신의 생성자를 이용해 만들어 내려는 시도는, 실제 도메인의 처리 방식과는 정반대 방식이다.
   3. 실제 도메인에서는 **사물이 외부의 다른 사물에 의해 생성된다.** (자신의 생성자를 통해 스스로를 생성하려는 시도는 마치 프린터가 자기 자신을 생성하려고 하는 것과도 같다.)
   4. 하나의 객체를 생성하는 것은 그 자체로 **주요 오퍼레이션**에 해당하지만, 복잡하게 조합된 오퍼레이션을 이미 생성된 객체가 부담하게 하는 것은 적절하지 않다.
   5. 이러한 책임들을 생성된 객체와 결합시키는 것은 이해하기 어려운 조악한 설계를 낳는다.
   6. 따라서 **복잡한 객체 생성의 절차를 캡슐화 할 수 있는 팩토리가 도입될 필요가 있다.**
   7. 중요한 것은, 생성 절차를 **쪼갤 수 없는 원자적인 상태로 작성해야 한다.**
   8. 복잡한 객체와 집합 객체를 생성하는 책무를 별도의 객체에 맡겨야 한다. 그 자신은 도메인 모델 내에 어떠한 책임을 지지 않으면서도 여전히 도메인 설계의 일부인, 그런 객체 말이다.
   9. **모든 복잡한 조합을 캡슐화하고, 클라이언트가 인스턴스화된 객체들의 구체적인 클래스를 참조할 필요가 없는 인터페이스를 제공해야 한다.**
   10. **전체 집합을 한 단위로 생성하고 불변식을 보장할 수 있어야 한다.**
   11. 다만 팩토리를 생성할 때는, 객체의 캡슐화를 깨뜨리기 때문에 매우 주의해서 작업해야 한다.
   12. **엔티티 팩토리와 값 객체 팩토리는 다르다. 엔티티는 변경될 수 있지만 값은 불변이기 때문이다.**
   13. 아래와 같은 경우에는 팩토리 대신 생성자를 사용할 수 있다.
       1.  생성 작업이 복잡하지 않다
       2.  객체의 생성이 다른 객체의 생성과 연관되어 있지 않으며 모든 속성이 생성자를 통해 전달되어야 한다.
       3.  클라이언트가 구현에 관심이 있어서, 사용할 전략 패턴을 선택하려고 한다.
       4.  클래스가 바로 해당 타입이다. 관련된 계층 구조가 없어서 concrete 구현 목록에서 선택할 필요가 없다.
3. **Repository 리포지토리**
   1. 객체지향 언어에서는 하나의 객체를 사용하기 위해서 반드시 다른 객체가 해당 객체의 참조 주소를 가지고 있어야만 한다.
   2. 이러한 참조를 얻고자 클라이언트는 객체를 직접 생성하거나 다른 객체에 존재하는 연관 관계를 추적한다.
   3. 예를 들어, 집합의 값 객체를 얻기 위해 클라이언트는 집합의 `root`를 얻어야만 한다.
   4. 이때 클라이언트는 `root`에 대한 참조를 어떻게 얻을 것인가?
   5. **객체의 참조를 얻는 로직을 캡슐화하기 위해 리파지토리를 사용한다.** 이렇게 하면 도메인 객체가 도메인의 다른 객체의 참조를 얻고자 인프라스트럭처를 참조할 필요가 없어진다.
   6. **도메인 모델이 객체의 저장이나 참조와 연관을 없애고 하부의 영속성을 보장하는 인프라스트럭처에 접근할 필요가 없도록 하는 것이 리파지토리의 전반적인 효과다.**
   7. **직접 접근할 필요가 있는 집합 `root`에 대해서만 리파지토리를 제공한다.**
      1. 클라이언트는 모델에만 집중하도록 하고 객체의 저장이나 접근과 관련된 내용은 리파지토리에 위임한다.
   8. 리파지토리는 인프라스트럭처의 구현과 매우 유사해지지만, 리파지토리 인터페이스 자체는 순수하게 도메인 모델이다.
   9. 팩토리와 리포지토리 둘은 모두 모델 중심 설계의 패턴이고, 도메인 객체의 생명주기를 관리하는 역할을 한다.
      1.  팩토리는 객체의 생성과 관여하는 반면에, 리포지토리는 이미 존재하는 객체들을 관리한다.

# **도메인**
소프트웨어로 해결하고자 하는 **문제 영역**  
한 도메인은 다시 하위 도메인으로 나눌 수 있다  
한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공  
  
**도메인 계층은 엔티티와 값 객체에 적용될 비즈니스 규칙을 담고 있다.**  
  
- **도메인 모델 패턴**
  1. `Presentation`**표현** *또는 사용자 인터페이스*
     - 클라이언트의 요청을 처리 또는 응답
  2. `Application` **응용**
     - 요청한 기능을 실행
     - `업무로직을 직접 구현하지 않고` **도메인 계층을 조합해서 기능을 실행**
  3. `Domain` **도메인**
     - 도메인 모델의 핵심 로직을 구현
  4. `Infrastructure` **인프라스트럭처**
     - DB나 메시징 시스템과 같은 외부 시스템과의 연동
     - *[Drools](http://www.opennaru.com/jboss/dynamically-create-rules-using-drools/)*

- 도메인의 복잡도에 따라 **응용**계층이 **인프라스트럭처**계층에 의존하기도 한다
  - 이런 의존은 `테스트 어려움` , `기능 확장의 어려움` 두 가지 문제가 발생한다

<br>

- **도메인 모델**이란?
  - 도메인 자체를 표현하는 개념적인 모델을 의미하지만,
  - 도메인 계층을 구현할 때 사용하는 객체 모델을 언급할 때에도 사용한다

<br>

- **도메인 모델에서 `Getter` , `Setter`는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다**
  - 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 `생성 시점에 필요한 것을 전달해 주어야 한다`
- 도출한 모델은 크게 **엔티티**와 **밸류**로 구분할 수 있다