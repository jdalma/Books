
> 신뢰할 수 없는 테스트는 심각한 문제를 발생시키며, 이런 테스트는 귀중한 시간을 낭비한다.  

# 단위 테스트

단일 메서드, 클래스 또는 독립된 기능을 테스트하며, 개발자에게 코드가 설계대로 동작한다는 확신을 준다.  
테스트를 빠르고, 상태를 유지하는 것을 포함한 다양한 이유로, 때때로 단위 테스트는 데이터베이스와 다른 외부 의존성을 "스텁으로 만드는" 경우가 있다. <sup>[1](#devops)</sup>  

> "stub" , "mocks" , "service virtualization"  
> - 외부의 통합 지점으로부터 입력이 필요한 테스트 문제를 처리하기 위해 사용되는 다양한 범주의 아키텍처 기법들과 테스팅 기법이 있다.  
> - 이런 기법은 외부의 상태에 더 많이 의존하는 승인 테스팅과 통합 테스팅에서 더 중요하다.
  
**단위 테스트 코드를 작성하는 이유**<sup>[2](#designpattern)</sup>  
1. 단위 테스트는 프로그래머가 코드에서 버그를 찾는데 도움이 될 수 있다.
2. 단위 테스트는 프로그래머가 코드 설계에서 문제를 찾는데 도움이 될 수 있다.
   - 단위 테스트를 통해 코드 설계의 문제점을 적시에 찾을 수 있다.
3. 단위 테스트는 통합 테스트를 보완하는 강력한 도구다.
   - 물론 단위 테스트가 통합 테스트를 완전히 대채할 수는 없지만 모든 클래스와 함수가 예상대로 실행된다는 것을 보장할 수 있다면 전체 시스템에 문제가 발생할 가능성이 줄어든다.
4. 단위 테스트 코드를 작성하는 과정은 코드 리팩터링 과정에 해당한다.
   - 실제로 단위 테스트 코드를 작성하는 것은 현장에서 지속적인 리팩터링을 수행하는 효과적인 방법이다.
5. 단위 테스트는 프로그래머가 코드에 빠르게 익숙해지도록 도와준다.
   - 일부 프로그래머는 문서를 작성하고 주석을 추가하는 것을 좋아하지 않기 때문에, 이 경우 단위 테스트 문서와 주석의 역할을 대신할 수 있다.
6. 단위 테스트는 테스트 주도 개발을 개선하고 대체할 수 있다.
7. 단위 테스트 코드의 품질은 그렇게 신경 쓰진 않아도 된.
8. 단위 테스트의 커버리지는 쉽게 정량화할 수 있지만 테스트 품질을 측정하는 유일한 척도로 사용되어서는 안된다.
   - 커버리지 보단 엣지케이스에 신경써야 한다.
9. 단위 테스트를 작성할 클래스가 높은 응집도와 낮은 결합도를 만족하는지에 달려 있다.

<h3>단위 테스트를 작성하기 어려운 이유</h3>

날이 갈수록 더 많은 사람들이 단위 테스트의 중요성을 깨닫고 있지만 실제로 실행에 옮기는 사람은 많지 않고, 단위 테스트를 활용하지도 않는다.  
단위 테스트 코드의 작성은 작성하기도 번거롭고, 그렇다고 특별한 기술을 습득할 수 있는 것도 아니기 때문에 인내심을 테스트하는 일이기도 하다.  
그리고 테스트 팀이 있기 때문에, 개발자가 별도로 단위 테스트를 작성하는 것은 순전히 시간 낭비이며 불필요하다고 느끼는 사람들이 있을 수 있다.  
**프로그래머는 단위 테스트의 이점을 진정으로 느낄 때만 이를 인식하고 사용할 수 있다.**  

<h3>테스트가 불가능한 코드</h3>

1. 보류 중인 동작
   - 코드의 출력이 무작위이거나 불확실하며 대부분 시간 및 난수와 관련이 있음을 의미한다.
2. 전역 변수
   - 상태를 공유하는 전역 변수를 잘못 사용하면 단위 테스트를 설계하기가 어렵다.
   - 테스트 실행 순서는 보장되지 않으며 멀티 스레드로 동시에 실행 시킬수도 있기 때문이다.
3. 정적 메서드
   - 정적 메서드는 모의 구현이 어렵기 때문에 테스트 용이성이 떨어지는 경우가 간혹 있을 수 있다.
   - `Math.abs()`와 같은 간단한 정적 메서드는 테스트 용이성에 영향을 미치지 않는다.
4. 복잡한 상속 관계
   - 상위 클래스에서 단위 테스트를 위해 종속 객체를 모의 구현해야 하는 경우, 이 상위 클래스를 상속받는 모든 하위 클래스의 단위 테스트 코드에서 이 종속 객체를 전부 모의 구현해야 한다.

# 승인 테스트

높은 수준의 기능이 설계한대로 동작(예를 들어, 사용자 스토리에 대한 비즈니스 승인 기준, API의 정확성)하고, 회귀 오류가 발생하지 않는다는 사실(이전에 올바르게 동작하던 기능이 망가진 경우)을 확인하기 위해 애플리케이션을 전체적으로 테스트한다. <sup>[1](#devops)</sup>  

> **단위 테스트와 승인 테스트의 차이점**  
> - 단위 테스트의 목적은 애플리케이션의 한 부분이 프로그래머가 의도한 대로 동작하는지 증명하는 것이다.  
> - 승인 테스트의 목적은 애플리케이션이 고객의 의도대로 동작하는 것을 증명하는 것이지 프로그래머가 생각한 대로 동작하는 것을 증명하는 것이 아니다.
  
빌드가 단위 테스트를 통과하면, 배포 파이프라인은 승인 테스트를 실행한다.  
일반적으로, 승인 테스트를 통과한 빌드는 통합 테스팅은 물론 수동 테스팅(UI 테스팅등)에도 사용할 수 있다.  

# 통합 테스트

스텁으로 된 인터페이스를 호출하는 것과 달리, 애플리케이션이 다른 프로덕션 애플리케이션 및 서비스와 올바르게 상호 작용하는 것을 보장하는 테스트다.  
통합 테스트는 단위 테스트와 승인 테스트를 통과한 빌드 결과에 대해 수행된다.  
통합 테스트는 때때로 취약하기 때문에 통합 테스트의 개수를 최소화해야 한다.<sup>[1](#devops)</sup>

# 출시, 배포?

지속적인 전달? 지속적인 배포?  
이 두 용어를 혼동하는 사람이 많다. 우리가 관심을 가져야하는 핵심 사항은 형식이 아니라 결과다.  
배포는 필요할 때 수행할 수 있는 **낮은 위험의 푸시버튼 이벤트**여야 한다.  
  
> "**지속적인 전달을 수행한다는 것**은 모든 개발자가 트렁크에 대한 작은 규모의 배치 작업을 하거나 모두가 정기적으로 트렁크에 병합되는 기능 브랜치에서 작업하고, 트렁크가 항상 출시 가능한 상태를 유지하는 것"

- **배포** : 주어진 환경에 소프트웨어의 특정 버전을 설치하는 것이다. (코드를 통합 테스트 환경으로 배포하거나 프로덕션 환경으로 배포) 특히, 고객에게 기능을 출시하는 것과 밀접하게 관련돼 있다.
- **출시** : 모든 고객이나 고객 세그먼트에 기능을 사용할 수 있도록 만드는 행위다. (고객의 5%가 기능을 사용할 수 있도록)

# `@Transactional` 롤백 테스트에 대해서

토비님의 페이스 북 글을 시작으로 롤백 테스트에 대한 이야기가 화두가 된적이 있다.  

<iframe src="https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Ftobyilee%2Fposts%2Fpfbid037RXRFuBUQrYZTYZjbJxSKY1rGYZ1eCPK4NKjcQyL52Dzi8ck5Kv74Z1nXm7LWSyBl&show_text=true&width=500" width="500" height="570" style="border:none;overflow:hidden" scrolling="no" frameborder="0" allowfullscreen="true" allow="autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share"></iframe>

- [테스트 데이터 초기화에 @Transactional 사용하는 것에 대한 생각](https://jojoldu.tistory.com/761)
  
요즘 Testcontainers를 접하면서 인메모리 DB나 테스트 DB를 대상으로 하지 않고 테스트가 실행될 때 필요한 DB를 컨테이너로 실행시키는 방식을 사용하려 한다.  
자동 롤백을 사용하지 않고 테스트 Fixture 준비 코드만 직접 작성하는 편이다.  
  
테스트에 실제 DB를 대상으로 `@Transactional`을 사용하여 자동 롤백을 사용할 것인가? 아니면 내장 DB를 이용하여 사용하고 버려버릴 것인가?가 이 내용의 핵심이다.  
다른 분들의 의견을 먼저 들어보자.  
  
**제미니님**은 실제 실행환경과 통합 테스트를 실행한 경우 동작이 다른 경우가 있기에 90%는 테스트에 트랜잭션을 걸지 않는다.  
그래서 테스트간 커밋 결과가 다른 테스트에 영향을 주지 않도록 데이터 충돌이 나지 않게 테스트를 구성하는 편이다.  
즉, 각자 테스트가 돌던 병렬로 동시에 실행되던 독립적인 테스트가 진행되도록 테스트를 구성하는 편이다. 중요한 것은 **가능한 테스트와 실제 서버의 동작이 동일하도록 하는 것이다.**  
테스트 데이터를 제네레이션하는 빈을 따로 생성하여 추가적인 테스트 데이터가 필요하다면 초기 세팅을 추가한다고 한다.  
  
**토비님**은 내장 DB를 사용하는 자체가 테스트 환경과 운영 환경이 서로 다르게 동작할 수 있는 대표적인 원인이다.  
만약 내장 DB나 가상 DB를 사용하여 테스트 코드를 작성하면 클린 업 코드를 작성하지 않기에 해당 테스트가 운영 DB에서 실행되게 된다면 문제가 발생할 수 밖에 없다.  
그리고 데이터의 식별자를 서로 다르게 해서 테스트 간의 데이터 충돌을 막는 것은 좋은 아이디어이지만, 다른 팀원들이 이를 의식하고 테스트 코드를 작성해야 한다는 부담이 있다.  
`@Transactional`을 통한 개개인의 난감한 장애의 경험으로 자동 롤백을 꺼려할 수 있지만, 자동 롤백을 사용하지 않는 테스트 코드 작성 기법은 팀원들이 많아질수록 다른 부가적인 비용을 발생시킨다.  
  
**동욱님**은 테스트 코드에서 `@Transactional`을 믿고 사용했을 때 발생하는 문제점들을 설명한다.  
`"의도치 않은 트랜잭션 적용"`, `"트랜잭션 전파 속성을 조절한 테스트 롤백 실패"`, `"비동기 메서드 테스트 롤백 실패"`, `"TransactionalEventListener 동작 실패"` 와 같이 일반적인 트랜잭션 방법을 적용한 부분을 테스트에서 `@Transactional`을 사용하는 것은 문제가 없지만 **일반적이지 않고 트랜잭션과 관련된 기능이 추가적으로 존재하는 부분을 `@Transactional`을 적용하면 문제가 발생할 수 있다고 강조한다.**  
스프링 팀에서도 `@Transactional`을 테스트 코드에 사용 중이기 때문에 안티 패턴은 아니다. 하지만 위와 같은 문제 때문에 주의가 필요하다는 입장이다.  
데이터 초기화는 **명시적 초기화하는 메서드를 선언해서 사용하길 권장한다.**  
  
정답은 없어보이지만 개인적으로는 테스트에서 `@Transactional`을 쓰면 안된다기 보다는 간단한 곳에는 써도 괜찮을 것 같다.  

***

<a name="devops">1</a>: 데브옵스 핸드북 (3부 - 빠르고 신뢰도가 높으며 자동화된 검증 테스트 스위트를 만들어라)  
<a name="designpattern">2</a>: 디자인패턴의 아름다움

