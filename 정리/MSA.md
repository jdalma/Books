
> 모노리스 아키텍처는 데이터 일관성을 유지하기 위해 데이터베이스 트랜잭션 (ACID)에 전적으로 의존한다.  
> 마이크로서비스 아키텍처는 ACID와는 다르게 가용성을 더 중요하게 여기는 분산 시스템에 적합한 BASE(basically available/soft state/eventually consistency)를 사용한다.  
> BASE는 CAP 이론에 기반한 접근으로 **애그리게이트 상태 변경에만 ACID를 사용하고 애그리게이트간에는 결과적 일관성을 사용한다.**  
> 예를 들어, 주문 프로세스에 참여하는 마이크로서비스는 주문의 상태를 대기/처리 중/완료와 같이 soft state로 프로세스의 진행과 완료를 관리하고 카프카로 대표되는 브로커를 활용해 메시지를 주고 받으면서 결과적 일관성을 달성한다.  
> 이벤트를 사용하면 요청-응답간 대기 시간을 감소시키고 데이터베이스 잠금을 더 짧게 사용하므로 더 많은 요청을 처리할 수 있다.

헥사고날 아키텍처는 기술에 의존하는 구성 요소인 어댑터에 서비스간 협력을 위한 책임을 부여한다.  
마이크로서비스는 협력에 참여하는 마이크로서비스가 제공하는 REST API를 호출하거나 메시지 브로커에 이벤트를 발행해서 통신한다.  
협력 요청을 받은 인바운드 어댑터는 애플리케이션 서비스에 위임해 비즈니스 로직을 처리한다.  
반대로 비즈니스 로직을 처리하는 중간 또는 완료 후에 다른 마이크로서비스와 협력을 위해 아웃바운드 어댑터를 사용한다.  
  
# 일관성과 마이크로서비스 분리 및 통합

마이크로서비스를 분리하는 기준으로 **비즈니스 능력** 과 **서브 도메인** 패턴 또는 **유스케이스, 변동성, 기술로 접근하는 방법** 을 설명하는 책이 많지만 한 가지 접근 방법을 선택해서 서비스를 정확하게 분리할 수 없다.  
시스템 구축 초반에 식별한 마이크로서비스는 시간이 지나면서 더 작은 마이크로서비스로 분할하거나 반대로 통합이 필요한 상황을 만나게 된다.  
여러 애그리게이트간 일관성을 단일 트랜잭션으로 처리하는 마이크로서비스를 분할하려면 결과적 일관성을 적용하기 위해 많은 노력이 필요하다.  
  
(이벤트 소싱과 MSA 1장의) 애그리게이트 설계 규칙 중 하나인 이벤트를 사용해 애그리게이트간에 일관성을 유지하면 단순한 소스 이동만으로 마이크로서비스를 분할하거나 통합할 수 있다.  
따라서 **명확하지 않은 애그리게이트는 비교적 큰 마이크로서비스로 개발하더라도 결과적 일관성을 적용하고, 도메인을 더 깊이 이해하고 필요할 때 분할하는 전략을 선택하는 것이 좋다.**  


# 인바운드 어댑터와 RESTful API

어댑터는 비즈니스 로직을 포함하면 안되고 외부 요청을 받아 애플리케이션 서비스에 요청을 위임하는 책임만 가진다.  
애그리게이트를 중심으로 HTTP 프로토콜이 제공하는 URL, HTTP 메소드를 활용한 설계 방법을 알아보자.  
헥사고날 아키텍처에서 외부 요청을 받는 인바운드 어댑터인 RESTful API의 모듈은 endpoint 패키지에 위치되며 애그리게이트 단위로 분리한다.  

## HTTP 메소드

URL은 자원을 기준으로 목록과 단일 엔티티를 다루고 명사를 사용한다.  

- `/cart`
  - `POST` : 새로운 자원 생성
  - `GET` : 자원 목록 조회
  - `PUT` : 자원 대량 업데이트
  - `DELETE` : 모든 자원 삭제
- `/cart/{itemId}`
  - `POST` : 오류
  - `GET` : 상세 조회
  - `PUT` : 자원이 있으면 업데이트, 없으면 에러 (item 수량을 변경)
  - `DELETE` : 자원 삭제

> `PATCH`는 엔티티의 일부 속성을 변경하는 메소드로 `PUT` 메소드와 구분해야 하지만 여기에서는 사용되지 않는다.

## 애그리게이트와 URL

예를 들어, `/cart/{itemId}`의 PUT 메소드를 통해 수량 변경을 위한 API와 옵션 변경을 위한 API를 구분하기위해서는 어떻게 해야할까?  
(`/cart/{itemId}/changeOption`과 같은 동사는 RESTful API 네이밍 스타일 중 명사를 사용해야 하는 요건을 충족하지 못한다.)  
  
해결 방법으로는 도메인 주도 설계에서 애그리게이트는 상태 변경을 단일 트랜잭션으로 설계하고 에그리게이트 루트가 모든 행위의 진입점임을 강종하는데 이 특징에 착안해 애그리게이트 단위로 API를 설계할 수 있다.  
**HTTP 헤더로 애그리게이트가 제공하는 기능을 구별하는 용도로 사용할 수 있다.**  
이 헤더 기능을 이용하면 URL과 HTTP 메소드의 중복 제약없이 자유롭게 사용할 수 있다.  
  
```java
@PutMapping(
    value = "/cart/{itemId}",
    headers = { "command=ChangeQuantity" }
)
public void changeQuantity(...) {
    ...
}

@PutMapping(
    value = "/cart/{itemId}",
    headers = { "command=ChangeOption" }
)
public void changeOption(...) {
    ...
}
```

한편 클라이언트에서 요청에 포함시키지 않고 백엔드에서 할당해야만 하는 속성도 있다.  
대표적으로 세션에 보관중인 로그인한 사용자의 userId와 신규로 생성한 에그리게이트의 식별자가 있다.  
커맨드 객체의 속성 중 백엔드에서 할당하는 속성임을 표현하기 위한 용도로 `transient` 키워드를 사용할 수 있다.  
그래서 커맨드 객체, `AddItem` 커맨드의 userId 속성은 백엔드에서 직접 할당한다.  

# 아웃바운드 어댑터와 협력

아웃바운드 어댑터는 협력 대상 마이크로서비스와 통신하는 책임을 가지며 애플리케이션 서비스 또는 유즈케이스가 이 어댑터를 사용한다.  
아웃바운드 어댑터는 아파치 HttpClient나 스프링 WebClient와 같이 HTTP를 지원하는 다양한 라이브러리를 사용할 수 있지만 중복 코드를 작성해야 한다는 단점이 있다.  
대안으로 스프링이 제공하는 **페인 클라이언트**를 사용할 수 있다.  
페인 클라이언트는 인터페이스 선언만으로 다른 마이크로서비스를 사용할 수 있는 개발 편의성을 제공한다.  
  
`@FeignClient` 어노테이션은 오퍼레이션에 선언한 `@xMapping` 어노테이션에 따라 RESTful API를 호출하고 결과를 반환한다.  

```java
@FeignClient(value = "cart")
public interface CartClient {

    @GetMapping(value = "/cart/{itemId}")
    public Item queryItem(@PathVariable String itemId);
}
```

위와 같이 선언하면 `itemId`로 Cart에 담긴 Item을 조회하는 API로 사용된다.  
정상 응답을 반환하면 해당 메소드의 반환 타입으로 역직렬화된다.  

> 이렇게 외부 서비스의 협력을 필요로 할 때 반환 타입인 `Item`은 기존에 존재하는 `Item` 의존성을 가지도록 해결하게 되면, 필요한 객체 외에 다른 바운디드 컨텍스트에 있으면서 사용하지 않는 모든 객체를 보게되는 문제가 생긴다.  
> 이렇게 다른 서비스의 모델을 직접 참조하는 서비스가 많아질수록 변경에 의한 영향을 파악하기 위한 시간이 증가하며, 서비스의 독립성도 훼손시키게 된다.  
> **사용하지 않는 속성을 알고 있는 것보다는 코드 중복이 있더라도 개발자가 유지하는 소스 코드 단위로 필요한 속성만 선언하면 독립성을 높일 수 있다.**
  
# 이벤트 브로커

브로커는 생산자와 소비자간 메시지를 주고 받는 가교 역할을 하는데 일반적으로 서로 다른 시스템 간 데이터를 교환하면서 비동기 방식으로 처리하기 위한 목적으로 사용한다.  
**메시지와 이벤트는 서로 다른 생명주기를 갖는다.**  
  
메시지는 등록돼 있는 소비자가 읽어가면서 삭제하는 반면, 이벤트는 소비자가 다시 읽을 수 있도록 저장소에 보관한다.  
이벤트 브로커가 메시지 브로커의 기능도 지원하고 있어 당장 필요하지 않더라도 확장성을 고려했을 때 이벤트 브로커를 선택할 수 있다.  
  
마이크로서비스 아키텍처는 서로 다른 마이크로서비스가 같은 이벤트를 여러 번 소비하며, 소비하는 서비스에 장애가 발생하여 일시적으로 소비가 중단될 수 있으므로 이벤트를 저장해 신뢰할 수 있는 전달을 보장하는 이벤트 브로커를 사용해야 한다.  
  
이벤트 브로커는 생산자와 소비자간 메시지를 주고 받는 세 가지 패턴이 있다.  

1. **단일 생산자와 단일 소비자**
2. **단일 생산자와 다중 소비자**
3. **다중 생산자와 단일 소비자**

```yml
services:
  zookeeper:
    container_name: zookeeper
    image: wurstmeister/zookeeper:latest
    expose:
      - "2181"
    ports:
      - "2181:2181"
    platform: linux/amd64
  kafka:
    container_name: kafka
    image: wurstmeister/kafka:latest
    depends_on:
      - zookeeper
    expose:
      - "9092"
    ports:
      - "9092:9092"
    environment:
      KAFKA_ADVERTISED_HOST_NAME: 192.68.0.1
      KAFKA_ADVERTISED_PORT: 9092
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
```

## 아웃바운드 어댑터와 이벤트 발행

애플리케이션 서비스가 도메인 이벤트를 이벤트 저장소에 저장하면서 이벤트를 함께 발행할 수 있다.  
(트랜잭션을 지원하지 않는 이벤트 브로커를 사용하면 애플리케이션 서비스가 이벤트 저장소에 이벤트 기록과 이벤트 발행을 하나의 트랜잭션으로 처리할 수 없다.)  
이벤트 저장소에 이벤트 브로커로 이벤트 발행을 단일 트랜잭션으로 처리할 수 없는 문제를 해결하기 위해 **트랜잭셔널 아웃박스 패턴** 을 사용할 수 있다.  
  
이 패턴은 단일 트랜잭션으로 도메인 객체 외에 이벤트를 데이터베이스에 함께 저장하고 **메시지 릴레이**가 데이터베이스에 저장돼 있는 도메인 이벤트를 주기적으로 조회해 브로커에 전달한다.  
메시지 릴레이를 사용하면 애플리케이션 서비스가 직접 이벤트를 발행하는 방법에 비해 약간의 지연이 발생하지만 "트랜잭션"과 "이벤트 전달"을 보장하면서 개발자가 이벤트를 발행하지 않는 실수를 방지한다.  
  
> 이벤트 소싱은 이미 발행해야 하는 이벤트를 단일 트랜잭션에서 데이터베이스에 저장하므로 트랜잭셔널 아웃박스 패턴을 사용하는 것이 적합하다.

메시지 릴레이는 스프링의 `@Scheduled` 기능을 사용하여 이벤트를 주기적으로 조회하여 발행하도록 한다.  
이때 사용되는 옵션 중 `fixedDelay`는 이전 작업이 끝난 후 다음 작업을 시작하기까지 지정한 시간을 대기하는 반면, `fixedRate`는 이전 작업을 시작한 시간 기준으로 다음 작업을 시작한다.  
  
많은 브로커가 제공하는 기능은 유사하지만 설계 의도에 따라 서로 다른 데이터 포맷을 요구한다.  
메시지 릴레이가 다양한 포맷을 알아야 하면 브로커를 교체할 때마다 데이터 포맷을 변환하는 코드도 변경돼야 하기 때문에 브로커에 중립적인 이벤트를 정의하고 리스코프 치환 원칙을 적용해 다양한 메시지 브로커의 특성을 반영한 포맷으로 변환해 이벤트를 발행하는 로직을 분리해야 한다.  
예를 들어, 카프카는 페이로드와 헤더를 지원하지만 페이로드만 지원하는 브로커도 있다.  
  
## 변환(2차) 메시지(커맨드/이벤트)

한 서비스가 이벤트를 발행하고 다른 마이크로서비스가 이벤트를 소비하려면 메시지를 구독하는 서비스가 역직렬화하기 위해 이벤트와 타입을 알아야 하기 때문에 타입 의존성이 존재한다.  
  
소비자인 어느 서비스를 특정 도메인 이벤트에 반응하는 방식으로 설계하면 해당 도메인 이벤트를 변경하거나 새로운 이벤트를 추가할 때마다 알림 서비스를 변경해야 한다.  
이벤트를 소비하는 서비스의 이벤트 핸들러를 변경하거나 추가하지 않고 **도메인 이벤트를 발행하는 서비스가 도메인 이벤트를 새로운 메시지(알림 서비스의 경우 커맨드)로 변환해 발행하면 타입 의존성을 제거할 수 있다.**  
  
예를 들어, 주문 서비스는 `OrderCompleted` 이벤트를 발행한 후 `OrderCompleted`를 알림 서비스가 요구(이해)하는 커맨드로 변환해서 알림 서비스가 구독하는 토픽에 한 번 더 발행한다.  
메시지 변환 책임은 메시지 릴레이가 가지는 것이 적절하다. 이벤트 스토어에서 이벤트를 읽어 브로커에 발행할 때 필요한 만큼 여러 번 메시지를 변환해 발행할 수 있으며, 메시지 변환은 발행이 주 목적이므로 책임 관점에서도 메시지 릴레이에 부여하는 것이 적합하다.

## 인바운드 어댑터와 이벤트 소비

카프카에 발행한 메시지를 수신해 이벤트에 반응하기 위해 스프링 카프카가 제공하는 [Message Listener](https://docs.spring.io/spring-kafka/reference/kafka/receiving-messages/message-listeners.html)를 사용할 수 있다.  
메시지 전달은 `"최소 한 번 이상"`, `"한 번 또는 전달 안 됨"`, `"정확히 한 번만 전달"`하는 세 가지 방식이 있으며, 카프카는 메시지 전달을 위해 `"최소 한 번 이상"` 전달을 보장한다.  
그렇기에 동일한 이벤트를 여러 번 수신하더라도 동일 이벤트에는 한 번만 반응해야 한다.  
  
(논란의 소지는 있지만) 메시지 릴레이와 같은 방식으로 이벤트를 수신해 저장소에 저장하는 책임과 이벤트를 스프링 컨텍스트에 발행하는 책임을 가진 **리버스 릴레이**를 사용하여 정확하게 한번 처리할 수 있다.  
이 리버스 릴레이는 주기적으로 수신한 이벤트의 저장소에서 메시지를 조회해 처리한 후 플래그 값을 변경하거나 이벤트를 삭제한다.  
이를 트랜잭셔널 아웃박스 패턴의 반대 의미로 `트랜잭셔널 인박스 패턴`이라고 한다.  

> EventStore는 메시지 릴레이에서 이벤트 브로커로 도메인 이벤트를 발행하기 위해 사용하는 전용 인터페이스이다.  

# 결과적 일관성

MSA에서 결과적 일관성은 비즈니스 프로세스에 참여하는 시스템간 협력의 결과이다.  
결과적 일관성에 활용할 수 있는 시스템간 협력 패턴이 존재한다.  

1. **라우팅 슬립 패턴**
   - 사전에 정의한 규칙에 따라 수신한 메시지를 하나 이상의 대상으로 라우팅한다.
   - 이는 처리 단계와 비즈니스 규칙을 충족하는지 검사하는 파이프-필터 아키텍처로 볼 수 있다.
   - 각 필터는 수신 메시지를 검사하고 다양한 비즈니스 규칙을 적용한 후 결과를 다음 필터로 전달한다.
   - 단순한 비지니스 프로세스는 이 패턴을 활용해 마이크로서비스간 협업 순서를 정의할 수 있다.
   - 하지만 처리 단계의 순서가 정해져있으며, 처리 순서가 선형이어야 한다는 제한이 있다.
2. **프로세스 매니저 패턴**
   - 라우팅 슬립과 다르게 프로시저의 실행 결과를 이용해 다음에 실행할 프로시저를 동적으로 결정하거나 동시에 실행할 수 있다.
   - 동적인 흐름을 가질 수 있는것이 장점이며, 대부분의 워크플로우 엔진이 이 패턴을 사용한다.

# 분산 트랜잭션

분산 트랜잭션을 주로 사용하는 모노리스 아키텍처와 마찬가지로 마이크로서비스 아키텍처도 분산 트랜잭션을 사용할 수 있지만 가용성과 확장성 측면에서 다시 모노리스로 되돌리는 결과를 초래한다.  
주문 서비스가 결제와 재고 데이터베이스에 직접 접근하게 되면 응집도가 낮고 결합도가 높은 시스템이 되기 때문이다.  

> 선택한 데이터 저장소가 2PC로 알려진 X/A 프로토콜을 지원하지 않으면 분산 트랜잭션을 사용할 수 없다.  

주문, 결제, 재고 서비스 모두 자신만의 로직을 가지고 분산 트랜잭션을 지원하는 데이터베이스를 사용한다.  
하지만 비즈니스 트랜잭션에 참여하는 서비스가 API로 협력하는 경우 각 서비스는 독립적인 트랜잭션을 소유하기 때문에 결제나 재고 서비스에서 오류가 발생하면 주문을 롤백할 수 없다.  
**결론적으로 마이크로서비스 아키텍처는 일관성을 유지하기 위해 분산 트랜잭션을 사용할 수 없다.**  
  
# 사가 - "일련의 사건"

사가는 장기 실행 트랜잭션에서 데이터베이스 잠금을 오랫동안 유지해야 하는 문제를 해결하기 위해 짧은 트랜잭션 집합으로 분해해서 관리하는 접근법이다.  
마이크로서비스 아키텍처에서 일련의 사건은 비즈니스 프로세스를 완성하는 **여러 서비스간의 협력에서 발생하는 개별 트랜잭션의 순서이다.**  
  
사가는 **비즈니스 트랜잭션을 구성하는 여러 트랜잭션들 중 하나에서 오류가 발생하면 이전에 완료된 트랜잭션을 이전 상태로 되돌리는 트랜잭션 (보상 트랜잭션)을 실행한다.**  
예를 들어, 주문이 시작되어 재고를 감소하는 이벤트를 발행하고 결제를 시작하는 이벤트를 발행하여 결제가 시작되었지만 결제에 실패한다면 다시 재고를 증가하는 이벤트를 발행하는것이다.  
  
> 오픈 마켓에서 재고에 상관없이 주문을 받고 재고가 부족할 때 판매자가 주문을 취소하는 것도 일종의 보상 로직이다.
  
분산 트랜잭션을 사용하면 개별 트랜잭션이 아직 진행 중이라 롤백할 수 있는 반면 마이크로서비스 아키텍처는 주문과 재고 서비스가 이미 트랜잭션을 커밋했기 때문에 롤백할 수 없다.  
이런 이유로 "롤백"이라 하지 않고 "보상"이란 언어를 사용한다.  

> 앞서 애그리게이트는 독립적인 존재이면서 트랜잭션 단위임을 여러 번 강조한 것은 서비스가 아닌 애그리게이트간 일관성을 보장하는 방법으로 사용해야 하기 때문이다.  
> 단일 마이크로서비스가 여러 애그리게이트를 갖고 있어도 보상 트랜잭션을 사용해 애그리게이트간 일관성을 유지해야 서비스의 독립성을 높일 수 있다.

사가는 보상하는 방법만 정의하고 있어 일반적으로 비즈니스 트랜잭션의 각 스텝에서 상태를 중앙에서 관리하는 프로세스 매니저를 함께 사용해 보상 프로세스를 진행시킨다.  
또한 일관성을 유지하기 위해 비즈니스 트랜잭션에 참여하는 애그리게이트간에 트랜잭션을 구분하는 값을 주고 받아야 한다.  
  
이런 보상 로직은 데이터베이스가 제공하는 롤백처럼 완벽할 롤백을 의미하지 않는다.  
또한 분산 트랜잭션을 사용해 일관성을 유지하는 방법에 익숙한 개발자에게 보상 트랜잭션은 기술적으로 수용 불가한 방법일 수 있다.  
**하지만 도메인 전문가는 일관성을 달성하는데 소요되는 시간에 관대하거나 거의 신경쓰지 않는 경우가 많으므로 충분한 활용 가치가 있다.**  

> 오케스트레이션 방식은 "커맨드"와 "이벤트"를 사용하고 코레오그래피 방식은 "이벤트"만 사용해 보상 메커니즘을 구현한다.

## 오케스트레이션

> 하나의 서비스가 트랜잭션에 필요한 이벤트에 반응해 일관성을 조정하는 책임을 갖는 중앙 집중형  

예를 들어, 주문 마이크로서비스가 프로세스 흐름의 전체 제어권 가지도록 하여, 비즈니스 프로세스에 필요한 모든 작업을 알고 있으며 이벤트가 발생할 때마다 프로세스의 다음 스텝을 결정하는 것이다.  
주문 서비스가 협력할 서비스에게 커맨드를 발행하고 응답 토픽에서 결과를 기다려, 정상 응답이라면 다음 서비스에게 다시 커맨드를 발행하는 흐름이다.  
만약 주문 서비스가 협력하는 서비스로 부터 실패하는 이벤트를 수신하면 다른 서비스에게 보상 트랜잭션을 위한 커맨드를 발행하는 책임도 가진다.  
  
이 오케스트레이션 방식에서는 **비즈니스 프로세스의 진행 상태를 관리하는 객체가 필요하다.**  
[스프링 스테이트 머신](https://spring.io/projects/spring-statemachine)을 활용하거나 직접 구현할 수 있다. 하지만 주문 서비스에도 장애가 발생할 수 있기에 프로세스의 진행 상태를 데이터베이스에 저장하고 서비스가 다시 시작했을 때 저장한 진행 상태를 조회하고 다음 스텝을 계속 진행시켜야 한다.  

## 코레오그래피

> 비즈니스 트랜잭션에 참여하는 모든 서비스가 자율적으로 도메인 이벤트에 반응해 일관성을 달성하는 분산형

예를 들어, 주문 서비스와 결제, 재고, 배송 서비스는 비즈니스 프로세스를 완료하기 위해 서로 어떤 메시지를 발행하고 반응해 무엇을 처리할지 상세하게 정의한다.  
마이크로서비스는 자신이 반응하기로 한 메시지를 수신하면 설계 시 부여한 기능을 실행(일반적으로 처리, 처리 결과를 이벤트로 발행)한다.  
만약 중간 스텝에서 실패가 발생하면 각 서비스는 실패 이벤트에 반응해 개별적으로 보상 로직을 실행한다.  
  
이 방식은 **일련의 흐름을 병렬로 처리할 수 있는 유연함이 있다.**  
하지만 비즈니스 프로세스 전체를 파악하기 어려운 단점이 있어 명확한 문서화 및 현행화가 필요하고 단순하거나 자주 변하지 않는 프로세스에 적용하는 것이 좋다.  

## 타임아웃

비즈니스 트랜잭션에 참여하는 마이크로서비스 중 하나에서 장애가 발생하여 서비스를 제공할 수 없는 상태가 되거나 급격한 부하 증가로 처리 시간이 지연될 수 있다.  
그렇기에 **데이터가 일관성을 유지하지 못한 채 비즈니스 트랜잭션이 장시간 방치되는 것을 방지하기 위해 타임아웃을 고려해야 한다.**  

> 사가 패턴을 지원하는 일부 라이브러리나 프레임워크는 타임아웃 대신 "데드라인"이라고 부르기도 한다.

타임아웃이 발생하기 전에 기대하는 성공/실패 이벤트를 받지 못하면 보상 로직을 실행하도록 오케스트레이션과 코레오그래피 두 가지 방식에서 모두 고려해야 한다.  

## 의미적 잠금

마이크로서비스 아키텍처에서는 비즈니스 프로세스에 참여하는 서비스에서 데이터베이스의 잠금 기능을 사용하지 않고 soft state를 사용하여 전체 프로세스에 대한 진행도를 표현한다.  
데이터베이스 잠금과 달리 논리적임을 강조하기 위해 **의미적 잠금** 이라 부르기도 한다.  
  
# 이벤트 소싱과 결과적 일관성

위에서 소개 오케스트레이션, 코레오그래피 두 가지 방식 모두 보상 로직을 가진 메소드를 제공해야 하는 번거로움이 있지만 이벤트를 사용해 서비스의 독립성을 높일 수 있다.  
하지만 이벤트 소싱을 사용하면 보다 간결한 방식으로 보상 로직을 구현할 수 있다.  
  
이벤트 소싱도 이벤트의 추가만 있고 변경이 없기 때문에 회계 장부와 같다고 할 수 있다.  
**이벤트 소싱에서 보상 트랜잭션은 상관 관계 아이디로 커밋한 도메인 이벤트를 찾아 deleted 속성 값을 true로 변경해 리플레이 대상 이벤트에서 제외시키는 아주 간단한 메커니즘으로 구현할 수 있다.**  

## 상관 관계 아이디와 추적성

마이크로서비스 아키텍처 패턴에서 분산 추적 패턴은 **외부 요청별로 고유한 요청 식별자를 할당하고 다른 마이크로서비스와 협력할 때 요청 식별자를 전달해 마이크로서비스간 의존성을 추적한다.**  
[Spring Cloud Sleuth](https://spring.io/projects/spring-cloud-sleuth)는 고유한 식별자를 생성하고 전달하는 기능을 제공한다.  

- `traceId` : 요청별로 할당한 고유값, 하나의 비즈니스 프로세스에 다수의 마이크로서비스가 협력해도 동일한 값을 가진다.
- `spanId` : 비즈니스 프로세스에서 실행 순서, 애플리케이션 별로 할당하는 고유 값으로 최초 요청은 traceId와 같은 값을 가진다.
- `parentId` : 자신을 요청한 마이크로서비스의 spanId, 연결 리스트와 유사해서 호출 관계를 분석하는데 사용한다.

보상 메커니즘을 구현하는데 중요한 속성인 상관 관계 아이디 값으로 traceId를 사용할 수 있다.  
traceId를 상관 관계 아이디로 사용하면 추적성을 유지하면서 도메인 객체에서 발생한 이벤트의 deleted 속성을 손쉽게 변경할 수 있다.  
traceId를 사용하면 도메인 이벤트에 저장할 때 CORRELATION_ID에 traceId를 저장하고 브로커에 이벤트 발행 시에도 traceId를 포함해야 한다.  

***

- 추가로 이벤트 소싱을 활용해 트랜잭션의 상태 변화를 기록하면 7장에서 소개할 감사 사례의 이벤트 통합 저장소처럼 CQRS를 적용해 비즈니스 트랜잭션 데이터를 수집해 모니터링 할 수 있다.  
- Saga는 기술 언어이면서 도메인 객체를 직접 사용하지 않으므로 클래스 이름에 사용할 수 있다.