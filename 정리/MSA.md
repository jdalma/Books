
헥사고날 아키텍처는 기술에 의존하는 구성 요소인 어댑터에 서비스간 협력을 위한 책임을 부여한다.  
마이크로서비스는 협력에 참여하는 마이크로서비스가 제공하는 REST API를 호출하거나 메시지 브로커에 이벤트를 발행해서 통신한다.  
협력 요청을 받은 인바운드 어댑터는 애플리케이션 서비스에 위임해 비즈니스 로직을 처리한다.  
반대로 비즈니스 로직을 처리하는 중간 또는 완료 후에 다른 마이크로서비스와 협력을 위해 아웃바운드 어댑터를 사용한다.  
  
# 인바운드 어댑터와 RESTful API

애그리게이트를 중심으로 HTTP 프로토콜이 제공하는 URL, HTTP 메소드를 활용한 설계 방법을 알아보자.  

## HTTP 메소드

URL은 자원을 기준으로 목록과 단일 엔티티를 다루고 명사를 사용한다.  

- `/cart`
  - `POST` : 새로운 자원 생성
  - `GET` : 자원 목록 조회
  - `PUT` : 자원 대량 업데이트
  - `DELETE` : 모든 자원 삭제
- `/cart/{itemId}`
  - `POST` : 오류
  - `GET` : 상세 조회
  - `PUT` : 자원이 있으면 업데이트, 없으면 에러 (item 수량을 변경)
  - `DELETE` : 자원 삭제

> `PATCH`는 엔티티의 일부 속성을 변경하는 메소드로 `PUT` 메소드와 구분해야 하지만 여기에서는 사용되지 않는다.

## 애그리게이트와 URL

예를 들어, `/cart/{itemId}`의 PUT 메소드를 통해 수량 변경을 위한 API와 옵션 변경을 위한 API를 구분하기위해서는 어떻게 해야할까?  
(`/cart/{itemId}/changeOption`과 같은 동사는 RESTful API 네이밍 스타일 중 명사를 사용해야 하는 요건을 충족하지 못한다.)  
  
해결 방법으로는 도메인 주도 설계에서 애그리게이트는 상태 변경을 단일 트랜잭션으로 설계하고 에그리게이트 루트가 모든 행위의 진입점임을 강종하는데 이 특징에 착안해 애그리게이트 단위로 API를 설계할 수 있다.  
**HTTP 헤더로 애그리게이트가 제공하는 기능을 구별하는 용도로 사용할 수 있다.**  
이 헤더 기능을 이용하면 URL과 HTTP 메소드의 중복 제약없이 자유롭게 사용할 수 있다.  
  
```java
@PutMapping(
    value = "/cart/{itemId}",
    headers = { "command=ChangeQuantity" }
)
public void changeQuantity(...) {
    ...
}

@PutMapping(
    value = "/cart/{itemId}",
    headers = { "command=ChangeOption" }
)
public void changeOption(...) {
    ...
}
```

한편 클라이언트에서 요청에 포함시키지 않고 백엔드에서 할당해야만 하는 속성도 있다.  
대표적으로 세션에 보관중인 로그인한 사용자의 userId와 신규로 생성한 에그리게이트의 식별자가 있다.  
커맨드 객체의 속성 중 백엔드에서 할당하는 속성임을 표현하기 위한 용도로 `transient` 키워드를 사용할 수 있다.  
그래서 커맨드 객체, `AddItem` 커맨드의 userId 속성은 백엔드에서 직접 할당한다.  

