
1. Armeria + Tomcat + BlockingTaskExecutor 구분하는 방법 : 질문 남겨놓음
2. 이벤트 루프는 
3. @ControllerAdvice 확인해보기
4. 코틀린의 결 확인하기
5. 과제 고민 지점 정리하기
6. 동기화로 동시성 문제를 해결했으니 디비 락 수준 확인해보기

# 과제 관련

1. OrderWebClient에서 POST 함수의 return 식이 응답 코드에 따라 분기되어 `OrderResult().apply`를 하고있는데 이 작업을 `OrderResult`클래스에 넣는게 좋을 것 같다.
2. items.sumOf { it.toLong() } 으로 오버플로우를 대비해야했다
3. OrderProcess의 내부 필드들이 public하게 열려있는 것
   1. state를 OrderState의 구현체들이 직접 변경하는데, OrderProcess까지 
4. 상태 패턴을 적용하게된 계기
   1. 처음에 요구사항의 입력 내용을 보자마자 상태를 단계별로 나누어야겠다는 생각을 했다.  
   2. 그리고 각 상태가 변경이나 확장에 유연하도록 내부에 다음 진행할 상태 필드를 주입하려고 했다.  
   3. 장점은 외부에서 상태 전이를 편하게 주입해줄 수 있고, 각 상태 구현체들은 완전히 독립적이게 된다.
   4. 하지만 A 상태가 B 상태를 호출하게 되면 콜 스택에 누적될 우려가 있었다. 사용자가 주문을 계속 할 수 있기 때문에 문제가 될 것 같았다.
   5. 그래서 OrderProcess가 추상화된 OrderState를 실행하기만 하고 각 상태에 맞는 구현체가 실행된다.
   6. 각 상태가 스스로 상태를 정하기 보다는 외부에서 각 주문 상태의 성공과 실패 시 전이될 상태를 객체로 정했으면 좋았을 것 같다. 
5. 4-6번과 관련하여 OrderPrepareState와 OrderStartState에서 OrderWebClient를 직접 생성하여 사용하는데 현재 상태가 변경될 때 이전 상태에서 다음 상태 구현체를 직접 생성하여 OrderProcess의 상태를 변경한다. 이렇게 되면 OrderWebClient도 매번 생성되기 때문에 불필요한 낭비다.
6. kotest를 사용한 이유는 DCI패턴을 작성하기 편해서이다.
   1. Given-When-Then은 상황을 기준으로 삼는데, Describe-Context-It은 테스트 대상을 기준으로 삼아 (주관적이지만)
      1. 빠진 케이스를 생각하기 쉽다
      2. 스코프를 기준으로 작성하기 때문에 문맥이 잘 맞다
7. 코틀린 스코프 함수
   1. **문맥 참조를 `it`으로 하냐, `this`로 하냐?**
      1. `it`은 이름을 지정할 수 있지만, `this`는 키워드이기 때문에 이름을 지정해줄 수 없다.
   2. **리턴 값이 전달 받은 람다의 반환 값이냐, 수신 객체이냐?**
   3. run 블록, runCatching 블록 : 함수 내에서 컨텍스트 영역을 표현하기 위함으로 사용
   4. let : 보통 null 체크를 간편하게 하기위해 사용한다. null 체크 후, 실행을 let을 이용해 대체 가능하다. run 처럼 반환 값이 있기 때문에 컨텍스트 영역을 표현하기 위해서도 사용하는 듯
   5. apply : 객체 생성 후 수신 객체 설정 (apply 내부 할당은 객체 생성 후 setter로 설정된다.)
   6. run : 개체 구성 및 결과 계산
   7. also : 추가 효과
   8. with : `.`을 제거하고 receiver 내부 필드를 호출할 수 있다
8. 코틀린 스터디 정리한거 한 번 훑기
9. 스프링 프록시 보기
10. 클라이언트에서 서버 통신할 떄 요청이 실제로 가기전에 `disconnect`를 해버림
    1. 이게 통신이 되는 이유가 커넥션의 소켓이 끊겨도 요청이 갈때 소켓을 새로 만듦
       1. HttpUrlConnection 내부에 HttpClient가 null이 아니면 소켓을 바로 끊어버림
    2. 킵얼라이브도 60초동안함

> 수신 객체 : '확장 함수가 호출되는 대상이 되는 값(객체)'

- 서버가 이중화됐을 때 배치가 같이 돌면 문제가 생기는 경우는 없었나?
- 브라우저 ajax 비동기도 되는거아니야?
- 세션 스토리지
- 일반적인 SQL로 비관적인 락을 사용한다면
  - 버전 컬럼이 추가되거나 where절에 추가하게 된다.
- 컨트롤러 
- 필터나 인터셉터에서 발생한 예외는 어드바이스에서 잡히나?
  - **디스패처 라이프 사이클**
  - **컨트롤러 어드바이스 확인하기**
- 안좋은 사용자 경험
  - 너무 많은 리소스
  - 외부 솔루션 : 엔플리티드
    - 실험 그룹 할당
- 분산 트랜잭션
  - 사가 패턴
  - 중앙 관리 서비스


# 사내 교육 및 스터디 운영

빈에서 전역변수 상태를 가진 클래스가 작성되어 있는 것을 보고 마침 스프링 공부를 하고 있었어서 나서서 배운것을 공유하면 좋겠다고 생각했다  
같이 개발 이야기하면서 공부할 동료가 필요했기에 개발 흥미를 북돋아 줄 주제들을 선정하려 노력했다  
기억에 남는 주제는 GC를 정리한 내용이다.  

# 개선점 찾기

코드 형상관리와 이미지를 업데이트하는 단계가 연결이 되어있지 않아 현재 반영된 이미지와 깃 로그가 일치하지 않는 경우도 있었고,  
이미지 반영을 sh 스크립트로 직접 실행하면서 이미지 태그를 파라미터로 직접 넘겨주기 때문에 다른 개발 서버에 이미지를 반영하는 경우도 있었다.  
dev4에 반영해야하는데 dev3에 반영하거나..  
그래서 bitbucket의 푸시 이벤트 웹훅을 활용하여 젠킨스를 통해 테스트 자동화와 이미지의 일관성을 지켜주려 하였다.  
구상을 하면서 리뷰를 받던 도중 포테이너를 걷어내고 젠킨스를 사용해서 자동화 구축을 하는 작업은 큰 작업이라서 혼자 진행하기에는 무리가 있어 후순위로 미뤘다.

> CI/CD 작업을 진행하다가 실패했다는 얘기를 해야할까? 근데 이 얘기를 안하면 개선하려 했던 이유가 멋지게 안나옴

QA 팀원이랑 얘기하다보면 야근도 자주하고 반복된 업무가 많다고 한탄을 했었다  
통합테스트로 API의 응답 정도는 검증해줄 수 있지 않을까, 서버 상태를 대신 확인해줄 수 있지 않을까 생각했다.  
개발팀에서 포스트맨을 기존에 활용하고 있어서 CLI로 스크립트를 실행시킬 수 있는 newman을 같이 사용하면 추후에 CI/CD에도 추가하기 쉽다고 판단되어 포스트맨 테스트 스크립트를 활용하기로 했다.  
사용자한테 꾸준히 피드백을 받으면서 테스트 케이스를 계속 개발 중이며, 현재 많은 테스트 케이스가 쌓여있진 않지만 수동으로하면 60분 작업에서 3~5분 정도는 단축된 것 같다고 말해주셨다.  

# 전략패턴 vs SOLID의 DIP vs 스프링의 DI

SOLID의 DIP를 설명할 때 전략 패턴과 스프링의 DI를 예로 들 수 있겠다.  
전략 패턴과 스프링의 DI는 클라이언트 코드가 특정 처리에 대한 내부 구현을 캡슐화하여 결합도를 낮추고 유연성을 놓이는 행위이다.  
  
전략 패턴을 적용하게 되면 클라이언트 코드에서 내부 구현체는 다르지만 다형성과 동적 디스패치를 통해 호출할 기능을 동적으로 변경할 수 있다.  
자신의 기능 맥락에서 , 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고 , 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.  
스프링의 DI는 빈을 로딩할 떄 의존된 빈을 확인하여 필요한 빈을 주입해주는 것이다. 이런 식으로 의존성을 관리하게 되면 결합도를 감소시킬 수 있고, 테스트 시에도 주입을 달리하여 테스트 환경에 용이하고, 재사용이 가능하다.  
  
위에서 말헀던 전략 패턴과 스프링의 DI를 적용할 때 **의존 역전 원칙**을 지켜야한다.  
이 원칙은 **상위 인터페이스의 타입으로 통신하라**는 원칛이다.  
하위 모듈의 인스턴스에 직접 의존하게 되면 하위 모듈 변화가 있을 때마다 클라이언트나 상위 모듈을 자주 수정해야 하기 때문이다.  
쉽게 생각하면 추상화 지점을 찾아 추상화를 하게 되었다면 클라이언트 코드는 추상화의 구현체를 직접 의존하는 것이 아니라 추상화 타입에 대해 의존하는 것이다.  
  
생각해보면 전략 패턴은 이 유연성이 생명인데, 구현 타입에 직접 의존하는 것은 전략 패턴이라고 생각되지 않는다.  

# gRPC vs Message Queue vs HTTP API

# HTTPS 적용과정

클라이언트가 서버에게 접속 요청을 보내고, 서버는 자신의 공개 키를 전송한다. (서버가 미리 공개키와 개인키를 만들어두었다고 가정)  
클라이언트는 자신의 대칭 키를 서버에게 전달받은 공개 키로 암호화하고 서버에게 암호화된 클라이언트의 공개 키를 전달한다.  
이렇게 얻어낸 클라이언트의 대칭 키를 활용해서 안전하게 통신한다.  
  
개발자는 CA 기업의 인증서를 구입하여 CA 기업의 개인 키를 이용하여 암호화 한 인증서를 받는다.  
이 SSL 인증서에는 서버 측 공개 키가 들어 있다.  
클라이언트는 이미 브라우저에 신뢰할 수 있는 CA 기관의 리스트와 해당 기관의 공개 키를 이미 가지고 있기 때문에,  
CA의 개인 키로 암호화 된 인증서를 복호화하여 인증서를 검증한 뒤, 서버의 공개 키를 꺼낼 수 있다.  
  
> TCP 핸드쉐이크가 끝나고 SSL 핸드쉐이크에서  
> 클라이언트가 서버에게 암호화 알고리즘을 나열하고 서버가 암호화 알고리즘을 선택하여 인증서를 클라이언트에게 전달  
> 클라이언트는 인증서에 담겨있는 서버의 공개 키를 꺼낸다.  
> 클라이언트는 다시 자신이 전달할 데이터를 암호화할 대칭 키를 만들고, 그 대칭 키를 서버 공개 키로 암호화한다.  
> 암호화한 대칭키를 서버에게 전달한다.  

# ControllerAdvice 설명

컨트롤러에서 런타임예외가 발생한다면 디스패처 서블릿에서 예외를 구분한다.  
만약 Exception에 속하지 않는 Throwable 타입이라면 (Error)라면 


# JPA와 MyBatis 차이(성능면에서)

# 인터페이스와 추상클래스 차이

# TCP/UDP 에 대해

[참고!](https://github.com/jdalma/footprints/blob/main/%EC%A0%95%EB%A6%AC/TCP%EC%99%80UDP.md)

# RDBMS Lock에 대해

# ConcurrentHashMap

이때까지 `ConcurrentHashMap`이 동시성 문제를 다 해결해주는 줄 알고 있었지만 아래의 테스트 코드는 실패한다.  

```kotlin
describe("ConcurrentHashMap<String,Item>") {
   context("Item의 재고를 동시에 감소시키면") {
      it("동시성 문제가 생긴다.") {
            data class Item (
               val itemId: String,
               val quantity: Int
            )

            val itemKey = "인형"
            val items = ConcurrentHashMap<String, Item>().apply {
               this[itemKey] = Item(itemKey, 1000)
            }
            val threadCount = 1000
            val executor = Executors.newFixedThreadPool(threadCount)
            val latch = CountDownLatch(threadCount)

            for (i in 1..threadCount) {
               executor.submit {
                  try {
                        val findItem = items[itemKey]!!
                        items[itemKey] = findItem.copy(quantity = findItem.quantity - 1)
                  } catch (e: Exception) {
                        e.printStackTrace()
                  } finally {
                        latch.countDown()
                  }
               }
            }
            latch.await()
            items[itemKey]!!.quantity shouldBe 0
      }
   }
}
```

`"인형"`이라는 Item은 재고가 1000개가 있다고 가정하고, 1000개의 스레드가 동시에 ConcurrentHashMap에서 Item을 찾고, 찾은 Item의 재고 수 기준으로 1씩 차감하는 테스트 코드다.  
Map 내부에서 동기화를 해주는 줄 알겠지만 테스트가 끝난 후에는 재고가 0개이길 기대하지만, 동시성 문제가 해결되지 않아 재고가 순차적으로 차감되지 않는다.  
  
[`javase 17` ConcurrentHashMap](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/ConcurrentHashMap.html)을 살펴보면 

> 모든 작업이 스레드로부터 안전하더라도 검색 작업에는 잠금이 수반되지 않으며 모든 액세스를 방지하는 방식으로 전체 테이블을 잠그는 기능이 지원되지 않습니다 .  
> 검색 작업( get 포함)은 일반적으로 차단되지 않으므로 업데이트 작업( put 및 remove 포함)과 겹칠 수 있습니다.  
> 검색은 가장 최근에 완료된 업데이트 작업의 결과를 반영합니다.  
> ...



# Synchronized

상품들의 재고를 관리하는 과제를 진행하면서, `ConcurrentHashMap`을 사용했다.  
- `ConcurrentHashMap`이 동시성 문제를 다 해결해주는 줄 알고 있었지만 아니였다.
키는 상품의 식별자이고 값은 상품이다.  
특정 상품의 재고를 감소할 때 내가 원했던 것은 재고 감소할 상품에 대해 락을 거는 것이였다. (디비의 로우 락 처럼)  

```kotlin
private val items = ConcurrentHashMap<String, ItemEntity>()

// 기존에는 items 통째로 동기화를 걸었다.
fun decreaseQuantity(item: ItemEntity) : ItemEntity? {
    synchronized(items) {
        this.items[item.id]?.let {
            return this.updateOne(it.decreaseQuantity(item.quantity))
        } ?: throw ItemNotExistException(String.format(CustomExceptionMessage.PRODUCT_NOT_FOUND.description, item.id))
    }
}

// 하지만 items 통째로 동기화를 거는 것은 비효율적이여, items의 id 기준으로 동기화를 걸었다.
fun decreaseQuantity(item: ItemEntity) : ItemEntity? {
    synchronized(item.id) {
        val findItem = this.items[item.id]
            ?: throw ItemNotExistException(String.format(CustomExceptionMessage.PRODUCT_NOT_FOUND.description, item.id))
        return this.updateOne(findItem.decreaseQuantity(item.quantity))
    }
}
```

![](imgs/pieces/concurrentTestFail.png)

`synchronized`에 대해 알아보자

> The Java programming language provides multiple mechanisms for **communicating between threads**.  
> The most basic of these methods is **synchronization**, which is implemented using **monitors**.  
> Each object in Java is associated with a **monitor**, which a **thread can lock or unlock.**  
> Only one thread at a time may hold a lock on a monitor.  
> Any other threads attempting to lock that monitor are **blocked until they can obtain a lock on that monitor**  
  
자바는 스레드간 통신할 수 있는 여러가지 메커니즘을 제공한다. 가장 기본적인 방법은 monitor를 사용하는 synchronization이다.  
자바에서는 각 객체가 모니터와 연관되며, 스레드는 해당 모니터를 잠그거나 잠금을 해제할 수 있다.  
한 번에 하나의 스레드만 모니터의 잠금을 보유할 수 있고, 다른 스레드가 잠금을 획득하려 한다면 차단된다.  
  
## monitor

![](imgs/pieces/threadStatus.png)

`synchronized`를 사용해보면 위와 같이 다른 스레드들은 `monitor` 상태로 기다리게 된다.  
- 푸른색이 `monitor`상태다.
  
**모니터의 구성요소**  
1. **mutex**
   1. 임계 영역 진입을 기다리는 entry queue를 가진다. 
   2. critical section에서 상호 배제를 지키기 위한 방법
   3. mutex lock을 취득하지 못한 스레드는 **큐에 들어간 후 대기 상태로 전환**
2. **condition variable**
   1. **자바의 monitor는 한 개의 condition variable을 가진다.**  
   2. 조건이 충족되길 기다리는 waiting queue를 가진다.
   3. 조건이 충족되길 기다리는 스레드들이 대기 상태로 머무는 곳
   4. 주요 동작
      1. `wait` : 스레드를 큐에 넣고 대기 상태로 전환
      2. `signal`, `notify` : waiting queue에서 대기중인 한 개의 스레드를 깨움
      3. `broadcast`, `notifyAll` : waiting queue의 모든 스레드를 꺠움
  
![](imgs/pieces/consumerProblem.png)

> 결론은 한 개의 객체에 한 개의 monitor를 가지고, monitor안에는 mutex lock과 condition variable이 있다.  
> 객체의 mutex lock을 한 스레드가 가지고 있을 때 다른 스레드들은 해당 mutex lock에서 관리하는 entry queue에서 대기 상태로 기다리고 있는다.  
> - entry queue의 구현은 선입선출이 아니라 우선순위 큐일 수도 있다.  
> mutex lock을 얻고 임계 영역에 진입했다고 하여도, 내부 조건이 맞지 않으면 condition variable의 waiting queue에서 대기 상태로 기다린다.  
> **critical section 내에서 waiting 하는 기능은 뮤텍스나 세마포는 제공하지 않는 기능**  
> 자바의 모니터는 **한 개의 condition variable을 가지고 있기 때문에**  
> `wait()`을 통해서 mutex lock을 반납하여 entry queue에서 대기하던 스레드를 깨울 수 있고,  
> `notify()`또는 `notifyAll()`로 waiting queue에서 대기하던 스레드를 깨울 수 있다.  