
1. Armeria + Tomcat + BlockingTaskExecutor 구분하는 방법 : 질문 남겨놓음
2. 이벤트 루프는 
3. @ControllerAdvice 확인해보기
4. 코틀린의 결 확인하기
5. 과제 고민 지점 정리하기
6. 동기화로 동시성 문제를 해결했으니 디비 락 수준 확인해보기

# 과제 관련

1. OrderWebClient에서 POST 함수의 return 식이 응답 코드에 따라 분기되어 `OrderResult().apply`를 하고있는데 이 작업을 `OrderResult`클래스에 넣는게 좋을 것 같다.
2. items.sumOf { it.toLong() } 으로 오버플로우를 대비해야했다
3. OrderProcess의 내부 필드들이 public하게 열려있는 것
   1. state를 OrderState의 구현체들이 직접 변경하는데, OrderProcess까지 
4. 상태 패턴을 적용하게된 계기
   1. 처음에 요구사항의 입력 내용을 보자마자 상태를 단계별로 나누어야겠다는 생각을 했다.  
   2. 그리고 각 상태가 변경이나 확장에 유연하도록 내부에 다음 진행할 상태 필드를 주입하려고 했다.  
   3. 장점은 외부에서 상태 전이를 편하게 주입해줄 수 있고, 각 상태 구현체들은 완전히 독립적이게 된다.
   4. 하지만 A 상태가 B 상태를 호출하게 되면 콜 스택에 누적될 우려가 있었다. 사용자가 주문을 계속 할 수 있기 때문에 문제가 될 것 같았다.
   5. 그래서 OrderProcess가 추상화된 OrderState를 실행하기만 하고 각 상태에 맞는 구현체가 실행된다.
   6. 각 상태가 스스로 상태를 정하기 보다는 외부에서 각 주문 상태의 성공과 실패 시 전이될 상태를 객체로 정했으면 좋았을 것 같다. 
5. 4-6번과 관련하여 OrderPrepareState와 OrderStartState에서 OrderWebClient를 직접 생성하여 사용하는데 현재 상태가 변경될 때 이전 상태에서 다음 상태 구현체를 직접 생성하여 OrderProcess의 상태를 변경한다. 이렇게 되면 OrderWebClient도 매번 생성되기 때문에 불필요한 낭비다.
6. kotest를 사용한 이유는 DCI패턴을 작성하기 편해서이다.
   1. Given-When-Then은 상황을 기준으로 삼는데, Describe-Context-It은 테스트 대상을 기준으로 삼아 (주관적이지만)
      1. 빠진 케이스를 생각하기 쉽다
      2. 스코프를 기준으로 작성하기 때문에 문맥이 잘 맞다
7. 코틀린 스코프 함수
   1. **문맥 참조를 `it`으로 하냐, `this`로 하냐?**
      1. `it`은 이름을 지정할 수 있지만, `this`는 키워드이기 때문에 이름을 지정해줄 수 없다.
   2. **리턴 값이 전달 받은 람다의 반환 값이냐, 수신 객체이냐?**
   3. run 블록, runCatching 블록 : 함수 내에서 컨텍스트 영역을 표현하기 위함으로 사용
   4. let : 보통 null 체크를 간편하게 하기위해 사용한다. null 체크 후, 실행을 let을 이용해 대체 가능하다. run 처럼 반환 값이 있기 때문에 컨텍스트 영역을 표현하기 위해서도 사용하는 듯
   5. apply : 객체 생성 후 수신 객체 설정 (apply 내부 할당은 객체 생성 후 setter로 설정된다.)
   6. run : 개체 구성 및 결과 계산
   7. also : 추가 효과
   8. with : `.`을 제거하고 receiver 내부 필드를 호출할 수 있다
8. 코틀린 스터디 정리한거 한 번 훑기
9. 스프링 프록시 보기
10. 클라이언트에서 서버 통신할 떄 요청이 실제로 가기전에 `disconnect`를 해버림
    1. 이게 통신이 되는 이유가 커넥션의 소켓이 끊겨도 요청이 갈때 소켓을 새로 만듦
       1. HttpUrlConnection 내부에 HttpClient가 null이 아니면 소켓을 바로 끊어버림
    2. 킵얼라이브도 60초동안함

> 수신 객체 : '확장 함수가 호출되는 대상이 되는 값(객체)'

- 서버가 이중화됐을 때 배치가 같이 돌면 문제가 생기는 경우는 없었나?
- 브라우저 ajax 비동기도 되는거아니야?
- 세션 스토리지
- 일반적인 SQL로 비관적인 락을 사용한다면
  - 버전 컬럼이 추가되거나 where절에 추가하게 된다.
- 컨트롤러 
- 필터나 인터셉터에서 발생한 예외는 어드바이스에서 잡히나?
  - **디스패처 라이프 사이클**
  - **컨트롤러 어드바이스 확인하기**
- 안좋은 사용자 경험
  - 너무 많은 리소스
  - 외부 솔루션 : 엔플리티드
    - 실험 그룹 할당
- 분산 트랜잭션
  - 사가 패턴
  - 중앙 관리 서비스


CREATE TABLE `address_test` (
  `id` int NOT NULL AUTO_INCREMENT,
  `street_address` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL,
  `city` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL,
  `state` char(2) COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `city_index` (`city`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci

INSERT INTO address_test (id, street_address, city, state)  
SELECT id, street_address, city, state  
FROM address;

# 사내 교육 및 스터디 운영

빈에서 전역변수 상태를 가진 클래스가 작성되어 있는 것을 보고 마침 스프링 공부를 하고 있었어서 나서서 배운것을 공유하면 좋겠다고 생각했다  
같이 개발 이야기하면서 공부할 동료가 필요했기에 개발 흥미를 북돋아 줄 주제들을 선정하려 노력했다  
기억에 남는 주제는 GC를 정리한 내용이다.  

# 개선점 찾기

코드 형상관리와 이미지를 업데이트하는 단계가 연결이 되어있지 않아 현재 반영된 이미지와 깃 로그가 일치하지 않는 경우도 있었고,  
이미지 반영을 sh 스크립트로 직접 실행하면서 이미지 태그를 파라미터로 직접 넘겨주기 때문에 다른 개발 서버에 이미지를 반영하는 경우도 있었다.  
dev4에 반영해야하는데 dev3에 반영하거나..  
그래서 bitbucket의 푸시 이벤트 웹훅을 활용하여 젠킨스를 통해 테스트 자동화와 이미지의 일관성을 지켜주려 하였다.  
구상을 하면서 리뷰를 받던 도중 포테이너를 걷어내고 젠킨스를 사용해서 자동화 구축을 하는 작업은 큰 작업이라서 혼자 진행하기에는 무리가 있어 후순위로 미뤘다.

> CI/CD 작업을 진행하다가 실패했다는 얘기를 해야할까? 근데 이 얘기를 안하면 개선하려 했던 이유가 멋지게 안나옴

QA 팀원이랑 얘기하다보면 야근도 자주하고 반복된 업무가 많다고 한탄을 했었다  
통합테스트로 API의 응답 정도는 검증해줄 수 있지 않을까, 서버 상태를 대신 확인해줄 수 있지 않을까 생각했다.  
개발팀에서 포스트맨을 기존에 활용하고 있어서 CLI로 스크립트를 실행시킬 수 있는 newman을 같이 사용하면 추후에 CI/CD에도 추가하기 쉽다고 판단되어 포스트맨 테스트 스크립트를 활용하기로 했다.  
사용자한테 꾸준히 피드백을 받으면서 테스트 케이스를 계속 개발 중이며, 현재 많은 테스트 케이스가 쌓여있진 않지만 수동으로하면 60분 작업에서 3~5분 정도는 단축된 것 같다고 말해주셨다.  

# 전략패턴 vs SOLID의 DIP vs 스프링의 DI

SOLID의 DIP를 설명할 때 전략 패턴과 스프링의 DI를 예로 들 수 있겠다.  
전략 패턴과 스프링의 DI는 클라이언트 코드가 특정 처리에 대한 내부 구현을 캡슐화하여 결합도를 낮추고 유연성을 놓이는 행위이다.  
  
전략 패턴을 적용하게 되면 클라이언트 코드에서 내부 구현체는 다르지만 다형성과 동적 디스패치를 통해 호출할 기능을 동적으로 변경할 수 있다.  
자신의 기능 맥락에서 , 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고 , 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.  
스프링의 DI는 빈을 로딩할 떄 의존된 빈을 확인하여 필요한 빈을 주입해주는 것이다. 이런 식으로 의존성을 관리하게 되면 결합도를 감소시킬 수 있고, 테스트 시에도 주입을 달리하여 테스트 환경에 용이하고, 재사용이 가능하다.  
  
위에서 말헀던 전략 패턴과 스프링의 DI를 적용할 때 **의존 역전 원칙**을 지켜야한다.  
이 원칙은 **상위 인터페이스의 타입으로 통신하라**는 원칛이다.  
하위 모듈의 인스턴스에 직접 의존하게 되면 하위 모듈 변화가 있을 때마다 클라이언트나 상위 모듈을 자주 수정해야 하기 때문이다.  
쉽게 생각하면 추상화 지점을 찾아 추상화를 하게 되었다면 클라이언트 코드는 추상화의 구현체를 직접 의존하는 것이 아니라 추상화 타입에 대해 의존하는 것이다.  
  
생각해보면 전략 패턴은 이 유연성이 생명인데, 구현 타입에 직접 의존하는 것은 전략 패턴이라고 생각되지 않는다.  

# HTTPS 적용과정

클라이언트가 서버에게 접속 요청을 보내고, 서버는 자신의 공개 키를 전송한다. (서버가 미리 공개키와 개인키를 만들어두었다고 가정)  
클라이언트는 자신의 대칭 키를 서버에게 전달받은 공개 키로 암호화하고 서버에게 암호화된 클라이언트의 공개 키를 전달한다.  
이렇게 얻어낸 클라이언트의 대칭 키를 활용해서 안전하게 통신한다.  
  
개발자는 CA 기업의 인증서를 구입하여 CA 기업의 개인 키를 이용하여 암호화 한 인증서를 받는다.  
이 SSL 인증서에는 서버 측 공개 키가 들어 있다.  
클라이언트는 이미 브라우저에 신뢰할 수 있는 CA 기관의 리스트와 해당 기관의 공개 키를 이미 가지고 있기 때문에,  
CA의 개인 키로 암호화 된 인증서를 복호화하여 인증서를 검증한 뒤, 서버의 공개 키를 꺼낼 수 있다.  
  
> TCP 핸드쉐이크가 끝나고 SSL 핸드쉐이크에서  
> 클라이언트가 서버에게 암호화 알고리즘을 나열하고 서버가 암호화 알고리즘을 선택하여 인증서를 클라이언트에게 전달  
> 클라이언트는 인증서에 담겨있는 서버의 공개 키를 꺼낸다.  
> 클라이언트는 다시 자신이 전달할 데이터를 암호화할 대칭 키를 만들고, 그 대칭 키를 서버 공개 키로 암호화한다.  
> 암호화한 대칭키를 서버에게 전달한다.  
