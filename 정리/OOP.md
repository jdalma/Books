
# 객체

어떤 객체애 대한 개념을 중심으로 하여 그것이 가지는 데이터 값들과 그것을 대상으로 수행 가능한 동작들을 만들어 넣는 것이 **객체지향 프로그래밍**이다.  
객체는 `상태`, `식별성`, `동작 방식` 세 가지의 기본적인 속성으로 특정지어진다.  
- 상태는 데이터 타입이 가진 값을 의미한다.
- 식별성은 어떤 객체가 다른 객체와 구분될 수 있음을 의미한다. 객체의 데이터 값이 메모리에 저장된 영역을 생각하면 된다.
- 동작 방식은 데이터 타입 값에 취해진 연산의 효과를 의미한다. 일급 컬렉션을 생각하자

**객체에 이런저런 연산이 행해지는 동안 객체의 식별성이 유지되도록 하는 데는 전적으로 그 연산들의 구현부에 책임이 있다.**  

# 값 객체
  
함수형 스타일 연산은 상태를 변화시키지 않으며 새로운 값을 생성하여 일시적이더라도 고정적인 상황을 표현하고 싶다면 함수형 스타일이 적절하고, 상황이 변하는 경우라면 상태를 사용하는 편이 낫다.  
  
**상태와 객체를 사용한 프로그래밍은 연산에 대한 사고의 틀을 마련해주기에 가능한 한 언제나 스스로의 작은 수학 세계를 만든 후, 변화하는 상태를 갖고 있는 객체를 통해 관리하는 것이 좋다.**  

```java
class Transaction {
    private int value;

    public Transaction(int value, Account credit, Account debit) {
        this.value = value;
        credit.addCredit(this);
        debit.addCredit(this);
    }

    public int getValue() {
        return value;
    }
}
```

위의 Transaction 객체의 경우, 일단 생성된 후에는 값을 변경하는 것이 불가능하다.  
더구나 객체 생성 시 생성자는 2개의 Account 객체를 모두 업데이트하기에 거래가 중간에 중단되는 경우나 거래 금액이 나중에 바뀌는 경우를 걱정할 필요가 없다는 것이다.  
  
이렇게 **값 스타일 객체(변화하는 상태를 지닌 객체가 아닌 정수와 같은 객체)** 를 구현하려면, 먼저 상태를 가지고 있는 세계와 값으로만 구성된 세계를 구별해야 한다.  
즉, **값 스타일의 객체에서는 생성자에서만 모든 상태를 설정할 뿐, 다른 경로를 통해서는 필드 값을 변경하면 안된다.**  
그리고 **값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다.**  
  
결국은 두 가지에서 선택해야 한다.  
1. 변하는 상태를 가진 객체를 참조하는 불변 필드
2. 변하지 않는 상태를 가진 객체를 참조하는 가변 필드

예상한것처럼 Transaction은 값 스타일 객체이고 Account는 변화하는 상태를 가진 객체다.  
이런 값 객체에 반대하는 대표적인 의견으로는 성능이 있지만 큰 설득력이 없다고 생각한다.  
**값 객체 스타일의 프로그래밍을 사용하지 않는 이유는 이런 스타일의 프로그래밍에 익숙하지 않고 상태로 된 부분과 값으로 된 부분을 구별하기 쉽지 않기 때문이다.**  
  
프로그램을 가장 잘 효과적으로 표현하는 방법은 변화하는 상태를 가진 객체와 값 스타일의 객체를 적절히 섞어서 사용하는 것이다.  

# 상태

객체는 **외부에 드러나는 행위** 와 **행위를 지원하기 위한 상태** 를 묶어주는 편리한 단위다.  
그렇기에 모든 상태를 잘게 쪼개서 적당한 객체가 상태를 가지도록 지정할 수 있다.  
이때 상태를 마구잡이로 뒤섞어서 객체를 정의하면 상태를 변경하는 코드의 효과를 예측하기 어렵기 때문에 신중해야 한다.  
  
- **상태** : 시간에 따라 변화하는 값을 사용하여 연산한다.
- **접근** : 상태에 대한 접근을 제한해서 유연성을 조절한다.

객체 지향 언어에서는 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대한 `매우 엄격한` 접근 권한을 적용해서 알지 못하는 사이에 상태가 변해버리는 문제를 막아준다.  
효과적인 상태를 관리하기 위한 키 포인트는 **유사한 상태를 묶어서 관리하고 각 상태를 별도로 관리하는 것이다.**  

1. **상태가 동일한 연산 안에서 사용되는지?**
2. **동일한 시점에 생성되고 소멸되는지?** 

위의 두 가지 기준으로 상태가 유사한지 확인하여 해당되는 상태들을 밀접하게 관리하는 것이 좋은 아이디어일 가능성이 높다.  

# ADT

**추상 데이터 타입 `ADT`**은 그 데이터가 구체적으로 어떻게 표현되어 있는지를 사용자가 알 수 없도록 숨긴다.  
`데이터와 함수를 서로 연결 짓고 데이터의 표현 방식을 클라이언트로부터 숨긴다는 것`이다.  
  
이와 연장선으로, 자바에서는 자바 자체에 내장된 기능들을 모든 데이터 타입들이 적용받을 수 있도록 몇몇 메서드들을 객체의 기본 API로서 항상 정의하도록 하고 있다.
- `equals()`, `hashCode()`, `toString()` ..
  
클라이언튿 코드에서는 변수를 선언하고, 데이터 값을 담고 있는 객체를 생성하고, 그 객체의 인스턴스 메서드를 호출함으로써 데이터를 조작할 수 있다.  
**사용하는 API들의 상세 구현 내용을 몰라도 된다.**  
프로그램들을 독립된 모듈로써 정리해 두면 **재활용하기도 용이해진다.**  
  
> 좋은 시스템 아키텍처 스타일을 유지하려면 시스템이 오직 일부에 사용된 개념의 세부 사항을 전체 시스템에서 볼 수 있게 만들지 않아야 한다.  
> 따라서 Observable의 추가 구조가 필요한 상황에서만 Observable을 사용하고 그렇지 않으면 Publisher의 인터페이스를 사용하는 것이 좋다.  
> 이미 List 인터페이스에도 이 원칙이 적용되어 있다. 예를 들어 전달하는 값이 ArrayList라는 사실을 이미 알고 있지만 이 값의 파라미터 형식을 List로 설정함으로 **구현 세부 사항을 밖으로 노출하지 않을 수 있다.**  
> 나중에 ArrayList를 LinkedList로 바꾸더라도 기존 코드를 크게 바꿀 필요가 없게 된다.  
> - 모던 자바 인 액션, 17.3장 (553p)

> **에일리어싱**  
> 참조 타입 변수를 대입문에 사용하여 참조 타입의 변수를 복제하는 것  
> 이미 존재하는 객체에 대한 참조를 만드는 것


> **값에 의한 전달**  
> 메서드에 인수를 넘기는 것은 마치 대입문의 우측에 인수 변수를 두는 것과 같은 효과가 있다.  
> 자바에서는 메서드 호출 시 인수를 복제하여 넘긴다.  
> 즉, 값에 의한 전달이 참조 자체를 복제하는 것이 되어버려서 "값에 의한 전달"이라는 의미가 다르게 적용된다.  
> 예를 들어 **객체의 참조를 메서드의 인수로 전달하면 메서드 안에서 원본 참조 변수 자체(가리키는 객체)는 바꿀 수 없지만 참조를 통해 원본 객체 본체의 값은 바꿀 수 있다.**  
> 이러한 특성은 여러 객체를 가진 객체의 배열은 객체 하나의 데이터 크기가 크면 배열 내에서 객체 위치를 바꾸어야 할 때 큰 데이터 값을 이리저리 이동시켜야 하는 오버헤드를 피할 수 있게 해준다.