
> 객체를 사용하여 프로그램 수정 비용을 낮추는 것은 모두 사람을 위한 것이다.  
> 사람은 실수하기 쉽고 변덕이 심하며 창조적인데, 이는 컴퓨터에 적합한 덕목들과 상당히 다르다.  
> 컴퓨터는 크고 보기 흉한 코드 덩어리건, 공들여 작성한 객체들로 구성된 코드건 상관없이 똑같이 수행한다.  
> **객체 생성은 독자들에게 연산에 대한 관련된 세부 내용은 당장 알 필요 없다는 메시지를 전달해준다.**  
> 의미 있는 객체 생성을 위해서는 **명확하고 직접적인 표현과 유연성 사이에서 균형을 잡아야 한다.**


# 메모

1. **일반적으로 어떤 결정이 영향을 미치는 범위가 넓어질수록 미래 수정에 대한 유연성은 떨어진다.**
2. **유연성을 위해서는 가급적 작은 양의 정보를 소수의 대상에게만 알리는 것이 좋다.**
3. **개발자가 갖고 있는 모든 정보를 당장 전달하는 것이 능사는 아니다. 구현 전략을 항상 이름에 노출시키기 보다는 사용자의 관점에서 이름을 짓는 편이 좋다.**
   1. 예를 들어, 트리로 구현됐는지 해시맵으로 구현됐는지 구현 정보는 그리 중요한 문제가 아니다.
4. **메소드의 이름을 지을 때는 그 메소드를 호출하는 입장에서 생각해보라.**
   1. `왜 이 메소드를 사용해야 하는가?` 라는 질문에 대한 답을 메소드 이름에서 찾을 수 있어야 한다.
5. **메소드 가시성에 있어 상충하는 두 가지 주요 요소는 외부 사용자에게 기능을 노출시켜야 하는 것과 미래 수정에 대한 유연성이다.**
   1. 먼저 **가장 제한적인 가시성을 선택한 후, 필요에 따라 조금씩 가시성을 높여라.**  
6. **완결 생성자를 구현할 때는 모든 생성자가 동일한 하나의 생성자를 사용해서 모든 초기화를 되도록 하라.**

# 객체

어떤 객체애 대한 개념을 중심으로 하여 그것이 가지는 데이터 값들과 그것을 대상으로 수행 가능한 동작들을 만들어 넣는 것이 **객체지향 프로그래밍**이다.  
객체는 `상태`, `식별성`, `동작 방식` 세 가지의 기본적인 속성으로 특정지어진다.  
- 상태는 데이터 타입이 가진 값을 의미한다.
- 식별성은 어떤 객체가 다른 객체와 구분될 수 있음을 의미한다. 객체의 데이터 값이 메모리에 저장된 영역을 생각하면 된다.
- 동작 방식은 데이터 타입 값에 취해진 연산의 효과를 의미한다. 일급 컬렉션을 생각하자

**객체에 이런저런 연산이 행해지는 동안 객체의 식별성이 유지되도록 하는 데는 전적으로 그 연산들의 구현부에 책임이 있다.**  

# 값 객체
  
함수형 스타일 연산은 상태를 변화시키지 않으며 새로운 값을 생성하여 일시적이더라도 고정적인 상황을 표현하고 싶다면 함수형 스타일이 적절하고, 상황이 변하는 경우라면 상태를 사용하는 편이 낫다.  
  
**상태와 객체를 사용한 프로그래밍은 연산에 대한 사고의 틀을 마련해주기에 가능한 한 언제나 스스로의 작은 수학 세계를 만든 후, 변화하는 상태를 갖고 있는 객체를 통해 관리하는 것이 좋다.**  

```java
class Transaction {
    private int value;

    public Transaction(int value, Account credit, Account debit) {
        this.value = value;
        credit.addCredit(this);
        debit.addCredit(this);
    }

    public int getValue() {
        return value;
    }
}
```

위의 Transaction 객체의 경우, 일단 생성된 후에는 값을 변경하는 것이 불가능하다.  
더구나 객체 생성 시 생성자는 2개의 Account 객체를 모두 업데이트하기에 거래가 중간에 중단되는 경우나 거래 금액이 나중에 바뀌는 경우를 걱정할 필요가 없다는 것이다.  
  
이렇게 **값 스타일 객체(변화하는 상태를 지닌 객체가 아닌 정수와 같은 객체)** 를 구현하려면, 먼저 상태를 가지고 있는 세계와 값으로만 구성된 세계를 구별해야 한다.  
즉, **값 스타일의 객체에서는 생성자에서만 모든 상태를 설정할 뿐, 다른 경로를 통해서는 필드 값을 변경하면 안된다.**  
그리고 **값 스타일의 객체를 다루는 연산은 언제나 새로운 객체를 반환한다.**  
  
결국은 두 가지에서 선택해야 한다.  
1. 변하는 상태를 가진 객체를 참조하는 불변 필드
2. 변하지 않는 상태를 가진 객체를 참조하는 가변 필드

예상한것처럼 Transaction은 값 스타일 객체이고 Account는 변화하는 상태를 가진 객체다.  
이런 값 객체에 반대하는 대표적인 의견으로는 성능이 있지만 큰 설득력이 없다고 생각한다.  
**값 객체 스타일의 프로그래밍을 사용하지 않는 이유는 이런 스타일의 프로그래밍에 익숙하지 않고 상태로 된 부분과 값으로 된 부분을 구별하기 쉽지 않기 때문이다.**  
  
프로그램을 가장 잘 효과적으로 표현하는 방법은 변화하는 상태를 가진 객체와 값 스타일의 객체를 적절히 섞어서 사용하는 것이다.  

# 상태

객체는 **외부에 드러나는 행위** 와 **행위를 지원하기 위한 상태** 를 묶어주는 편리한 단위다.  
그렇기에 모든 상태를 잘게 쪼개서 적당한 객체가 상태를 가지도록 지정할 수 있다.  
이때 상태를 마구잡이로 뒤섞어서 객체를 정의하면 상태를 변경하는 코드의 효과를 예측하기 어렵기 때문에 신중해야 한다.  
  
- **상태** : 시간에 따라 변화하는 값을 사용하여 연산한다.
- **접근** : 상태에 대한 접근을 제한해서 유연성을 조절한다.

객체 지향 언어에서는 전체 시스템을 매우 작은 단위로 쪼갠 후, 각각에 대한 `매우 엄격한` 접근 권한을 적용해서 알지 못하는 사이에 상태가 변해버리는 문제를 막아준다.  
효과적인 상태를 관리하기 위한 키 포인트는 **유사한 상태를 묶어서 관리하고 각 상태를 별도로 관리하는 것이다.**  

1. **상태가 동일한 연산 안에서 사용되는지?**
2. **동일한 시점에 생성되고 소멸되는지?** 

위의 두 가지 기준으로 상태가 유사한지 확인하여 해당되는 상태들을 밀접하게 관리하는 것이 좋은 아이디어일 가능성이 높다.  

# ADT

**추상 데이터 타입 `ADT`**은 그 데이터가 구체적으로 어떻게 표현되어 있는지를 사용자가 알 수 없도록 숨긴다.  
`데이터와 함수를 서로 연결 짓고 데이터의 표현 방식을 클라이언트로부터 숨긴다는 것`이다.  
  
이와 연장선으로, 자바에서는 자바 자체에 내장된 기능들을 모든 데이터 타입들이 적용받을 수 있도록 몇몇 메서드들을 객체의 기본 API로서 항상 정의하도록 하고 있다.
- `equals()`, `hashCode()`, `toString()` ..
  
클라이언튿 코드에서는 변수를 선언하고, 데이터 값을 담고 있는 객체를 생성하고, 그 객체의 인스턴스 메서드를 호출함으로써 데이터를 조작할 수 있다.  
**사용하는 API들의 상세 구현 내용을 몰라도 된다.**  
프로그램들을 독립된 모듈로써 정리해 두면 **재활용하기도 용이해진다.**  
  
> 좋은 시스템 아키텍처 스타일을 유지하려면 시스템이 오직 일부에 사용된 개념의 세부 사항을 전체 시스템에서 볼 수 있게 만들지 않아야 한다.  
> 따라서 Observable의 추가 구조가 필요한 상황에서만 Observable을 사용하고 그렇지 않으면 Publisher의 인터페이스를 사용하는 것이 좋다.  
> 이미 List 인터페이스에도 이 원칙이 적용되어 있다. 예를 들어 전달하는 값이 ArrayList라는 사실을 이미 알고 있지만 이 값의 파라미터 형식을 List로 설정함으로 **구현 세부 사항을 밖으로 노출하지 않을 수 있다.**  
> 나중에 ArrayList를 LinkedList로 바꾸더라도 기존 코드를 크게 바꿀 필요가 없게 된다.  
> - 모던 자바 인 액션, 17.3장 (553p)

> **에일리어싱**  
> 참조 타입 변수를 대입문에 사용하여 참조 타입의 변수를 복제하는 것  
> 이미 존재하는 객체에 대한 참조를 만드는 것


> **값에 의한 전달**  
> 메서드에 인수를 넘기는 것은 마치 대입문의 우측에 인수 변수를 두는 것과 같은 효과가 있다.  
> 자바에서는 메서드 호출 시 인수를 복제하여 넘긴다.  
> 즉, 값에 의한 전달이 참조 자체를 복제하는 것이 되어버려서 "값에 의한 전달"이라는 의미가 다르게 적용된다.  
> 예를 들어 **객체의 참조를 메서드의 인수로 전달하면 메서드 안에서 원본 참조 변수 자체(가리키는 객체)는 바꿀 수 없지만 참조를 통해 원본 객체 본체의 값은 바꿀 수 있다.**  
> 이러한 특성은 여러 객체를 가진 객체의 배열은 객체 하나의 데이터 크기가 크면 배열 내에서 객체 위치를 바꾸어야 할 때 큰 데이터 값을 이리저리 이동시켜야 하는 오버헤드를 피할 수 있게 해준다.

# 예외

예외는 여러 함수 호출을 걸쳐서 제어 흐름을 바꾸는 경우를 표현할 때 유용하게 사용된다.  
시스템에 치명적인 예외는 스택의 한참 아래쪽에서 해결하는 것이 합리적이다.  
예외를 발견한 쪽에서는 예외를 던지고, 예외를 처리하는 쪽에서 예외를 받는 편이 그 사이의 모든 코드에서 예외를 처리하지도 못하면서 예외를 체크하고 전달하며 코드를 지저분하게 하는 것보다는 훨씬 낫다.  
  
예외는 비용이 들어가며 **일종의 설계상 누수** 라고 볼 수 있다.  
예외가 발생할 경우 다음에 수행되는 문장이 다른 메소드나 다른 객체, 다른 패키지에 있을 수도 있으므로 제어 흐름을 따라가기가 어려워진다.  
조건절과 메시지로 구현할 수 있는 코드를 예외로 구현하면 단순 제어 흐름 구조 이외에 어떤 일이 벌어지는지 알아내야 하기 때문에 코드를 읽고 이해하기가 훨씬 어렵다.  
  
**가능하면 순차적 구문, 메시지, 루프, 제어문을 사용해서 제어 흐름을 표현하라.**  
주요 흐름의 이해를 방해하는 경우에만 예외를 사용하라.  
  
> 예외가 발생한 상황을 개발자에게 보내어 문제를 진단할 수 있게 해야한다. 이해할 수 없는 정보를 보여주는 것은 전혀 도움이 안된다.  
> 웹 서버가 갑자기 NPE를 발생시킨다면 어떻게 해야할지 모를 수 있다.  
> **유요한 정보를 제공하도록 하위 수준 예외를 상위 수준 예외로 포장하라.**  

# 메소드 객체

복잡하게 꼬여있는 메소드를 읽기 쉽고 명확하면서도 세부 구현 전달이 쉽도록 바꿔준다.  
메소드 객체를 생성할 때는 **먼저 많은 수의 파라미터와 임시 변수를 사용하는 긴 메소드를 찾아보라.**  

1. 그 메소드의 일부를 많은 파라미터를 사용하는 서브 메소드로 변환한다.  
2. 메소드 이름을 따서 클래스 이름을 정한다.
3. 메소드에서 사용하는 각 파라미터, 지역 변수, 필드에 대해 새로운 객체 상의 필드를 생성한다.
4. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파라미터로 취하는 생성자를 만든다.
5. 기존 메소드에서 사용하던 파라미터, 지역변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 되었다.
6. 본래 메소드를 새로운 클래스의 메소드로 추가한다.
7. 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 메소드를 호출하는 코드로 바꾼다.

**이제 모든 데이터가 필드에 저장되어 있어 파라미터를 사용할 필요가 없기 때문에 새로운 클래스의 코드는 리팩토링이 쉬워진다.**  
때로 메소드를 분화해 나가다 보면, 일부 데이터는 필드가 아닌 지역 변수로 바꾸거나 필드를 파라미터로 바꿔도 괜찮은 경우가 있다.  

# 메소드 반환 타입

메소드가 프로시저인지 특정 타입의 객체를 반환하는 함수인지 구별하는데 도움이 된다.  
**함수를 작성할 때는 의도를 나타내는 반환 타입을 사용하라.**  
때로 구상(콘크리트) 클래스나 기본 타입을 반환 타입으로 사용할 수 있지만 **가급적 메소드의 적용 범위를 넓히기 위해서 가장 추상적인 타입을 사용하라.**  
그래야 이후 구체적인 반환 클래스의 타입을 유연하게 변경할 수 있다.  

# 변환

때로 객체 A를 가진 상태에서 이후 연산을 위해 객체 B가 필요한 경우가 있다.  
프로그래머의 의도를 명확하게 전달하기 위해서는 먼저 변환이 얼마나 많이 필요한지 생각해야 한다.  
하나의 객체가 다른 하나의 객체로 변환되는 경우만 고려한다면 간단한 방법을 사용해도 괜찮지만 변환을 얼마나 많이 해야 할지 알 수 없는 경우에는 다른 방법을 사용해야 한다.  
또 다른 문제는 `클래스 간의 의존성`이다.  
**변환을 편리하게 표현하기 위해 새로운 의존성을 만드는 것은 바람직하지 않다.**  
  
1. 기존 객체의 정보를 복사해서 새로운 타입의 실제 객체를 생성하는 경우
2. 기존 객체에서 정보를 복사하지 않고 대상 객체에 대한 인터페이스를 구현하는 경우
3. 실제 변환을 하지 않고 두 객체 간의 공통 인터페이스를 찾아서 인터페이스를 통해 코드를 작성하는 경우

<h3>변환 메소드</h3>

기존 객체에 메소드를 추가해서 변환을 나타낼 수 있다.  
읽기 쉽다는 장점 때문에 널리 사용되지만 아래와 같은 단점들로 인해 자주 사용하지 않으며, 유사한 타입의 객체 사이의 변환에만 사용된다.  
대개의 경우 변환 메소드보다는 변환 생성자 사용을 선호한다.

1. **하나의 변환 메소드를 만들기 위해서는 원본 객체의 프로토콜을 변경해야 한다.**  
2. **변환 메소드는 원본 객체와 대상 객체 사이에 의존성을 생성한다.** (의존성이 존재하지 않았는데 변환 메소드 때문에 의존성이 생기는 것은 바람직하지 않다.)  
3. **필요한 변환의 수가 제한되지 않는 경우 다루기 어려워진다.** (이런 경우 변환을 이용하는 대신, 클라이언트 측에서 원본 객체를 다룰 수 있게 하는 편이 낫다.)

<h3>변환 생성자</h3>

원본 객체를 파라미터로 취해서 대상 객체를 반환하는 것이며, **하나의 원본 객체를 여러 다른 대상 객체로 변환할 때 유용하다.**  
변환을 사용하더라도 원본 객체의 코드가 지저분해지지 않기 때문이다.  
  
대표적으로 File 클래스는 String으로 된 파일 이름을 받아서 읽기,쓰기,삭제를 수행할 수 있는 객체로 변환한다.  
구상 클래스가 아닌 클래스를 반환해서 변환을 구현하고 싶다면, 변환 생성자를 좀더 일반적인 타입을 반환하는 공장 메소드로 표현할 수 있다.  

# 공장 메소드

객체 생성을 나타내는 다른 방법은 클래스의 정적 메소드를 사용하는 것이다.  
정적 메소드는 생성자에 비해 장점이 있다.  

1. **추상 타입을 반환할 수 있다.**
2. **의도가 담긴 별도의 이름을 가질 수 있다.**

그러나 공장 메소드를 사용하면 `복잡성이 증가`하므로, 이득이 있을 경우에만 사용해야 한다.  
예를 들어, 객체를 생성하는 것보다 복잡한 작업(객체를 캐시에 저장해 놓거나, 런타임에 타입이 결정되는 하위 클래스를 반환하거나 등등)을 하는 경우 유용하다.  
즉, **객체 생성 이외에 다른 의도가 있을 경우에만 공장 메소드를 사용하라.**