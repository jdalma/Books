
# Java/Spring 테스트를 추가하고 싶은 개발자들의 오답노트

> 테스트는 `프로그램이 지켜야 할 계약`과 같은 것이다.

1. 회귀 버그 (Regression) 방지
2. 테스트 코드는 유연한 설계로 개선할 수 있는 기회를 준다. 테스트와 설계는 긴밀한 관계이다.
3. TDD를 적용하였을 때 실패하는 테스트를 먼저 작성하기에 객체지향의 핵심 원리 중 행동(퍼블릭 인터페이스)에 집중하여 개발할 수 밖에 없다.
4. 커버리지를 위한 테스트를 지양해야한다. 스스로 의미있는 테스트인지 판단하는 것이 필요하다.
5. **테스트의 종류**
   1. ~~API 테스트~~ → 대형 테스트 (5%) : 멀티 서버에서 실행되는 테스트이며 E2E를 의미한다.
   2. ~~통합 테스트~~ → 중형 테스트 (15%) : 단일 서버 / 멀티 프로세스 / 멀티 스레드에서 실행되는 테스트이며 Disk IO가 있을 수 있다.
   3. ~~단위 테스트~~ → **소형 테스트 (80%)** : 단일 서버 / 단일 프로세스 / 단일 스레드에서 실행되는 테스트이며 Disk IO와 Blocking Call이 있으면 안된다.
   4. 스프링 개발자는 중형 테스트를 과도하게 작성하는 실수를 많이 하는데 소형 테스트에 집중해야 한다.
6. **SUT : System under test (테스트 하려는 대상)**
7. **상태 기반 검증** : 어떤 값을 시스템에 넣었을 때, 나오는 결괏값을 기댓값과 비교하는 방식 vs **행위 기반 검증** : 어떤 값을 시스템에 넣었을 때, 협력 객체의 어떤 메서드를 실행하는가?
8. **Test Double (테스트 대역)의 종류**
   1.  Dummy : 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
   2.  Fake : Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 있다는게 특징 (RDB를 대신해 인메모리로 구현하는 등)
   3.  Stub : 미리 준비된 값을 출력하는 객체 (mockito를 사용하기도 한다.)
   4.  Mock : 메소드 호출을 확인하기 위한 객체, 자가 검증 능력을 갖춤 (사실상 테스트 더블과 동일한 의미로 사용됨)
   5.  Spy : 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체
9. **Testability 소프트웨어가 테스트가 가능한 구조인가?**
   1. 의존성 주입
   2. **의존성 역전** : 상위 모듈, 하위 모듈 모두 추상화에 의존하는 것 그리고 정책(인터페이스나 추상 클래스)만 import 해야한다.
   3. 의존성 주입만으로 해결하지 못하는 부분을 의존성 역전을 같이 적용하여 해결할 수 있다. (xxxHolder 추상 계층을 추가하는 방법 등)
   4. 의존성 역전을 port-adpater 패턴이라고도 부른다.
   5. 호출자가 모르는 정보가 존재하면 안된다.
   6. `얼마나 쉽게 input을 변경하고, output을 쉽게 검증할 수 있는가?`
10. 엔티티는 JPA랑 상관이 없다. 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 서로 다르다.
   1. 도메인 엔티티 : 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델. 비즈니스 로직을 들고 있고, 식별 가능하며, 일반적으로 생명주기를 갖는다.
   2. DB 엔티티 : 데이터베이스에 표현하려고 하는 유형, 무형의 객체로서 서로 구별되는 것을 뜻한다.
   3. 영속성 객체 (JPA + Hibernate) : RDB에 있는 데이터를 객체로 매핑해주는 ORM이다.
   4. 영속성 객체를 도메인 엔티티처럼 사용해서는 안된다.
11. **테스트를 작성할 때는 중복이 어느정도 용인되지만 서술적이고 의미있는 문구를 작성하려 노력해야 한다.**
12. 흔한 컨벤션은 아니지만 `get`과 `find`를 구분하는 컨벤션이 있다. `get`은 애초에 데이터가 없으면 예외를 던진다는 의미가 내포되어 있다.
14. 2부의 핵심은
    1.  의존성 역전 원리를 이용하여 외부를 다룰 것이다. 의존 관계를 약화시키고 독립적이게 되며 테스트가 쉽도록 개선된다.
    2.  모키토나 h2를 사용하지 않으면서 테스트를 작성할 것이다.
    3.  현재 layer로만 분류되어 있는 것을 domain/layer로 분류하여 도메인을 밖으로 노출해서 어떤 시스템인지 빠르게 파악할 수 있도록 한다. 이렇게하면 필요에 따라 패키지별로 MSA로 확장이 가능하다.
        1.  패키지별로 분리하게되면 패키지간 순환참조가 발생하지 않도록 신경써야한다.
    4.  CQRS 원리를 적용하기 위해 Repository와 도메인 객체를 Reader와 Writer를 분리한다.
15. repository를 infrastructure로 변경하게 되면서 Service가 의존하게 될 Repository 인터페이스를 infrastructure에 작성하면 Service가 infrastructure에 의존하게 되기 때문에 Service 내부 port 패키지 안에 Service가 사용하는 인터페이스들을 모은다.
16. 도메인 엔티티를 영속성 객체로 바꾸는 책임을 도메인 엔티티가 가질 수도 있지만 도메인은 인프라 레이어의 정보를 모르는 것이 좋다.
17. 도메인 객체와 영속성 객체를 구분하게 되었을 때 [참고](https://www.inflearn.com/community/questions/1146350/%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B2%8C-%EB%90%98%EB%A9%B4)
18. Controller, Service, Domain 테스트를 모두 소형 테스트로 작성할 수 있다.
19. 테스트는 품질 보증을 위한 도구이기도 하지만 설계를 위한 도구이기도 하며, Testability를 높여야 설계를 위한 도구로서 온전히 활용할 수 있는 것이고 테스트의 가치를 더 끌어낼 수 있다.
26. **DDD와 클린 아키텍처**
    1.  비즈니스에 집중하기 위해서는 DDD를 학습
    2.  비즈니스를 잘 짜기 위해서는 테스트를 학습
    3.  비즈니스와 기술을 분리하는 방법은 클린 아키텍처를 학습
    4.  비즈니스와 기술을 분리하는 구체적인 방법은 헥사고날 아키텍처를 학습
27. **테스트는 어디까지 해야하는가?**
    1.  커버리지는 중요한게 아니다. 릴리즈할 때 확신을 주면 된다.
    2.  테스트는 무엇을 해야하는가? [자바와 Junit을 활용한 실용주의 단위 테스트](https://m.yes24.com/Goods/Detail/75189146)에서 소개된 Right-BICEP 원칙