
# Java/Spring 테스트를 추가하고 싶은 개발자들의 오답노트

> 테스트는 `프로그램이 지켜야 할 계약`과 같은 것이다.

1. 회귀 버그 (Regression) 방지
2. 테스트 코드는 유연한 설계로 개선할 수 있는 기회를 준다. 테스트와 설계는 긴밀한 관계이다.
3. TDD를 적용하였을 때 실패하는 테스트를 먼저 작성하기에 객체지향의 핵심 원리 중 행동(퍼블릭 인터페이스)에 집중하여 개발할 수 밖에 없다.
4. 커버리지를 위한 테스트를 지양해야한다. 스스로 의미있는 테스트인지 판단하는 것이 필요하다.
5. **테스트의 종류**
   1. ~~API 테스트~~ → 대형 테스트 (5%) : 멀티 서버에서 실행되는 테스트이며 E2E를 의미한다.
   2. ~~통합 테스트~~ → 중형 테스트 (15%) : 단일 서버 / 멀티 프로세스 / 멀티 스레드에서 실행되는 테스트이며 Disk IO가 있을 수 있다.
   3. ~~단위 테스트~~ → **소형 테스트 (80%)** : 단일 서버 / 단일 프로세스 / 단일 스레드에서 실행되는 테스트이며 Disk IO와 Blocking Call이 있으면 안된다.
   4. 스프링 개발자는 중형 테스트를 과도하게 작성하는 실수를 많이 하는데 소형 테스트에 집중해야 한다.
6. **SUT : System under test (테스트 하려는 대상)**
7. **상태 기반 검증** : 어떤 값을 시스템에 넣었을 때, 나오는 결괏값을 기댓값과 비교하는 방식 vs **행위 기반 검증** : 어떤 값을 시스템에 넣었을 때, 협력 객체의 어떤 메서드를 실행하는가?
8. **Test Double (테스트 대역)의 종류**
   1.  Dummy : 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
   2.  Fake : Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체, 자체적인 로직이 있다는게 특징 (RDB를 대신해 인메모리로 구현하는 등)
   3.  Stub : 미리 준비된 값을 출력하는 객체 (mockito를 사용하기도 한다.)
   4.  Mock : 메소드 호출을 확인하기 위한 객체, 자가 검증 능력을 갖춤 (사실상 테스트 더블과 동일한 의미로 사용됨)
   5.  Spy : 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체
9. **Testability 소프트웨어가 테스트가 가능한 구조인가?**
   1. 의존성 주입
   2. **의존성 역전** : 상위 모듈, 하위 모듈 모두 추상화에 의존하는 것 그리고 정책(인터페이스나 추상 클래스)만 import 해야한다.
   3. 의존성 주입만으로 해결하지 못하는 부분을 의존성 역전을 같이 적용하여 해결할 수 있다. (xxxHolder 추상 계층을 추가하는 방법 등)
   4. 의존성 역전을 port-adpater 패턴이라고도 부른다.
   5. 호출자가 모르는 정보가 존재하면 안된다.
   6. `얼마나 쉽게 input을 변경하고, output을 쉽게 검증할 수 있는가?`
10. 엔티티는 JPA랑 상관이 없다. 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 서로 다르다.
   1. 도메인 엔티티 : 소프트웨어에서 어떤 도메인이나 문제를 해결하기 위해 만들어진 모델. 비즈니스 로직을 들고 있고, 식별 가능하며, 일반적으로 생명주기를 갖는다.
   2. DB 엔티티 : 데이터베이스에 표현하려고 하는 유형, 무형의 객체로서 서로 구별되는 것을 뜻한다.
   3. 영속성 객체 (JPA + Hibernate) : RDB에 있는 데이터를 객체로 매핑해주는 ORM이다.
   4. 영속성 객체를 도메인 엔티티처럼 사용해서는 안된다.
11. **테스트를 작성할 때는 중복이 어느정도 용인되지만 서술적이고 의미있는 문구를 작성하려 노력해야 한다.**
12. 흔한 컨벤션은 아니지만 `get`과 `find`를 구분하는 컨벤션이 있다. `get`은 애초에 데이터가 없으면 예외를 던진다는 의미가 내포되어 있다.
14. 2부의 핵심은
    1.  의존성 역전 원리를 이용하여 외부를 다룰 것이다. 의존 관계를 약화시키고 독립적이게 되며 테스트가 쉽도록 개선된다.
    2.  모키토나 h2를 사용하지 않으면서 테스트를 작성할 것이다.
    3.  현재 layer로만 분류되어 있는 것을 domain/layer로 분류하여 도메인을 밖으로 노출해서 어떤 시스템인지 빠르게 파악할 수 있도록 한다. 이렇게하면 필요에 따라 패키지별로 MSA로 확장이 가능하다.
        1.  패키지별로 분리하게되면 패키지간 순환참조가 발생하지 않도록 신경써야한다.
    4.  CQRS 원리를 적용하기 위해 Repository와 도메인 객체를 Reader와 Writer를 분리한다.
15. repository를 infrastructure로 변경하게 되면서 Service가 의존하게 될 Repository 인터페이스를 infrastructure에 작성하면 Service가 infrastructure에 의존하게 되기 때문에 Service 내부 port 패키지 안에 Service가 사용하는 인터페이스들을 모은다.
16. 도메인 엔티티를 영속성 객체로 바꾸는 책임을 도메인 엔티티가 가질 수도 있지만 도메인은 인프라 레이어의 정보를 모르는 것이 좋다.
17. 도메인 객체와 영속성 객체를 구분하게 되었을 때 [참고](https://www.inflearn.com/community/questions/1146350/%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B0%9D%EC%B2%B4%EC%99%80-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B2%8C-%EB%90%98%EB%A9%B4)
18. Controller, Service, Domain 테스트를 모두 소형 테스트로 작성할 수 있다.
19. 테스트는 품질 보증을 위한 도구이기도 하지만 설계를 위한 도구이기도 하며, Testability를 높여야 설계를 위한 도구로서 온전히 활용할 수 있는 것이고 테스트의 가치를 더 끌어낼 수 있다.

26. **DDD와 클린 아키텍처**
    1.  비즈니스에 집중하기 위해서는 DDD를 학습
    2.  비즈니스를 잘 짜기 위해서는 테스트를 학습
    3.  비즈니스와 기술을 분리하는 방법은 클린 아키텍처를 학습
    4.  비즈니스와 기술을 분리하는 구체적인 방법은 헥사고날 아키텍처를 학습
27. **테스트는 어디까지 해야하는가?**
    1.  커버리지는 중요한게 아니다. 릴리즈할 때 확신을 주면 된다.
    2.  테스트는 무엇을 해야하는가? [자바와 Junit을 활용한 실용주의 단위 테스트](https://m.yes24.com/Goods/Detail/75189146)에서 소개된 Right-BICEP 원칙

# 아키텍처

**아키텍처란?** 어떤 비즈니스를 문제를 해결하기 위해 준수해야하는 제약을 넣는 과정
아키텍처를 지키려하면 오히려 더 불편해진다. 사람들이 왜 많이 배우려할까? 꼭 써야하는 이유가 있기 때문이다.  
꼭 써야 하는 이유를 먼저 파악하고 구성원 모두가 공감을 해야 한다.  
  
아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 좋은 아키텍처가 만들어진다.  
목표는 인적 자원 절감과 정책을 만들고 세부사항을 미루는 시스템을 개발하는 것이다.  
세부사항인 데이터베이스, 웹 서버, REST, 의존성 주임 프레임워크와 같은 기술적 사항들을 먼저 고려할 것이 아니라 **도메인을 먼저 고려해야 한다.**

> 인적 자원 절감 → 동시 작업이 가능해야 한다. → 관심사를 분리한다. → 의존성 역전과 같은 방법들을 적용한다.

핵심은 본질인 도메인과 스프링과 같은 웹 프레임워크, 영속성 프레임워크와 결합되지 않도록 분리시키는 것이다.  

## **레이어드 아키텍처의 단점**

1.  DB 주도 설계를 유도한다.
2.  영속성 계층부터 먼저 고민하기에 의존성에 대한 고민을 유도하지 않고 도메인이 죽으며 동시 작업이 불가하다.
3.  규모가 커질수록 확장성이 떨어진다.
4.  상향식, 하향식 모두 프레임워크를 먼저 생각하게 된다.
5.  **즉, 절차지향적 사고를 유도하기에 낮은 Testability & Bad SOLID 에 이르게 된다.**

## **헥사고날 아키텍처**  

[Hexagonal Architecture with Java and Spring](https://reflectoring.io/spring-hexagonal/)  

> 외부(기술) 환경에 영향을 받지 않고 소프트웨어는 오직 도메인에 충실하게 된다.

Domain 계층은 순수 비즈니스 로직만 존재하며 계층간 연결된 의존성이 없는 OOP로 이루어진 테스트하기 쉬운 계층이다.  
Persistence 계층은 현재 Repository만 고려하지만 만약 JavaMailSender나 외부 네트워크 통신도 포함되게 되는 경우 infrastructure 레이어라고 부른다.  
infrastructure 계층은 DB와 JPA에 강결합되어 있기에 의존성 역전을 이용하여 Application(Service) 계층에 우리가 포트(추상화한 인터페이스)를 적용하여 Fake를 쓸 수 있어 테스트하기 쉽도록 개선할 수 있다.  
Controller 계층은 Application, Domain, infrastructure 계층에 의존한다.  
테스트를 위해 이 3개를 모두 준비하는 것은 테스트가 비대해질 확률이 높다. 그리하여 이 부분도 Application 계층의 의존성 역전을 통해 테스트하기 쉽도록 개선할 수 있다.

`Businsess layer = Application layer + Domain layer`  

1.  헥사고날의 접근법은 상향식일 때 자연스럽다. input port, output port  
2.  헥사고날이 클린 아키텍처의 실천법으로 나온 내용이다. 다만 클린 아키텍처는 input port를 Use case라고, output port를 Gateway 라고, adapter를 Humble이라고 부른다.
3.  의존성 역전 (포트-어댑터 패턴) → 인터페이스라는 포트(input port)에다가 필요한 input adapter(클라이언트)를 꽂아주는 느낌이기 때문이다. 즉, 실행 객체(구현체)는 포트를 통해 연결된 어댑터를 사용할 뿐이다.
4.  계층형 아키텍처 스타일과 달리 구성 요소간의 종속성이 도메인 객체를 향해 안쪽으로 향한다는 장점이 있기에 도메인은 고립되고 순수해진다.
6.  추상화와 의존성 역전을 통해 테스트에 유리하다.

![](./imgs/hexagonal.png)

## **모델은 어디까지 분리해야 하는가?**

1.  일반적으로 요청/응답 전용 모델과 도메인 모델, 엔티티 모델 이렇게 3단 분류를 많이 사용한다.
2.  하지만 시스템이 점점 커지면 input adapter가 input port를 호출할 때 파라미터를 나열하기 힘들어진다. 그렇다고 요청 전용 모델 (RequestDTO)를 전달하는 것은 하위 모듈이 상위 모듈에 의존하게 되므로 순환 참조가 발생한다.
3.  그렇기에 input port와 service만을 위한 입력을 받아주는 모델이 또 필요로 하게 된다.
4.  **웹 모델 / in port 모델 / 도메인 모델 / out port 모델 / 엔티티 모델** 이렇게 7개의 모델이 만들어질 수 있다.
5.  이 모델들의 상위 인터페이스를 둬서 단방향 매핑 전략을 사용할 수도 있다.
6.  이렇게 구성이 점점 과해지게 되면서 어떤 전략을 사용할지 정답은 없다. 원칙은 모두 지키는 것지 좋지만 `이게 정말로 필요한가?`를 고민해야 한다.

## **Repository를 다루는 방식**

1.  서비스 구현체가 JpaRepository에 의존하는 방식
    1.  JpaRepository는 이미 인터페이스이기 때문에 엄청 잘못된 방식은 아니다.
    2.  하지만 Fake가 불필요한 인터페이스에 모두 알게되며, ServiceImpl에서 사용하는 Domain entity가 Persistence entity에 종속되며 ServiceImpl도 Jpa에 의존된다.
2.  Repository 인터페이스는 JpaRepository와 격리하여 사용하고 RepositoryImpl을 interface로 생성하여 JpaRepository를 구현하는 방식
    1.  Repository가 필요한 인터페이스만 사용하도록 하므로, Service는 JpaRepository의 모든 기능을 알고 있을 필요가 없다.
    2.  하지만 이 방법 역시 JpaRepository의 entity 타입이 Service까지 전파되기 때문에 Domain entity와 Persistence entity를 분리할 수 없다. 
3.  Repository 인터페이스는 JpaRepository와 격리하여 사용하고 RepositoryImpl을 콘크리트 클래스로 생성하여 JpaRepository를 구현하는 방식
    1.  이 방법을 사용하면 콘크리트 클래스가 JpaRepository를 주입받아 엔티티를 도메인 모델로 변경하여 반환하기에 모두 해결할 수 있다.

## **Use Case(input port)는 추상화 되어야 하는가?**

1.  input Adapter(Controller)의 Testability를 높이기 위해선 추상화가 되어야 한다.
2.  하지만 input Adapter는 유스케이스를 호출하는 책임밖에 없기에 테스트가 꼭 필요한 계층은 아니다.
3.  Use case 자체가 특정 응용 프로그램의 특정한 사용 사례(application service)를 나타내기 때문에 사용 사례가 바뀌면 서비스 자체도 바뀌어야 하므로 인터페이스를 지니지 않아도 된다.
4.  이러니 저러니 해도 결국 트레이드 오프다.