# 메모

1. id 컬럼의 숫자는 쿼리 실행 순서가 아니며 단순한 식별자 값이다.
   1. 만약 id 컬럼의 숫자가 같다면 먼저 출력된 레코드가 드라이빙 테이블이다.
2. UNION ALL은 임시 테이블을 사용하지 않도록 개선됐지만, UNION은 여전히 임시 테이블을 사용한다..
3. `=` 연산자와 `<=>` 연산자의 차이점
4. `인덱스 레인지 스캔` 또는 `레인지 스캔` 이라고 하면 const, ref, range 라는 세 가지 접근 방법을 모두 묶어서 지칭하는 것임을 기억하라
   1. 이 세 가지를 꼭 구분하진 않는다.

# 통계 정보

MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했기에 실행 계획의 정확도가 떨어지는 경우가 많았다.  
**MySQL 8.0 버전부터는 인덱스되지 않은 컬럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.**  
그렇다고해서 테이블 및 인덱스의 통계 정보가 필요치 않은 것은 아니다.

테이블 및 인덱스에 대한 통계 정보와 히스토그램을 나누어 확인해보자.

## 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다.  
**MySQL 5.6 버전 부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다.**  
각 테이블의 통계 정보를 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되면서 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 됐다.

```sql
mysql> select * from mysql.innodb_index_stats where database_name='employees' and table_name='salaries';

+---------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+
| database_name | table_name | index_name | last_update         | stat_name    | stat_value | sample_size | stat_description                  |
+---------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | n_diff_pfx01 |     307242 |          20 | emp_no                            |
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | n_diff_pfx02 |    2838426 |          20 | emp_no,from_date                  |
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | n_leaf_pages |       6078 |        NULL | Number of leaf pages in the index |
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | size         |       6120 |        NULL | Number of pages in the index      |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_diff_pfx01 |      97450 |          20 | salary                            |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_diff_pfx02 |    2821563 |          20 | salary,emp_no                     |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_diff_pfx03 |    2950846 |          20 | salary,emp_no,from_date           |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_leaf_pages |       4157 |        NULL | Number of leaf pages in the index |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | size         |       4777 |        NULL | Number of pages in the index      |
+---------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+

mysql> select * from mysql.innodb_table_stats where database_name='employees' and table_name='salaries';

+---------------+------------+---------------------+---------+----------------------+--------------------------+
| database_name | table_name | last_update         | n_rows  | clustered_index_size | sum_of_other_index_sizes |
+---------------+------------+---------------------+---------+----------------------+--------------------------+
| employees     | salaries   | 2024-03-19 14:24:23 | 2838426 |                 6120 |                     4777 |
+---------------+------------+---------------------+---------+----------------------+--------------------------+
```

1. **innodb_index_stats.stat_name**
   1. `n_diff_pfx%` : 인덱스가 가진 유니크한 값의 개수
   2. `n_leaf_pages` : 인덱스의 리프 노드 페이지 개수
   3. `size` : 인덱스 트리의 전체 페이지 개수

## 히스토그램

MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다.  
8.0 버전으로 업그레이드 되면서 **컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됐다.**

히스토그램 정보는 **컬럼 단위로 관리되는데, 자동으로 수집되지 않고 `ANALYZE TABLE .. UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.**  
수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema.column_statistics` 테이블로 로드한다.

```sql
mysql> analyze table employees.employees update histogram on gender, hire_date;

+---------------------+-----------+----------+------------------------------------------------------+
| Table               | Op        | Msg_type | Msg_text                                             |
+---------------------+-----------+----------+------------------------------------------------------+
| employees.employees | histogram | status   | Histogram statistics created for column 'gender'.    |
| employees.employees | histogram | status   | Histogram statistics created for column 'hire_date'. |
+---------------------+-----------+----------+------------------------------------------------------+

mysql> select * from information_schema.COLUMN_STATISTICS where schema_name='employees' and table_name='employees'\G

*************************** 1. row ***************************
SCHEMA_NAME: employees
 TABLE_NAME: employees
COLUMN_NAME: gender
  HISTOGRAM: {
    "buckets": [[1, 0.5992564987177832], [2, 1.0]],
    "data-type": "enum",
    "null-values": 0.0,
    "collation-id": 45,
    "last-updated": "2024-03-24 14:04:47.827784",
    "sampling-rate": 0.34735190026498786,
    "histogram-type": "singleton",
    "number-of-buckets-specified": 100
  }
*************************** 2. row ***************************
SCHEMA_NAME: employees
 TABLE_NAME: employees
COLUMN_NAME: hire_date
  HISTOGRAM: {
    "buckets": [["1985-01-01", "1985-02-28", 0.0098334040551261, 31], ["1985-03-01", "1985-03-27", 0.019897422651882737, 27], ... ["1998-09-15", "2000-01-28", 1.0, 442]], 
    "data-type": "date", 
    "null-values": 0.0, 
    "collation-id": 8, 
    "last-updated": "2024-03-24 14:04:47.834205", 
    "sampling-rate": 0.34735190026498786,   -- 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율, 34%
    "histogram-type": "equi-height", 
    "number-of-buckets-specified": 100      -- 히스토그램을 생성할 때 설정했던 버킷의 개수, 기본으로 100개의 버킷이 사용됨
  }
```

- `Singleton` 히스토그램 : 컬럼값 개별로 레코드 건수를 관리하는 히스토그램
  - 각 버킷이 `컬럼의 값`과 `발생 빈도의 비율` 이 2개의 값을 가진다.
- `Equi-Height` 히스토그램 : 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램
  - 각 버킷이 `범위의 시작 값`과 `마지막 값`, 그리고 `발생 빈도율`과 각 버킷에 포함된 `유니크한 값의 개수` 4개의 값을 가진다.
  
**히스토그램은 버킷 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리되는데, 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며 높이 균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다.**  

> 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.  
> 히스토그램 정보가 없다면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측하기에 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.  

## 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.  
쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.  
**이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보며 이 작업을 `인덱스 다이브`라고 표현한다.**  
  
조건절에 인덱스에 사용된 컬럼이 명시된다면 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.  

## 코스트 모델

MySQL 서버가 쿼리를 처리하려면 아래와 같은 다양한 작업을 필요로 한다.

1. 디스크로부터 데이터 페이지 읽기
2. 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
3. 인덱스 키 비교
4. 레코드 평가
5. 메모리 임시 테이블 작업
6. 디스크 임시 테이블 작업

사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다.  
**이렇게 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용을 `코스트 모델`이라고 한다.**  
  
MySQL 서버 8.0의 코스트 모델은 아래 2개의 테이블에 저장돼 있는 설정 값을 사용하며, 모두 MySQL DB에 존재한다.  

- `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리

# 실행 계획 확인

`DESC` 또는 `EXPLAIN` 명령으로 확인할 수 있다.  
쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.  

```sql
mysql> explain analyze
    -> select e.emp_no, avg(s.salary)
    -> from employees e inner join salaries s
    ->     on e.emp_no = s.emp_no and
    ->        s.salary > 50000 and
    ->        s.from_date <= '1990-01-01' and
    ->        s.to_date > '1990-01-01'
    -> where e.first_name = 'Matt'
    -> group by e.emp_no\G

*************************** 1. row ***************************
EXPLAIN: -> Group aggregate: avg(s.salary)  (cost=474 rows=120) (actual time=0.246..3.32 rows=48 loops=1)
    -> Nested loop inner join  (cost=462 rows=120) (actual time=0.168..3.27 rows=48 loops=1)
        -> Covering index lookup on e using ix_firstname (first_name='Matt')  (cost=26 rows=233) (actual time=0.124..0.217 rows=233 loops=1)
        -> Filter: ((s.salary > 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))  (cost=0.947 rows=0.513) (actual time=0.0116..0.0129 rows=0.206 loops=233)
            -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=0.947 rows=9.24) (actual time=0.00841..0.0111 rows=9.53 loops=233)
```

- **들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행**
- **들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행**
  
1. **커버링 인덱스 조회 (Covering index lookup)**
   - ix_firstname 인덱스를 사용하여 e 테이블에서 first_name='Matt' 조건을 만족하는 행을 찾습니다.
   - 비용은 26이고, 예상 행 수는 233개입니다. 실제 시간은 0.124초에서 0.217초 사이이며, 실제로 233개의 행을 찾았습니다.
   - 이 단계는 쿼리의 시작점으로, 특정 이름을 가진 직원들을 빠르게 찾기 위해 인덱스를 사용합니다.
2. **인덱스 조회 (Index lookup)**
   - 이 단계는 각 직원 번호(emp_no)에 대해 salary 정보를 조회하는 내용에 대한 설명이다.
   - PRIMARY 인덱스를 사용하여 s 테이블에서 emp_no=e.emp_no 조건을 만족하는 행을 찾습니다.
   - 비용은 0.947이며, 예상 행 수는 9.24개입니다. 실제 시간은 각 루프에서 0.00841초에서 0.0111초 사이이며, 평균적으로 9.53개의 행을 찾았습니다.
3. **필터 (Filter)**
   - 조회된 s 테이블의 행에 대해 조건 ((s.salary > 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))를 적용합니다.
   - 비용은 0.947이며, 예상적으로 0.513개의 행이 조건을 만족할 것으로 보입니다. 실제 처리 시간은 각 루프에서 0.0116초에서 0.0129초 사이이며, 평균적으로 0.206개의 행이 조건을 만족합니다.
   - 이 단계는 급여 정보가 특정 조건을 만족하는지 필터링합니다.
4. **중첩 루프 내부 조인 (Nested loop inner join)**
   - 앞서의 두 단계를 통해 얻은 결과를 조인합니다.
   - 비용은 462이며, 예상 행 수는 120개입니다. 실제 시간은 0.168초에서 3.27초 사이이며, 48개의 행이 결과로 나왔습니다.
   - 이 단계에서는 첫 번째 단계에서 찾은 직원들과 세 번째 단계에서 필터링한 급여 정보를 조인합니다.
5. **그룹 집계 (Group aggregate)**
   - 조인된 결과에 대해 avg(s.salary)를 계산합니다.
   - 비용은 474이며, 예상 행 수는 120개입니다. 실제 처리 시간은 0.246초에서 3.32초 사이이며, 최종적으로 48개의 그룹이 생성됩니다.
   - 이 단계는 최종 결과인 각 그룹에 대한 평균 급여를 계산합니다.
  
# 실행 계획 분석 ⭐️

실행 계획의 각 라인은 쿼리 문장에서 사용된 테이블(서브쿼리로 임시 테이블을 생성한 경우 그 임시 테이블까지 포함)의 개수만큼 출력된다.  
일반적으로 실행 순서는 위에서 아래로 표시되며, UNION이나 상관 서브 쿼리와 같은 경우 순서대로 표시되지 않을 수 있다.  

## `id` 컬럼

`id` 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 조인같은 경우에는 같은 `id` 값이 부여될 수 있다.  


```sql
explain
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no LIMIT 10;

+----+-------------+-------+------------+-------+---------------+--------------+---------+--------------------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref                | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+--------------+---------+--------------------+--------+----------+-------------+
|  1 | SIMPLE      | e     | NULL       | index | PRIMARY       | ix_firstname | 58      | NULL               | 299888 |   100.00 | Using index |
|  1 | SIMPLE      | s     | NULL       | ref   | PRIMARY       | PRIMARY      | 4       | employees.e.emp_no |      9 |   100.00 | NULL        |
+----+-------------+-------+------------+-------+---------------+--------------+---------+--------------------+--------+----------+-------------+


explain select (
    (select count(*) from employees) + (select count(*) from departments)
) as TOTAL;

+----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
| id | select_type | table       | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
|  1 | PRIMARY     | NULL        | NULL       | NULL  | NULL          | NULL        | NULL    | NULL |   NULL |     NULL | No tables used |
|  3 | SUBQUERY    | departments | NULL       | index | NULL          | ux_deptname | 162     | NULL |      9 |   100.00 | Using index    |
|  2 | SUBQUERY    | employees   | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index    |
+----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
```

**한 가지 주의해야할 것은 id컬럼이 테이블의 접근 순서를 의미하지는 않는다는 것이다.**  

```sql
select *
from dept_emp de
where de.emp_no = (
    select e.emp_no
    from employees e
    where e.first_name = 'Georgi' and
          e.last_name = 'Facello'
    LIMIT 1
)

-- 테이블 형식 실행 계획
+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys     | key               | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | de    | NULL       | ref  | ix_empno_fromdate | ix_empno_fromdate | 4       | const |    1 |   100.00 | NULL        |
|  2 | SUBQUERY    | e     | NULL       | ref  | ix_firstname      | ix_firstname      | 58      | const |  253 |    10.00 | Using where |
+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+
```

위의 테이블 형식 실행 계획의 `id`값을 보면 `dept_emp` 테이블을 먼저 읽고 `employees`를 읽은것으로 생각할 수 있지만, 트리 형식의 실행 계획으로 확인하면 순서를 더 정확히 알 수 있다.  

```sql
+-----------------------------------------------------------------------------------------+
| EXPLAIN                                                                                 |
+-----------------------------------------------------------------------------------------+
| -> Index lookup on de using ix_empno_fromdate (emp_no=(select #2))  (cost=1.09 rows=1)  |
+-----------------------------------------------------------------------------------------+
```

`select #2` 라고 된 부분이 `id`값이 2인 employees 테이블이다. employees 테이블이 가장 먼저 조회되고, 그 결과를 이용해 dept_emp 테이블을 조회했다고 볼 수 있다.  

## `select_type` 컬럼

**각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다.**  

### SIMPLE

UNION이나 서브쿼리를 사용하지 않는 **단순한 SELECT 쿼리인 경우 해당 쿼리 문장이 SIMPLE로 표시된다.**  
(쿼리에 조인이 포함된 경우에도 마찬가지다.)  
**쿼리 문장이 아무리 복잡하더라도 실행 계획에서 SIMPLE인 단위 쿼리는 하나만 존재한다.**  
일반적으로 제일 바깥 쿼리가 SIMPLE이다.  

### PRIMARY

**UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리가 PRIMARY로 표시된다.**  
이 타입도 하나만 존재하며, 제일 바깥쪽에 있는 쿼리가 PRIMARY로 표시된다.  

### UNION

**UNION으로 결합하는 단위 SELECT 쿼리 중 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리가 UNION으로 표시된다.**  
UNION의 첫 번째 단위 SELECT는 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.  

```sql
select * from (
    (select e1.emp_no from employees e1 LIMIT 10) UNION ALL
    (select e2.emp_no from employees e2 LIMIT 10) UNION ALL
    (select e3.emp_no from employees e3 LIMIT 10)
) tb;

+----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL        | NULL    | NULL |     30 |   100.00 | NULL        |
|  2 | DERIVED     | e1         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index |
|  3 | UNION       | e2         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index |
|  4 | UNION       | e3         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index |
+----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
```

세 개의 서브쿼리로 조회된 결과를 UNION ALL로 결합해 임시 테이블을 만들어서 사용하고 있으므로 DERIVED라는 타입을 갖는 것이다.

### DEPENDENT UNION

**UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시되며 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.**  

```sql
explain select * from employees e1
where e1.emp_no in (
    select e2.emp_no from employees e2 where e2.first_name='Matt'
    union
    select e3.emp_no from employees e3 where e3.last_name='Matt'
);

+----+--------------------+------------+------------+--------+----------------------+---------+---------+------+--------+----------+-----------------+
| id | select_type        | table      | partitions | type   | possible_keys        | key     | key_len | ref  | rows   | filtered | Extra           |
+----+--------------------+------------+------------+--------+----------------------+---------+---------+------+--------+----------+-----------------+
|  1 | PRIMARY            | e1         | NULL       | ALL    | NULL                 | NULL    | NULL    | NULL | 299888 |   100.00 | Using where     |
|  2 | DEPENDENT SUBQUERY | e2         | NULL       | eq_ref | PRIMARY,ix_firstname | PRIMARY | 4       | func |      1 |     5.00 | Using where     |
|  3 | DEPENDENT UNION    | e3         | NULL       | eq_ref | PRIMARY              | PRIMARY | 4       | func |      1 |    10.00 | Using where     |
|  4 | UNION RESULT       | <union2,3> | NULL       | ALL    | NULL                 | NULL    | NULL    | NULL |   NULL |     NULL | Using temporary |
+----+--------------------+------------+------------+--------+----------------------+---------+---------+------+--------+----------+-----------------+
```

위의 예제 쿼리를 보면 두 개의 SELECT 쿼리가 UNION으로 결합됐으므로 `select_type`이 UNION으로 표시된 것을 볼 수 있다.  
이 경우 **IN 내부의 서브쿼리를 먼저 처리하지 않고, 외부의 employees 테이블을 먼저 읽은 다음 서브쿼리를 실행하는데 이때 employees 테이블의 컬럼값이 서브쿼리에 영향을 준다.**  
이렇게 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 키워드가 표시된다.  
  
결국 내부적으로는 UNION에 사용된 SELECT 쿼리의 WHERE 조건에 `"e2.emp_no=e1.emp_no"`와 `"e3.emp_no=e1.emp_no"`라는 조건이 자동으로 추가되어 실행된다.  
외부에 정의된 employees 테이블의 emp_no 컬럼이 서브쿼리에 사용되기 때문에 DEPENDENT UNION이 select_type에 표시된 것이다.  

### UNION RESULT

**UNION 결과를 담아두는 테이블을 의미한다.** MySQL 8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다.  
(하지만 UNION은 여전히 임시 테이블에 결과를 버퍼링한다.)  

```sql
mysql> explain select emp_no from salaries where salary > 100000
    -> union distinct
    -> select emp_no from dept_emp where from_date > '2001-01-01';

+----+--------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
| id | select_type  | table      | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
+----+--------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
|  1 | PRIMARY      | salaries   | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
|  2 | UNION        | dept_emp   | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
|  3 | UNION RESULT | <union1,2> | NULL       | ALL   | NULL                          | NULL        | NULL    | NULL |   NULL |     NULL | Using temporary          |
+----+--------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
```

**UNION RESULT 라인의 table 컬럼은 `<union1,2>`로 표시돼 있는데, 이것이 id값이 1인 단위 쿼리와 2인 단위 쿼리의 조회 결과를 UNION 했다는 것을 의미한다.**  
위의 예제를 UNION ALL로 변경하면 임시 테이블에 버퍼링하지 않기 때문에 UNION RESULT 라인이 없어지는 것을 확인할 수 있다.

```sql
mysql> explain select emp_no from salaries where salary > 100000
    -> union all
    -> select emp_no from dept_emp where from_date > '2001-01-01';

+----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
|  1 | PRIMARY     | salaries | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
|  2 | UNION       | dept_emp | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
+----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
```

### SUBQUERY

FROM 절 이외에서 사용되는 서브쿼리를 의미한다.  

```sql
mysql> explain
    -> select e.first_name,
    ->     (select count(*)
    ->      from dept_emp de, dept_manager dm
    ->      where dm.dept_no=de.dept_no) as cnt
    -> from employees e where e.emp_no=10001;

+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+-------+----------+-------------+
|  1 | PRIMARY     | e     | NULL       | const | PRIMARY       | PRIMARY | 4       | const                |     1 |   100.00 | NULL        |
|  2 | SUBQUERY    | dm    | NULL       | index | PRIMARY       | PRIMARY | 20      | NULL                 |    24 |   100.00 | Using index |
|  2 | SUBQUERY    | de    | NULL       | ref   | PRIMARY       | PRIMARY | 16      | employees.dm.dept_no | 41392 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+-------+----------+-------------+

-> Rows fetched before execution  (cost=0..0 rows=1) (actual time=82e-6..124e-6 rows=1 loops=1)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: count(0)  (cost=199906 rows=1) (actual time=240..240 rows=1 loops=1)
        -> Nested loop inner join  (cost=100563 rows=993429) (actual time=1.8..208 rows=897570 loops=1)
            -> Covering index scan on dm using PRIMARY  (cost=2.65 rows=24) (actual time=0.159..0.173 rows=24 loops=1)
            -> Covering index lookup on de using PRIMARY (dept_no=dm.dept_no)  (cost=223 rows=41393) (actual time=0.0242..6.81 rows=37399 loops=24)
```

FROM 절에 사용된 서브쿼리는 select_type이 DERIVED로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시된다.  

> **서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다.**  
> 1. **중첩된 쿼리(Nested Query)** : SELECT 되는 컬럼에 사용된 서브쿼리
> 2. **서브쿼리(Subquery)** : WHERE 절에 사용된 경우
> 3. **파생 테이블(Derived Table)** : FROM 절에 사용된 서브쿼리를 `파생 테이블`이라고 하며, RDBMS에서는 `인라인 뷰` 또는 `서브 셀렉트` 라고 부른다.
>
> **또한 서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분하기도 한다.**  
> 1. **스칼라 서브쿼리(Scalar Subquery)** : 하나의 값만(컬럼이 단 하나인 레코드 1건만) 반환하는 쿼리
> 2. **로우 서브쿼리(Row Subquery)** : 컬럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리

### DEPENDENT SUBQUERY

서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 컬럼을 사용하는 경우, DEPEDENT SUBQUERY 라고 표시된다.  

```sql
mysql> explain
    -> select e.first_name, e.last_name, e.emp_no,
    ->        (select count(*)
    ->         from dept_emp de, dept_manager dm
    ->         where dm.dept_no=de.dept_no and de.emp_no=e.emp_no) as cnt
    -> from employees e
    -> where e.first_name='Matt';

+----+--------------------+-------+------------+------+---------------------------+-------------------+---------+----------------------+------+----------+-------------+
| id | select_type        | table | partitions | type | possible_keys             | key               | key_len | ref                  | rows | filtered | Extra       |
+----+--------------------+-------+------------+------+---------------------------+-------------------+---------+----------------------+------+----------+-------------+
|  1 | PRIMARY            | e     | NULL       | ref  | ix_firstname              | ix_firstname      | 58      | const                |  233 |   100.00 | NULL        |
|  2 | DEPENDENT SUBQUERY | de    | NULL       | ref  | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | employees.e.emp_no   |    1 |   100.00 | Using index |
|  2 | DEPENDENT SUBQUERY | dm    | NULL       | ref  | PRIMARY                   | PRIMARY           | 16      | employees.de.dept_no |    2 |   100.00 | Using index |
+----+--------------------+-------+------------+------+---------------------------+-------------------+---------+----------------------+------+----------+-------------+
```

**이럴 때는 안쪽(Inner)의 서브쿼리 결과가 바깥쪽(Outer) SELECT 쿼리의 컬럼에 의존적이기 때문에 DEPENDENT라는 키워드가 붙는다.**  
**또한 DEPENDENT UNION과 같이 DEPENDENT SUBQUERY 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 (DEPENDENT 키워드가 없는) 일반 서브쿼리보다는 처리 속도가 느릴때가 많다.**  

### DERIVED

단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미하며 이 경우에 생성되는 임시 테이블을 **파생 테이블** 이라고도 한다.  
MySQL 5.5 버전까지는 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많았지만, MySQL 5.6 부터는 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.  

```sql
mysql> explain
    -> select *
    -> from (select de.emp_no from dept_emp de group by de.emp_no) tb,
    ->       employees e
    -> where e.emp_no=tb.emp_no;

+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
|  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
|  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
```

**가능하다면 DERVIED 형태의 실행 계획과 불필요한 서브쿼리는 조인으로 해결할 수 있도록 수정하는 것이 좋다.**  

### DEPENDENT DERVIED

MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 컬럼을 사용할 수가 없었는데, **래터럴 조인** 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 됐다.  
아래 쿼리는 래터럴 조인의 가장 대표적인 활용 예제로서, employees 테이블의 레코드 1건당 salaries 테이블의 레코드를 최근 순서대로 최대 2건까지만 가져와서 조인을 실행한다.  

```sql
mysql> explain
    -> select *
    -> from employees e LEFT JOIN LATERAL
    ->     (select *
    ->      from salaries s
    ->      where s.emp_no=e.emp_no
    ->      order by s.from_date DESC LIMIT 2) AS s2
    ->     on s2.emp_no=e.emp_no;

+----+-------------------+------------+------------+------+---------------+-------------+---------+--------------------+--------+----------+----------------------------+
| id | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref                | rows   | filtered | Extra                      |
+----+-------------------+------------+------------+------+---------------+-------------+---------+--------------------+--------+----------+----------------------------+
|  1 | PRIMARY           | e          | NULL       | ALL  | NULL          | NULL        | NULL    | NULL               | 299888 |   100.00 | Rematerialize (<derived2>) |
|  1 | PRIMARY           | <derived2> | NULL       | ref  | <auto_key0>   | <auto_key0> | 4       | employees.e.emp_no |      2 |   100.00 | NULL                       |
|  2 | DEPENDENT DERIVED | s          | NULL       | ref  | PRIMARY       | PRIMARY     | 4       | employees.e.emp_no |      9 |   100.00 | Using filesort             |
+----+-------------------+------------+------------+------+---------------+-------------+---------+--------------------+--------+----------+----------------------------+
```

LATERAL 키워드 없이 서브쿼리에서 외부 컬럼을 참조하면 오류가 발생한다.  
`DEPENDENT SUBQUERY` 키워드는 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.  

### UNREACHABLE SUBQUERY

하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.  
**그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.**  
이 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능이다.  
  
- SUBQUERY는 바깥쪽의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
- DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 컬럼의 값 단위로 캐시해두고 사용한다.

> select_type이 SUBQUERY인 경우와 UNREACHABLE SUBQUERY는 이 캐시를 사용할 수 있느냐 없느냐의 차이가 있다.  
> 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능할 수가 있는데, 그럴 경우에는 UNCACHEABLE SUBQUERY가 표시된다.  
> 1. 사용자 변수가 서브쿼리에 사용된 경우
> 2. NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
> 3. UUID나 RAND와 같이 결괏값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

### MATERIALIZED

주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.  

```sql
mysql> explain
    -> select *
    -> from employees e
    -> where e.emp_no in (select emp_no from salaries where salary between 100 and 1000);

+----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
| id | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
+----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
|  1 | SIMPLE       | <subquery2> | NULL       | ALL    | NULL              | NULL      | NULL    | NULL               | NULL |   100.00 | NULL                     |
|  1 | SIMPLE       | e           | NULL       | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no |    1 |   100.00 | NULL                     |
|  2 | MATERIALIZED | salaries    | NULL       | range  | PRIMARY,ix_salary | ix_salary | 4       | NULL               |    1 |   100.00 | Using where; Using index |
+----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
```

**서브쿼리의 내용을 임시 테이블로 구체화한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.**  
id값이 2인 레코드가 먼저 처리되어 임시 테이블로 구체화된 것을 알 수 있다.  

## `table` 컬럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.  
table 컬럼에 `<dervied N>`, `<union M,N>`과 같이 <>로 둘러싸인 이름이 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미하며 숫자는 단위 SELECT 쿼리의 id값을 지칭한다.  

## `partitions` 컬럼

파티션 생성 시 제약 사항으로 **파티션 키로 사용되는 컬럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야 한다.**  
파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 **파티션 프루닝** 이라고 한다.  

## `type` 컬럼

쿼리의 실행 계획에서 type 이후의 컬럼은 **MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.**  
인덱스를 사용해 레코드를 읽었는지, 아니면 풀 테이블 스캔으로 읽었는지 등을 확인할 수 있다.  
이 type 컬럼은 반드시 체크해야 할 중요한 정보다.  
  
`ALL`을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이며, `index_merge`를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다.  
  
아래의 3가지 접근 방법은 **WHERE 조건절에 사용하는 비교 연산다는 `동등 비교 연산자`여야 한다는 공통점이 있다.**  

1. **const** : 조인 순서와 관계없이 프라이머리 키나 유니크 키의 모든 컬럼에 대해 동등 조건으로 검색 **(반드시 1건의 레코드만 반환)**
2. **eq_ref** : 조인에서 첫 번째 읽은 테이블의 컬럼 값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색 **(두 번째 테이블은 반드시 1건의 레코드만 반환)**
3. **ref** : 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색 **(1건의 레코드만 반환된다는 보장이 없어도 됨)**

아래의 2가지 접근 방법은 `IN(subquery)` 형태의 기준으로 나뉜다.  
  
1. **unique_subquery** : `IN(subquery)` 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음
2. **index_subquery** : `IN(subquery)` 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음

### system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다.  
InnoDB 스토리지 엔진에서는 나타나지 않고 MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.  

### const

테이블의 레코드 건수와 관계없이 **쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 한다.**  
다른 DBMS에서는 이를 유니크 인덱스 스캔이라고도 표현한다.  

```sql
mysql> explain select * from employees where emp_no=10001;

+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
```

아래와 같이 **다중 컬럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용될 때는 const 접근 방법을 사용할 수 없다.**  
이 경우에는 실제 레코드가 1건만 저장돼 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문이다.  

```sql
mysql> explain select * from dept_emp where dept_no='d005';

+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

const는 옵티마이저가 쿼리 결과를 상수화시켜 실제로 쿼리가 실행될 때 인라인되도록 하는 것이다.  

### eq_ref

**여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시되며, 조인에서 처음 읽은 테이블의 컬럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리킨다.**  
또한 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL 이어야 하며, 다중 컬럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용돼야만 이 방법이 사용된다.  
즉, **조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.**  
  
```sql
mysql> explain
    -> select * from dept_emp de, employees e
    -> where e.emp_no=de.emp_no and de.dept_no='d005';

+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref                 | rows   | filtered | Extra |
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
|  1 | SIMPLE      | de    | NULL       | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const               | 165571 |   100.00 | NULL  |
|  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY                   | PRIMARY | 4       | employees.de.emp_no |      1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
```

### ref

eq_ref와 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다.  
**인덱스의 종류와 관계없이 동등 조건으로 검색할 때 이 방법이 사용된다.**  
이 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않지만 **동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.**  

```sql
mysql> explain
    -> select *
    -> from dept_emp
    -> where dept_no='d005';

+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

프라이머리 키를 구성하는 컬럼 중에서 일부인 dept_no만 동등 조건으로 검색했기 때문에 조건에 일치하는 레코드가 1건이라는 보장이 없기에 ref가 사용됐다.  
`ref` 컬럼 값에 const가 명시되어 있는데 이는 접근 방법이 아니라 **ref 접근 방법에서 값 비교에 사용된 입력 값이 상수 였음을 의미힌다.**  

### ref_or_null

ref 접근 방법과 같지만 NULL 비교가 추가된 형태다. 사용된다면 나쁘지 않은 접근 방법 정도로 기억하자.  

```sql
mysql> explain select * from titles where to_date='1985-03-01' OR to_date is null;

+----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
| id | select_type | table  | partitions | type        | possible_keys | key       | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | titles | NULL       | ref_or_null | ix_todate     | ix_todate | 4       | const |    2 |   100.00 | Using where; Using index |
+----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
```

### range

인덱스 레인지 스캔 형태의 접근 방법이며, 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다.  
주로 `<, >, IS NULL, BETWEEN, IN, LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.  
얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 이 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.  
  
### index_merge

이 방법은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.  
그렇게 효율적인 방법은 아니다.

1. 여러 인덱스를 읽어야 하므로 range 보다 효율이 떨어진다.
2. 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 사용되지 않는다.
3. 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

```sql
mysql> explain select * from employees
    -> where (emp_no between 10001 and 11000) or (first_name='Smith');

+----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table     | partitions | type        | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | employees | NULL       | index_merge | PRIMARY,ix_firstname | PRIMARY,ix_firstname | 4,58    | NULL | 1001 |   100.00 | Using union(PRIMARY,ix_firstname); Using where |
+----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
```

### index

이 접근 방법을 인덱스를 효율적으로 사용하는 줄 오해를 많이 하지만 이 방법은 **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미힌다.**  
range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아니라는 점을 명심해라.  
  
일반적으로 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 효율적이라 할 수 있긴하다.  
1번과 2번을 만족하거나 1번과 3번을 만족하는 경우 사용되는 방식이다.  
  
1. range나 const,ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
2. 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)
3. 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)

## `possible_keys` 컬럼

옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다.  
이 컬럼에 있는 내용은 **옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이며 사용될법 했던 인덱스의 목록이다.**  
그냥 무시해도 된다.

## `key` 컬럼

최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.  

## `key_len` 컬럼

이 컬럼 정보는 매우 중요한 정보이며, **쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 알려주는 정보다.**  
즉, 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.  

```sql
mysql> explain select * from dept_emp where dept_no='d005';

+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

`dept_no   char(4)`이기 때문에 컬럼의 값이 16으로 표시된 것이다.  


```sql
mysql> explain select * from dept_emp where dept_no='d005' and emp_no=10001;

+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
```

`emp_no    int` INTEGER 타입은 4바이트를 차지하기 때문에 20으로 표시된 것이다.

## `ref` 컬럼

참조 조건으로 어떤 값이 제공됐는지 보여준다. 상숫값을 지정했다면 ref 컬럼의 값은 const로 표시되고, 다른 테이블의 컬럼값이면 그 테이블명과 컬럼명이 표시된다.  
`func`가 출력되면 **문자 집합이 일치하지 않는 두 문자열 컬럼을 조인한다거나 숫자 타입의 컬럼과 문자열 타입의 컬럼으로 조인하는지 확인이 필요하다.**  

## `rows` 컬럼

실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여주며 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.  
**반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미힌다.**  

## `filtered` 컬럼

**필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.**  

## `Extra` 컬럼