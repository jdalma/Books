# 메모

1. id 컬럼의 숫자는 쿼리 실행 순서가 아니며 단순한 식별자 값이다.
   1. 만약 id 컬럼의 숫자가 같다면 먼저 출력된 레코드가 드라이빙 테이블이다.
2. UNION ALL은 임시 테이블을 사용하지 않도록 개선됐지만, UNION은 여전히 임시 테이블을 사용한다..
3. `=` 연산자와 `<=>` 연산자의 차이점
4. `인덱스 레인지 스캔` 또는 `레인지 스캔` 이라고 하면 const, ref, range 라는 세 가지 접근 방법을 모두 묶어서 지칭하는 것임을 기억하라
   1. 이 세 가지를 꼭 구분하진 않는다.
5. `EXPLAIN FOR CONNECTION {id}` 명령어로 다른 커넥션에서 실행 중인 쿼리의 실행계획을 확인할 수 있다.
6. MySQL 8.0 부터는 **루스 인덱스 스캔 최적화를 확장한 인덱스 스킵 스캔 최적화가 도입됐다.**

# 통계 정보

MySQL 서버는 5.7 버전까지 테이블과 인덱스에 대한 개괄적인 정보를 가지고 실행 계획을 수립했기에 실행 계획의 정확도가 떨어지는 경우가 많았다.  
**MySQL 8.0 버전부터는 인덱스되지 않은 컬럼들에 대해서도 데이터 분포도를 수집해서 저장하는 히스토그램 정보가 도입됐다.**  
그렇다고해서 테이블 및 인덱스의 통계 정보가 필요치 않은 것은 아니다.

테이블 및 인덱스에 대한 통계 정보와 히스토그램을 나누어 확인해보자.

## 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 통계 정보다.  
**MySQL 5.6 버전 부터는 InnoDB 스토리지 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선됐다.**  
각 테이블의 통계 정보를 `innodb_index_stats` 테이블과 `innodb_table_stats` 테이블로 관리할 수 있게 되면서 서버가 재시작돼도 기존의 통계 정보를 유지할 수 있게 됐다.

```sql
mysql> select * from mysql.innodb_index_stats where database_name='employees' and table_name='salaries';

+---------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+
| database_name | table_name | index_name | last_update         | stat_name    | stat_value | sample_size | stat_description                  |
+---------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | n_diff_pfx01 |     307242 |          20 | emp_no                            |
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | n_diff_pfx02 |    2838426 |          20 | emp_no,from_date                  |
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | n_leaf_pages |       6078 |        NULL | Number of leaf pages in the index |
| employees     | salaries   | PRIMARY    | 2024-03-19 14:24:23 | size         |       6120 |        NULL | Number of pages in the index      |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_diff_pfx01 |      97450 |          20 | salary                            |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_diff_pfx02 |    2821563 |          20 | salary,emp_no                     |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_diff_pfx03 |    2950846 |          20 | salary,emp_no,from_date           |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | n_leaf_pages |       4157 |        NULL | Number of leaf pages in the index |
| employees     | salaries   | ix_salary  | 2024-03-19 14:24:23 | size         |       4777 |        NULL | Number of pages in the index      |
+---------------+------------+------------+---------------------+--------------+------------+-------------+-----------------------------------+

mysql> select * from mysql.innodb_table_stats where database_name='employees' and table_name='salaries';

+---------------+------------+---------------------+---------+----------------------+--------------------------+
| database_name | table_name | last_update         | n_rows  | clustered_index_size | sum_of_other_index_sizes |
+---------------+------------+---------------------+---------+----------------------+--------------------------+
| employees     | salaries   | 2024-03-19 14:24:23 | 2838426 |                 6120 |                     4777 |
+---------------+------------+---------------------+---------+----------------------+--------------------------+
```

1. **innodb_index_stats.stat_name**
   1. `n_diff_pfx%` : 인덱스가 가진 유니크한 값의 개수
   2. `n_leaf_pages` : 인덱스의 리프 노드 페이지 개수
   3. `size` : 인덱스 트리의 전체 페이지 개수

## 히스토그램

MySQL 5.7 버전까지의 통계 정보는 단순히 인덱스된 컬럼의 유니크한 값의 개수 정도만 가지고 있었는데, 이는 옵티마이저가 최적의 실행 계획을 수립하기에는 많이 부족했다.  
8.0 버전으로 업그레이드 되면서 **컬럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용할 수 있게 됐다.**

히스토그램 정보는 **컬럼 단위로 관리되는데, 자동으로 수집되지 않고 `ANALYZE TABLE .. UPDATE HISTOGRAM` 명령을 실행해 수동으로 수집 및 관리된다.**  
수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장되고, MySQL 서버가 시작될 때 딕셔너리의 히스토그램 정보를 `information_schema.column_statistics` 테이블로 로드한다.

```sql
mysql> analyze table employees.employees update histogram on gender, hire_date;

+---------------------+-----------+----------+------------------------------------------------------+
| Table               | Op        | Msg_type | Msg_text                                             |
+---------------------+-----------+----------+------------------------------------------------------+
| employees.employees | histogram | status   | Histogram statistics created for column 'gender'.    |
| employees.employees | histogram | status   | Histogram statistics created for column 'hire_date'. |
+---------------------+-----------+----------+------------------------------------------------------+

mysql> select * from information_schema.COLUMN_STATISTICS where schema_name='employees' and table_name='employees'\G

*************************** 1. row ***************************
SCHEMA_NAME: employees
 TABLE_NAME: employees
COLUMN_NAME: gender
  HISTOGRAM: {
    "buckets": [[1, 0.5992564987177832], [2, 1.0]],
    "data-type": "enum",
    "null-values": 0.0,
    "collation-id": 45,
    "last-updated": "2024-03-24 14:04:47.827784",
    "sampling-rate": 0.34735190026498786,
    "histogram-type": "singleton",
    "number-of-buckets-specified": 100
  }
*************************** 2. row ***************************
SCHEMA_NAME: employees
 TABLE_NAME: employees
COLUMN_NAME: hire_date
  HISTOGRAM: {
    "buckets": [["1985-01-01", "1985-02-28", 0.0098334040551261, 31], ["1985-03-01", "1985-03-27", 0.019897422651882737, 27], ... ["1998-09-15", "2000-01-28", 1.0, 442]], 
    "data-type": "date", 
    "null-values": 0.0, 
    "collation-id": 8, 
    "last-updated": "2024-03-24 14:04:47.834205", 
    "sampling-rate": 0.34735190026498786,   -- 히스토그램 정보를 수집하기 위해 스캔한 페이지의 비율, 34%
    "histogram-type": "equi-height", 
    "number-of-buckets-specified": 100      -- 히스토그램을 생성할 때 설정했던 버킷의 개수, 기본으로 100개의 버킷이 사용됨
  }
```

- `Singleton` 히스토그램 : 컬럼값 개별로 레코드 건수를 관리하는 히스토그램
  - 각 버킷이 `컬럼의 값`과 `발생 빈도의 비율` 이 2개의 값을 가진다.
- `Equi-Height` 히스토그램 : 컬럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램
  - 각 버킷이 `범위의 시작 값`과 `마지막 값`, 그리고 `발생 빈도율`과 각 버킷에 포함된 `유니크한 값의 개수` 4개의 값을 가진다.
  
**히스토그램은 버킷 단위로 구분되어 레코드 건수나 컬럼값의 범위가 관리되는데, 싱글톤 히스토그램은 컬럼이 가지는 값별로 버킷이 할당되며 높이 균형 히스토그램에서는 개수가 균등한 컬럼값의 범위별로 하나의 버킷이 할당된다.**  

> 히스토그램은 특정 컬럼이 가지는 모든 값에 대한 분포도 정보를 가지지는 않지만 각 범위(버킷)별로 레코드의 건수와 유니크한 값의 개수 정보를 가지기 때문에 훨씬 정확한 예측을 할 수 있다.  
> 히스토그램 정보가 없다면 옵티마이저는 데이터가 균등하게 분포돼 있을 것으로 예측하기에 히스토그램이 있으면 특정 범위의 데이터가 많고 적음을 식별할 수 있다.  

## 히스토그램과 인덱스

히스토그램과 인덱스는 완전히 다른 객체이기 때문에 서로 비교할 대상은 아니지만, MySQL 서버에서 인덱스는 부족한 통계 정보를 수집하기 위해 사용된다는 측면에서 어느 정도 공통점을 가진다고 볼 수 있다.  
쿼리의 실행 계획을 수립할 때 사용 가능한 인덱스들로부터 조건절에 일치하는 레코드 건수를 대략 파악하고 최종적으로 가장 나은 실행 계획을 선택한다.  
**이때 조건절에 일치하는 레코드 건수를 예측하기 위해 옵티마이저는 실제 인덱스의 B-Tree를 샘플링해서 살펴보며 이 작업을 `인덱스 다이브`라고 표현한다.**  
  
조건절에 인덱스에 사용된 컬럼이 명시된다면 실제 인덱스 다이브를 통해 직접 수집한 정보를 활용한다.  

## 코스트 모델

MySQL 서버가 쿼리를 처리하려면 아래와 같은 다양한 작업을 필요로 한다.

1. 디스크로부터 데이터 페이지 읽기
2. 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
3. 인덱스 키 비교
4. 레코드 평가
5. 메모리 임시 테이블 작업
6. 디스크 임시 테이블 작업

사용자의 쿼리에 대해 이러한 다양한 작업이 얼마나 필요한지 예측하고 전체 작업 비용을 계산한 결과를 바탕으로 최적의 실행 계획을 찾는다.  
**이렇게 전체 쿼리의 비용을 계산하는데 필요한 단위 작업들의 비용을 `코스트 모델`이라고 한다.**  
  
MySQL 서버 8.0의 코스트 모델은 아래 2개의 테이블에 저장돼 있는 설정 값을 사용하며, 모두 MySQL DB에 존재한다.  

- `server_cost` : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- `engine_cost` : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리

# 실행 계획 확인

`DESC` 또는 `EXPLAIN` 명령으로 확인할 수 있다.  
쿼리의 실행 계획과 단계별 소요된 시간 정보를 확인할 수 있는 `EXPLAIN ANALYZE` 기능이 추가됐다.  

```sql
mysql> explain analyze
    -> select e.emp_no, avg(s.salary)
    -> from employees e inner join salaries s
    ->     on e.emp_no = s.emp_no and
    ->        s.salary > 50000 and
    ->        s.from_date <= '1990-01-01' and
    ->        s.to_date > '1990-01-01'
    -> where e.first_name = 'Matt'
    -> group by e.emp_no\G

*************************** 1. row ***************************
EXPLAIN: -> Group aggregate: avg(s.salary)  (cost=474 rows=120) (actual time=0.246..3.32 rows=48 loops=1)
    -> Nested loop inner join  (cost=462 rows=120) (actual time=0.168..3.27 rows=48 loops=1)
        -> Covering index lookup on e using ix_firstname (first_name='Matt')  (cost=26 rows=233) (actual time=0.124..0.217 rows=233 loops=1)
        -> Filter: ((s.salary > 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))  (cost=0.947 rows=0.513) (actual time=0.0116..0.0129 rows=0.206 loops=233)
            -> Index lookup on s using PRIMARY (emp_no=e.emp_no)  (cost=0.947 rows=9.24) (actual time=0.00841..0.0111 rows=9.53 loops=233)
```

- **들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행**
- **들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행**
  
1. **커버링 인덱스 조회 (Covering index lookup)**
   - ix_firstname 인덱스를 사용하여 e 테이블에서 first_name='Matt' 조건을 만족하는 행을 찾습니다.
   - 비용은 26이고, 예상 행 수는 233개입니다. 실제 시간은 0.124초에서 0.217초 사이이며, 실제로 233개의 행을 찾았습니다.
   - 이 단계는 쿼리의 시작점으로, 특정 이름을 가진 직원들을 빠르게 찾기 위해 인덱스를 사용합니다.
2. **인덱스 조회 (Index lookup)**
   - 이 단계는 각 직원 번호(emp_no)에 대해 salary 정보를 조회하는 내용에 대한 설명이다.
   - PRIMARY 인덱스를 사용하여 s 테이블에서 emp_no=e.emp_no 조건을 만족하는 행을 찾습니다.
   - 비용은 0.947이며, 예상 행 수는 9.24개입니다. 실제 시간은 각 루프에서 0.00841초에서 0.0111초 사이이며, 평균적으로 9.53개의 행을 찾았습니다.
3. **필터 (Filter)**
   - 조회된 s 테이블의 행에 대해 조건 ((s.salary > 50000) and (s.from_date <= DATE'1990-01-01') and (s.to_date > DATE'1990-01-01'))를 적용합니다.
   - 비용은 0.947이며, 예상적으로 0.513개의 행이 조건을 만족할 것으로 보입니다. 실제 처리 시간은 각 루프에서 0.0116초에서 0.0129초 사이이며, 평균적으로 0.206개의 행이 조건을 만족합니다.
   - 이 단계는 급여 정보가 특정 조건을 만족하는지 필터링합니다.
4. **중첩 루프 내부 조인 (Nested loop inner join)**
   - 앞서의 두 단계를 통해 얻은 결과를 조인합니다.
   - 비용은 462이며, 예상 행 수는 120개입니다. 실제 시간은 0.168초에서 3.27초 사이이며, 48개의 행이 결과로 나왔습니다.
   - 이 단계에서는 첫 번째 단계에서 찾은 직원들과 세 번째 단계에서 필터링한 급여 정보를 조인합니다.
5. **그룹 집계 (Group aggregate)**
   - 조인된 결과에 대해 avg(s.salary)를 계산합니다.
   - 비용은 474이며, 예상 행 수는 120개입니다. 실제 처리 시간은 0.246초에서 3.32초 사이이며, 최종적으로 48개의 그룹이 생성됩니다.
   - 이 단계는 최종 결과인 각 그룹에 대한 평균 급여를 계산합니다.
  
# 실행 계획 분석 ⭐️

실행 계획의 각 라인은 쿼리 문장에서 사용된 테이블(서브쿼리로 임시 테이블을 생성한 경우 그 임시 테이블까지 포함)의 개수만큼 출력된다.  
일반적으로 실행 순서는 위에서 아래로 표시되며, UNION이나 상관 서브 쿼리와 같은 경우 순서대로 표시되지 않을 수 있다.  

## `id` 컬럼

`id` 컬럼은 단위 SELECT 쿼리별로 부여되는 식별자 값이다. 조인같은 경우에는 같은 `id` 값이 부여될 수 있다.  


```sql
explain
SELECT e.emp_no, e.first_name, s.from_date, s.salary
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no LIMIT 10;

+----+-------------+-------+------------+-------+---------------+--------------+---------+--------------------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref                | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+--------------+---------+--------------------+--------+----------+-------------+
|  1 | SIMPLE      | e     | NULL       | index | PRIMARY       | ix_firstname | 58      | NULL               | 299888 |   100.00 | Using index |
|  1 | SIMPLE      | s     | NULL       | ref   | PRIMARY       | PRIMARY      | 4       | employees.e.emp_no |      9 |   100.00 | NULL        |
+----+-------------+-------+------------+-------+---------------+--------------+---------+--------------------+--------+----------+-------------+


explain select (
    (select count(*) from employees) + (select count(*) from departments)
) as TOTAL;

+----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
| id | select_type | table       | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
|  1 | PRIMARY     | NULL        | NULL       | NULL  | NULL          | NULL        | NULL    | NULL |   NULL |     NULL | No tables used |
|  3 | SUBQUERY    | departments | NULL       | index | NULL          | ux_deptname | 162     | NULL |      9 |   100.00 | Using index    |
|  2 | SUBQUERY    | employees   | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index    |
+----+-------------+-------------+------------+-------+---------------+-------------+---------+------+--------+----------+----------------+
```

**한 가지 주의해야할 것은 id컬럼이 테이블의 접근 순서를 의미하지는 않는다는 것이다.**  

```sql
select *
from dept_emp de
where de.emp_no = (
    select e.emp_no
    from employees e
    where e.first_name = 'Georgi' and
          e.last_name = 'Facello'
    LIMIT 1
)

-- 테이블 형식 실행 계획
+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys     | key               | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | de    | NULL       | ref  | ix_empno_fromdate | ix_empno_fromdate | 4       | const |    1 |   100.00 | NULL        |
|  2 | SUBQUERY    | e     | NULL       | ref  | ix_firstname      | ix_firstname      | 58      | const |  253 |    10.00 | Using where |
+----+-------------+-------+------------+------+-------------------+-------------------+---------+-------+------+----------+-------------+
```

위의 테이블 형식 실행 계획의 `id`값을 보면 `dept_emp` 테이블을 먼저 읽고 `employees`를 읽은것으로 생각할 수 있지만, 트리 형식의 실행 계획으로 확인하면 순서를 더 정확히 알 수 있다.  

```sql
+-----------------------------------------------------------------------------------------+
| EXPLAIN                                                                                 |
+-----------------------------------------------------------------------------------------+
| -> Index lookup on de using ix_empno_fromdate (emp_no=(select #2))  (cost=1.09 rows=1)  |
+-----------------------------------------------------------------------------------------+
```

`select #2` 라고 된 부분이 `id`값이 2인 employees 테이블이다. employees 테이블이 가장 먼저 조회되고, 그 결과를 이용해 dept_emp 테이블을 조회했다고 볼 수 있다.  

## `select_type` 컬럼

**각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다.**  

### SIMPLE

UNION이나 서브쿼리를 사용하지 않는 **단순한 SELECT 쿼리인 경우 해당 쿼리 문장이 SIMPLE로 표시된다.**  
(쿼리에 조인이 포함된 경우에도 마찬가지다.)  
**쿼리 문장이 아무리 복잡하더라도 실행 계획에서 SIMPLE인 단위 쿼리는 하나만 존재한다.**  
일반적으로 제일 바깥 쿼리가 SIMPLE이다.  

### PRIMARY

**UNION이나 서브쿼리를 가지는 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리가 PRIMARY로 표시된다.**  
이 타입도 하나만 존재하며, 제일 바깥쪽에 있는 쿼리가 PRIMARY로 표시된다.  

### UNION

**UNION으로 결합하는 단위 SELECT 쿼리 중 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리가 UNION으로 표시된다.**  
UNION의 첫 번째 단위 SELECT는 UNION되는 쿼리 결과들을 모아서 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.  

```sql
select * from (
    (select e1.emp_no from employees e1 LIMIT 10) UNION ALL
    (select e2.emp_no from employees e2 LIMIT 10) UNION ALL
    (select e3.emp_no from employees e3 LIMIT 10)
) tb;

+----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
| id | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL   | NULL          | NULL        | NULL    | NULL |     30 |   100.00 | NULL        |
|  2 | DERIVED     | e1         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index |
|  3 | UNION       | e2         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index |
|  4 | UNION       | e3         | NULL       | index | NULL          | ix_hiredate | 3       | NULL | 299888 |   100.00 | Using index |
+----+-------------+------------+------------+-------+---------------+-------------+---------+------+--------+----------+-------------+
```

세 개의 서브쿼리로 조회된 결과를 UNION ALL로 결합해 임시 테이블을 만들어서 사용하고 있으므로 DERIVED라는 타입을 갖는 것이다.

### DEPENDENT UNION

**UNION이나 UNION ALL로 집합을 결합하는 쿼리에서 표시되며 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미한다.**  

```sql
explain select * from employees e1
where e1.emp_no in (
    select e2.emp_no from employees e2 where e2.first_name='Matt'
    union
    select e3.emp_no from employees e3 where e3.last_name='Matt'
);

+----+--------------------+------------+------------+--------+----------------------+---------+---------+------+--------+----------+-----------------+
| id | select_type        | table      | partitions | type   | possible_keys        | key     | key_len | ref  | rows   | filtered | Extra           |
+----+--------------------+------------+------------+--------+----------------------+---------+---------+------+--------+----------+-----------------+
|  1 | PRIMARY            | e1         | NULL       | ALL    | NULL                 | NULL    | NULL    | NULL | 299888 |   100.00 | Using where     |
|  2 | DEPENDENT SUBQUERY | e2         | NULL       | eq_ref | PRIMARY,ix_firstname | PRIMARY | 4       | func |      1 |     5.00 | Using where     |
|  3 | DEPENDENT UNION    | e3         | NULL       | eq_ref | PRIMARY              | PRIMARY | 4       | func |      1 |    10.00 | Using where     |
|  4 | UNION RESULT       | <union2,3> | NULL       | ALL    | NULL                 | NULL    | NULL    | NULL |   NULL |     NULL | Using temporary |
+----+--------------------+------------+------------+--------+----------------------+---------+---------+------+--------+----------+-----------------+
```

위의 예제 쿼리를 보면 두 개의 SELECT 쿼리가 UNION으로 결합됐으므로 `select_type`이 UNION으로 표시된 것을 볼 수 있다.  
이 경우 **IN 내부의 서브쿼리를 먼저 처리하지 않고, 외부의 employees 테이블을 먼저 읽은 다음 서브쿼리를 실행하는데 이때 employees 테이블의 컬럼값이 서브쿼리에 영향을 준다.**  
이렇게 내부 쿼리가 외부의 값을 참조해서 처리될 때 DEPENDENT 키워드가 표시된다.  
  
결국 내부적으로는 UNION에 사용된 SELECT 쿼리의 WHERE 조건에 `"e2.emp_no=e1.emp_no"`와 `"e3.emp_no=e1.emp_no"`라는 조건이 자동으로 추가되어 실행된다.  
외부에 정의된 employees 테이블의 emp_no 컬럼이 서브쿼리에 사용되기 때문에 DEPENDENT UNION이 select_type에 표시된 것이다.  

### UNION RESULT

**UNION 결과를 담아두는 테이블을 의미한다.** MySQL 8.0 버전부터는 UNION ALL의 경우 임시 테이블을 사용하지 않도록 기능이 개선됐다.  
(하지만 UNION은 여전히 임시 테이블에 결과를 버퍼링한다.)  

```sql
mysql> explain select emp_no from salaries where salary > 100000
    -> union distinct
    -> select emp_no from dept_emp where from_date > '2001-01-01';

+----+--------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
| id | select_type  | table      | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
+----+--------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
|  1 | PRIMARY      | salaries   | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
|  2 | UNION        | dept_emp   | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
|  3 | UNION RESULT | <union1,2> | NULL       | ALL   | NULL                          | NULL        | NULL    | NULL |   NULL |     NULL | Using temporary          |
+----+--------------+------------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
```

**UNION RESULT 라인의 table 컬럼은 `<union1,2>`로 표시돼 있는데, 이것이 id값이 1인 단위 쿼리와 2인 단위 쿼리의 조회 결과를 UNION 했다는 것을 의미한다.**  
위의 예제를 UNION ALL로 변경하면 임시 테이블에 버퍼링하지 않기 때문에 UNION RESULT 라인이 없어지는 것을 확인할 수 있다.

```sql
mysql> explain select emp_no from salaries where salary > 100000
    -> union all
    -> select emp_no from dept_emp where from_date > '2001-01-01';

+----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys                 | key         | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
|  1 | PRIMARY     | salaries | NULL       | range | ix_salary                     | ix_salary   | 4       | NULL | 188518 |   100.00 | Using where; Using index |
|  2 | UNION       | dept_emp | NULL       | range | ix_fromdate,ix_empno_fromdate | ix_fromdate | 3       | NULL |   5325 |   100.00 | Using where; Using index |
+----+-------------+----------+------------+-------+-------------------------------+-------------+---------+------+--------+----------+--------------------------+
```

### SUBQUERY

FROM 절 이외에서 사용되는 서브쿼리를 의미한다.  

```sql
mysql> explain
    -> select e.first_name,
    ->     (select count(*)
    ->      from dept_emp de, dept_manager dm
    ->      where dm.dept_no=de.dept_no) as cnt
    -> from employees e where e.emp_no=10001;

+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+-------+----------+-------------+
|  1 | PRIMARY     | e     | NULL       | const | PRIMARY       | PRIMARY | 4       | const                |     1 |   100.00 | NULL        |
|  2 | SUBQUERY    | dm    | NULL       | index | PRIMARY       | PRIMARY | 20      | NULL                 |    24 |   100.00 | Using index |
|  2 | SUBQUERY    | de    | NULL       | ref   | PRIMARY       | PRIMARY | 16      | employees.dm.dept_no | 41392 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+-------+----------+-------------+

-> Rows fetched before execution  (cost=0..0 rows=1) (actual time=82e-6..124e-6 rows=1 loops=1)
-> Select #2 (subquery in projection; run only once)
    -> Aggregate: count(0)  (cost=199906 rows=1) (actual time=240..240 rows=1 loops=1)
        -> Nested loop inner join  (cost=100563 rows=993429) (actual time=1.8..208 rows=897570 loops=1)
            -> Covering index scan on dm using PRIMARY  (cost=2.65 rows=24) (actual time=0.159..0.173 rows=24 loops=1)
            -> Covering index lookup on de using PRIMARY (dept_no=dm.dept_no)  (cost=223 rows=41393) (actual time=0.0242..6.81 rows=37399 loops=24)
```

FROM 절에 사용된 서브쿼리는 select_type이 DERIVED로 표시되고, 그 밖의 위치에서 사용된 서브쿼리는 전부 SUBQUERY라고 표시된다.  

> **서브쿼리는 사용하는 위치에 따라 각각 다른 이름을 지니고 있다.**  
> 1. **중첩된 쿼리(Nested Query)** : SELECT 되는 컬럼에 사용된 서브쿼리
> 2. **서브쿼리(Subquery)** : WHERE 절에 사용된 경우
> 3. **파생 테이블(Derived Table)** : FROM 절에 사용된 서브쿼리를 `파생 테이블`이라고 하며, RDBMS에서는 `인라인 뷰` 또는 `서브 셀렉트` 라고 부른다.
>
> **또한 서브쿼리가 반환하는 값의 특성에 따라 다음과 같이 구분하기도 한다.**  
> 1. **스칼라 서브쿼리(Scalar Subquery)** : 하나의 값만(컬럼이 단 하나인 레코드 1건만) 반환하는 쿼리
> 2. **로우 서브쿼리(Row Subquery)** : 컬럼의 개수와 관계없이 하나의 레코드만 반환하는 쿼리

### DEPENDENT SUBQUERY

서브쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 컬럼을 사용하는 경우, DEPEDENT SUBQUERY 라고 표시된다.  

```sql
mysql> explain
    -> select e.first_name, e.last_name, e.emp_no,
    ->        (select count(*)
    ->         from dept_emp de, dept_manager dm
    ->         where dm.dept_no=de.dept_no and de.emp_no=e.emp_no) as cnt
    -> from employees e
    -> where e.first_name='Matt';

+----+--------------------+-------+------------+------+---------------------------+-------------------+---------+----------------------+------+----------+-------------+
| id | select_type        | table | partitions | type | possible_keys             | key               | key_len | ref                  | rows | filtered | Extra       |
+----+--------------------+-------+------------+------+---------------------------+-------------------+---------+----------------------+------+----------+-------------+
|  1 | PRIMARY            | e     | NULL       | ref  | ix_firstname              | ix_firstname      | 58      | const                |  233 |   100.00 | NULL        |
|  2 | DEPENDENT SUBQUERY | de    | NULL       | ref  | PRIMARY,ix_empno_fromdate | ix_empno_fromdate | 4       | employees.e.emp_no   |    1 |   100.00 | Using index |
|  2 | DEPENDENT SUBQUERY | dm    | NULL       | ref  | PRIMARY                   | PRIMARY           | 16      | employees.de.dept_no |    2 |   100.00 | Using index |
+----+--------------------+-------+------------+------+---------------------------+-------------------+---------+----------------------+------+----------+-------------+
```

**이럴 때는 안쪽(Inner)의 서브쿼리 결과가 바깥쪽(Outer) SELECT 쿼리의 컬럼에 의존적이기 때문에 DEPENDENT라는 키워드가 붙는다.**  
**또한 DEPENDENT UNION과 같이 DEPENDENT SUBQUERY 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리가 실행돼야 하므로 (DEPENDENT 키워드가 없는) 일반 서브쿼리보다는 처리 속도가 느릴때가 많다.**  

### DERIVED

단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미하며 이 경우에 생성되는 임시 테이블을 **파생 테이블** 이라고도 한다.  
MySQL 5.5 버전까지는 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많았지만, MySQL 5.6 부터는 쿼리의 특성에 맞게 임시 테이블에도 인덱스를 추가해서 만들 수 있게 최적화됐다.  

```sql
mysql> explain
    -> select *
    -> from (select de.emp_no from dept_emp de group by de.emp_no) tb,
    ->       employees e
    -> where e.emp_no=tb.emp_no;

+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys                         | key               | key_len | ref       | rows   | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | ALL    | NULL                                  | NULL              | NULL    | NULL      | 331143 |   100.00 | NULL        |
|  1 | PRIMARY     | e          | NULL       | eq_ref | PRIMARY                               | PRIMARY           | 4       | tb.emp_no |      1 |   100.00 | NULL        |
|  2 | DERIVED     | de         | NULL       | index  | PRIMARY,ix_fromdate,ix_empno_fromdate | ix_empno_fromdate | 7       | NULL      | 331143 |   100.00 | Using index |
+----+-------------+------------+------------+--------+---------------------------------------+-------------------+---------+-----------+--------+----------+-------------+
```

**가능하다면 DERVIED 형태의 실행 계획과 불필요한 서브쿼리는 조인으로 해결할 수 있도록 수정하는 것이 좋다.**  

### DEPENDENT DERVIED

MySQL 8.0 이전 버전에서는 FROM 절의 서브쿼리는 외부 컬럼을 사용할 수가 없었는데, **래터럴 조인** 기능이 추가되면서 FROM 절의 서브쿼리에서도 외부 컬럼을 참조할 수 있게 됐다.  
아래 쿼리는 래터럴 조인의 가장 대표적인 활용 예제로서, employees 테이블의 레코드 1건당 salaries 테이블의 레코드를 최근 순서대로 최대 2건까지만 가져와서 조인을 실행한다.  

```sql
mysql> explain
    -> select *
    -> from employees e LEFT JOIN LATERAL
    ->     (select *
    ->      from salaries s
    ->      where s.emp_no=e.emp_no
    ->      order by s.from_date DESC LIMIT 2) AS s2
    ->     on s2.emp_no=e.emp_no;

+----+-------------------+------------+------------+------+---------------+-------------+---------+--------------------+--------+----------+----------------------------+
| id | select_type       | table      | partitions | type | possible_keys | key         | key_len | ref                | rows   | filtered | Extra                      |
+----+-------------------+------------+------------+------+---------------+-------------+---------+--------------------+--------+----------+----------------------------+
|  1 | PRIMARY           | e          | NULL       | ALL  | NULL          | NULL        | NULL    | NULL               | 299888 |   100.00 | Rematerialize (<derived2>) |
|  1 | PRIMARY           | <derived2> | NULL       | ref  | <auto_key0>   | <auto_key0> | 4       | employees.e.emp_no |      2 |   100.00 | NULL                       |
|  2 | DEPENDENT DERIVED | s          | NULL       | ref  | PRIMARY       | PRIMARY     | 4       | employees.e.emp_no |      9 |   100.00 | Using filesort             |
+----+-------------------+------------+------------+------+---------------+-------------+---------+--------------------+--------+----------+----------------------------+
```

LATERAL 키워드 없이 서브쿼리에서 외부 컬럼을 참조하면 오류가 발생한다.  
`DEPENDENT SUBQUERY` 키워드는 해당 테이블이 래터럴 조인으로 사용된 것을 의미한다.  

### UNREACHABLE SUBQUERY

하나의 쿼리 문장에 서브쿼리가 하나만 있더라도 실제 그 서브쿼리가 한 번만 실행되는 것은 아니다.  
**그런데 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 서브쿼리의 결과를 내부적인 캐시 공간에 담아둔다.**  
이 서브쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능이다.  
  
- SUBQUERY는 바깥쪽의 영향을 받지 않으므로 처음 한 번만 실행해서 그 결과를 캐시하고 필요할 때 캐시된 결과를 이용한다.
- DEPENDENT SUBQUERY는 의존하는 바깥쪽 쿼리의 컬럼의 값 단위로 캐시해두고 사용한다.

> select_type이 SUBQUERY인 경우와 UNREACHABLE SUBQUERY는 이 캐시를 사용할 수 있느냐 없느냐의 차이가 있다.  
> 서브쿼리에 포함된 요소에 의해 캐시 자체가 불가능할 수가 있는데, 그럴 경우에는 UNCACHEABLE SUBQUERY가 표시된다.  
> 1. 사용자 변수가 서브쿼리에 사용된 경우
> 2. NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
> 3. UUID나 RAND와 같이 결괏값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용된 경우

### MATERIALIZED

주로 FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.  

```sql
mysql> explain
    -> select *
    -> from employees e
    -> where e.emp_no in (select emp_no from salaries where salary between 100 and 1000);

+----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
| id | select_type  | table       | partitions | type   | possible_keys     | key       | key_len | ref                | rows | filtered | Extra                    |
+----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
|  1 | SIMPLE       | <subquery2> | NULL       | ALL    | NULL              | NULL      | NULL    | NULL               | NULL |   100.00 | NULL                     |
|  1 | SIMPLE       | e           | NULL       | eq_ref | PRIMARY           | PRIMARY   | 4       | <subquery2>.emp_no |    1 |   100.00 | NULL                     |
|  2 | MATERIALIZED | salaries    | NULL       | range  | PRIMARY,ix_salary | ix_salary | 4       | NULL               |    1 |   100.00 | Using where; Using index |
+----+--------------+-------------+------------+--------+-------------------+-----------+---------+--------------------+------+----------+--------------------------+
```

**서브쿼리의 내용을 임시 테이블로 구체화한 후, 임시 테이블과 employees 테이블을 조인하는 형태로 최적화되어 처리된다.**  
id값이 2인 레코드가 먼저 처리되어 임시 테이블로 구체화된 것을 알 수 있다.  

## `table` 컬럼

MySQL 서버의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다. 테이블의 이름에 별칭이 부여된 경우에는 별칭이 표시된다.  
table 컬럼에 `<dervied N>`, `<union M,N>`과 같이 <>로 둘러싸인 이름이 명시되는 경우가 많은데, 이 테이블은 임시 테이블을 의미하며 숫자는 단위 SELECT 쿼리의 id값을 지칭한다.  

## `partitions` 컬럼

파티션 생성 시 제약 사항으로 **파티션 키로 사용되는 컬럼은 프라이머리 키를 포함한 모든 유니크 인덱스의 일부여야 한다.**  
파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 **파티션 프루닝** 이라고 한다.  

## `type` 컬럼

쿼리의 실행 계획에서 type 이후의 컬럼은 **MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다.**  
인덱스를 사용해 레코드를 읽었는지, 아니면 풀 테이블 스캔으로 읽었는지 등을 확인할 수 있다.  
이 type 컬럼은 반드시 체크해야 할 중요한 정보다.  
  
`ALL`을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이며, `index_merge`를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다.  
  
아래의 3가지 접근 방법은 **WHERE 조건절에 사용하는 비교 연산다는 `동등 비교 연산자`여야 한다는 공통점이 있다.**  

1. **const** : 조인 순서와 관계없이 프라이머리 키나 유니크 키의 모든 컬럼에 대해 동등 조건으로 검색 **(반드시 1건의 레코드만 반환)**
2. **eq_ref** : 조인에서 첫 번째 읽은 테이블의 컬럼 값을 이용해 두 번째 테이블을 프라이머리 키나 유니크 키로 동등 조건 검색 **(두 번째 테이블은 반드시 1건의 레코드만 반환)**
3. **ref** : 조인의 순서와 인덱스의 종류에 관계없이 동등 조건으로 검색 **(1건의 레코드만 반환된다는 보장이 없어도 됨)**

아래의 2가지 접근 방법은 `IN(subquery)` 형태의 기준으로 나뉜다.  
  
1. **unique_subquery** : `IN(subquery)` 형태의 조건에서 subquery의 반환 값에는 중복이 없으므로 별도의 중복 제거 작업이 필요하지 않음
2. **index_subquery** : `IN(subquery)` 형태의 조건에서 subquery의 반환 값에 중복된 값이 있을 수 있지만 인덱스를 이용해 중복된 값을 제거할 수 있음

### system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다.  
InnoDB 스토리지 엔진에서는 나타나지 않고 MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.  

### const

테이블의 레코드 건수와 관계없이 **쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식을 const라고 한다.**  
다른 DBMS에서는 이를 유니크 인덱스 스캔이라고도 표현한다.  

```sql
mysql> explain select * from employees where emp_no=10001;

+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
```

아래와 같이 **다중 컬럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용될 때는 const 접근 방법을 사용할 수 없다.**  
이 경우에는 실제 레코드가 1건만 저장돼 있더라도 MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문이다.  

```sql
mysql> explain select * from dept_emp where dept_no='d005';

+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

const는 옵티마이저가 쿼리 결과를 상수화시켜 실제로 쿼리가 실행될 때 인라인되도록 하는 것이다.  

### eq_ref

**여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시되며, 조인에서 처음 읽은 테이블의 컬럼값을, 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리킨다.**  
또한 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 NOT NULL 이어야 하며, 다중 컬럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용돼야만 이 방법이 사용된다.  
즉, **조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법이다.**  
  
```sql
mysql> explain
    -> select * from dept_emp de, employees e
    -> where e.emp_no=de.emp_no and de.dept_no='d005';

+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys             | key     | key_len | ref                 | rows   | filtered | Extra |
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
|  1 | SIMPLE      | de    | NULL       | ref    | PRIMARY,ix_empno_fromdate | PRIMARY | 16      | const               | 165571 |   100.00 | NULL  |
|  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY                   | PRIMARY | 4       | employees.de.emp_no |      1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------------------+---------+---------+---------------------+--------+----------+-------+
```

### ref

eq_ref와 달리 조인의 순서와 관계없이 사용되며, 또한 프라이머리 키나 유니크 키 등의 제약 조건도 없다.  
**인덱스의 종류와 관계없이 동등 조건으로 검색할 때 이 방법이 사용된다.**  
이 타입은 반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않지만 **동등한 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나다.**  

```sql
mysql> explain
    -> select *
    -> from dept_emp
    -> where dept_no='d005';

+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

프라이머리 키를 구성하는 컬럼 중에서 일부인 dept_no만 동등 조건으로 검색했기 때문에 조건에 일치하는 레코드가 1건이라는 보장이 없기에 ref가 사용됐다.  
`ref` 컬럼 값에 const가 명시되어 있는데 이는 접근 방법이 아니라 **ref 접근 방법에서 값 비교에 사용된 입력 값이 상수 였음을 의미힌다.**  

### ref_or_null

ref 접근 방법과 같지만 NULL 비교가 추가된 형태다. 사용된다면 나쁘지 않은 접근 방법 정도로 기억하자.  

```sql
mysql> explain select * from titles where to_date='1985-03-01' OR to_date is null;

+----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
| id | select_type | table  | partitions | type        | possible_keys | key       | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | titles | NULL       | ref_or_null | ix_todate     | ix_todate | 4       | const |    2 |   100.00 | Using where; Using index |
+----+-------------+--------+------------+-------------+---------------+-----------+---------+-------+------+----------+--------------------------+
```

### range

인덱스 레인지 스캔 형태의 접근 방법이며, 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다.  
주로 `<, >, IS NULL, BETWEEN, IN, LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.  
얼마나 많은 레코드를 필요로 하느냐에 따라 차이는 있겠지만 이 접근 방법도 상당히 빠르며, 모든 쿼리가 이 접근 방법만 사용해도 최적의 성능이 보장된다고 볼 수 있다.  
  
### index_merge

이 방법은 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식이다.  
그렇게 효율적인 방법은 아니다.

1. 여러 인덱스를 읽어야 하므로 range 보다 효율이 떨어진다.
2. 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 사용되지 않는다.
3. 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합, 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

```sql
mysql> explain select * from employees
    -> where (emp_no between 10001 and 11000) or (first_name='Smith');

+----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table     | partitions | type        | possible_keys        | key                  | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | employees | NULL       | index_merge | PRIMARY,ix_firstname | PRIMARY,ix_firstname | 4,58    | NULL | 1001 |   100.00 | Using union(PRIMARY,ix_firstname); Using where |
+----+-------------+-----------+------------+-------------+----------------------+----------------------+---------+------+------+----------+------------------------------------------------+
```

### index

이 접근 방법을 인덱스를 효율적으로 사용하는 줄 오해를 많이 하지만 이 방법은 **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미힌다.**  
range 접근 방법과 같이 효율적으로 인덱스의 필요한 부분만 읽는 것을 의미하는 것은 아니라는 점을 명심해라.  
  
일반적으로 풀 테이블 스캔보다 빠르게 처리되며, 쿼리의 내용에 따라 정렬된 인덱스의 장점을 이용할 수 있으므로 효율적이라 할 수 있긴하다.  
1번과 2번을 만족하거나 1번과 3번을 만족하는 경우 사용되는 방식이다.  
  
1. range나 const,ref 같은 접근 방법으로 인덱스를 사용하지 못하는 경우
2. 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우 (즉, 데이터 파일을 읽지 않아도 되는 경우)
3. 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (즉, 별도의 정렬 작업을 피할 수 있는 경우)

## `possible_keys` 컬럼

옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해 쿼리를 실행한다.  
이 컬럼에 있는 내용은 **옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방법에서 사용되는 인덱스의 목록일 뿐이며 사용될법 했던 인덱스의 목록이다.**  
그냥 무시해도 된다.

## `key` 컬럼

최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.  

## `key_len` 컬럼

이 컬럼 정보는 매우 중요한 정보이며, **쿼리를 처리하기 위해 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 알려주는 정보다.**  
즉, 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값이다.  

```sql
mysql> explain select * from dept_emp where dept_no='d005';

+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key     | key_len | ref   | rows   | filtered | Extra |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | ref  | PRIMARY       | PRIMARY | 16      | const | 165571 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+---------+---------+-------+--------+----------+-------+
```

`dept_no   char(4)`이기 때문에 컬럼의 값이 16으로 표시된 것이다.  


```sql
mysql> explain select * from dept_emp where dept_no='d005' and emp_no=10001;

+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
| id | select_type | table    | partitions | type  | possible_keys             | key     | key_len | ref         | rows | filtered | Extra |
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | dept_emp | NULL       | const | PRIMARY,ix_empno_fromdate | PRIMARY | 20      | const,const |    1 |   100.00 | NULL  |
+----+-------------+----------+------------+-------+---------------------------+---------+---------+-------------+------+----------+-------+
```

`emp_no    int` INTEGER 타입은 4바이트를 차지하기 때문에 20으로 표시된 것이다.

## `ref` 컬럼

참조 조건으로 어떤 값이 제공됐는지 보여준다. 상숫값을 지정했다면 ref 컬럼의 값은 const로 표시되고, 다른 테이블의 컬럼값이면 그 테이블명과 컬럼명이 표시된다.  
`func`가 출력되면 **문자 집합이 일치하지 않는 두 문자열 컬럼을 조인한다거나 숫자 타입의 컬럼과 문자열 타입의 컬럼으로 조인하는지 확인이 필요하다.**  

## `rows` 컬럼

실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여주며 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 MySQL 옵티마이저가 산출해 낸 예상값이라서 정확하지는 않다.  
**반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미힌다.**  

## `filtered` 컬럼

**필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.**  

## `Extra` 컬럼

주로 내부적인 처리 알고리즘에 대해 조금 더 깊이 있는 내용을 보여주는 경우가 많다.  

### Not exists ⭐️

A 테이블에는 존재하지만 B 테이블에는 없는 값을 조회해야 하는 쿼리가 필요할 수 있다. 이때는 주로 `NOT IN(subquery)`, `NOT EXISTS` 연산자를 사용한다.  
이러한 형태의 조인을 **안티 조인** 이라고 하며, **똑같은 처리를 아우터 조인을 이용해서도 구현할 수 있다.**  
레코드의 건수가 많을 때는 아우터 조인을 이용하면 더 빠른 성능을 낼 수 있다.  
  
아우터 조인을 이용해 `dept_emp` 테이블에는 있지만 `departments` 테이블에는 없는 `dept_no`를 조회하는 쿼리를 살펴보자.  

```sql
mysql> explain
    -> select *
    -> from dept_emp de left join departments d
    ->     on de.dept_no = d.dept_no
    -> where d.dept_no is null;

+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                                  |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------------------+
|  1 | SIMPLE      | de    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 331143 |   100.00 | NULL                                                   |
|  1 | SIMPLE      | d     | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |      9 |    11.11 | Using where; Not exists; Using join buffer (hash join) |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+--------------------------------------------------------+
```

Not Exists 메시지는 옵티마이저가 `dept_emp` 테이블의 레코드를 이용해 `departments` 테이블을 조인할 때 `departments` 테이블의 레코드가 존재하는지 아닌지만 판단한다는 것을 의미한다.  
즉, `departments` 테이블에 조인 조건에 일치하는 레코드가 여러 건이 있다고 하더라도 딱 1건만 조회해보고 처리를 완료하는 최적화를 의미한다.

### Range checked for each record(index map:N)

두 개의 테이블을 조인하는 아래의 쿼리를 보면서 이 메세지의 의미를 이해해 보자.  
조인 조건에 상수가 없고 둘 다 변수 `e1.emp_no` 와 `e2.emp_no` 인 경우 옵티마이저는 `e1` 테이블을 먼저 읽고 조인을 위해 `e2`를 읽을 때 인덱스 레인지 스캔과 풀 테이블 스캔 중에서 어느 것이 효율적인지 판단할 수 없다.  
즉, `e1` 테이블의 레코드를 하나씩 읽을 때마다 `e1.emp_no` 값이 계속 바뀌므로 쿼리의 비용 계산을 위한 기준 값이 계속 변하는 것이다. 그래서 어떤 접근 방법으로 `e2` 테이블을 읽는 것이 좋을지 판단할 수 없다.  

```sql
mysql> explain
    -> select *
    -> from employees e1, employees e2
    -> where e1.emp_no <= e2.emp_no;

+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+------------------------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra                                          |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+------------------------------------------------+
|  1 | SIMPLE      | e1    | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL | 299888 |   100.00 | NULL                                           |
|  1 | SIMPLE      | e2    | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL | 299888 |    33.33 | Range checked for each record (index map: 0x1) |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+------------------------------------------------+
```

예를 들어, 사번이 1번부터 1억 번까지 있다고 가정하면 `e1` 테이블을 처음부터 끝까지 스캔하면서 `e2` 테이블에서 `e1.emp_no <= e2.emp_no` 조건을 만족하는 레코드를 찾을 때 `e1.emp_no`가 1인 경우 `e2` 테이블의 1억 건 전부를 읽어야 한다는 것이다.  
이 메세지는 **레코드마다 인덱스 레인지 스캔을 체크한다** 는 의미이다.  
`index map: 0x1`의 의미는 `0x1`을 이진수로 바꾼 정수가 `SHOW CREATE TABLE employees` 명령으로 테이블의 구조를 조회했을 때 출력되는 인덱스의 순서를 의미한다.  
그 순서에 해당하는 인덱스를 사용할지 테이블 풀 스캔을 할지 매 레코드 단위로 결정하면서 처리된다.  

### Recursive

MySQL 8.0 부터는 Common Table Expression을 이용해 재귀 쿼리를 작성할 수 있게 됐다.  

```sql
WITH RECURSIVE cte (n) AS
(
    SELECT 1
    UNION ALL
    SELECT n + 1 FROM cte WHERE n < 5
)
SELECT * from cte;
```

1. `n` 이라는 컬럼 하나를 가진 `cte` 이름의 내부 임시 테이블을 생성
2. `n` 컬럼의 값이 1부터 5까지 1씩 증가하게 해서 레코드 5건을 만들어서 `cte` 내부 임시 테이블에 저장
3. 마지막 SELECT 쿼리에서 WITH 절에서 생성된 내부 임시 테이블을 조회해서 결과를 반환한다.

### Rematerialize

래터럴 조인 기능이 추가되면서 래터럴로 조인되는 테이블은 선행 테이블의 레코드별로 서브쿼리를 실행해서 그 결과를 임시 테이블에 저장한다.  
이 과정을 `"Rematerializing"` 이라고 한다.  

```sql
mysql> explain
    -> select *
    -> from employees e left join lateral (select *
    ->                                     from salaries s
    ->                                     where s.emp_no = e.emp_no
    ->                                     order by s.from_date desc limit 2) s2
    ->     on s2.emp_no = e.emp_no
    -> where e.first_name = 'Matt';

+----+-------------------+------------+------------+------+---------------+--------------+---------+--------------------+------+----------+----------------------------+
| id | select_type       | table      | partitions | type | possible_keys | key          | key_len | ref                | rows | filtered | Extra                      |
+----+-------------------+------------+------------+------+---------------+--------------+---------+--------------------+------+----------+----------------------------+
|  1 | PRIMARY           | e          | NULL       | ref  | ix_firstname  | ix_firstname | 58      | const              |  233 |   100.00 | Rematerialize (<derived2>) |
|  1 | PRIMARY           | <derived2> | NULL       | ref  | <auto_key0>   | <auto_key0>  | 4       | employees.e.emp_no |    2 |   100.00 | NULL                       |
|  2 | DEPENDENT DERIVED | s          | NULL       | ref  | PRIMARY       | PRIMARY      | 4       | employees.e.emp_no |    9 |   100.00 | Using filesort             |
+----+-------------------+------------+------------+------+---------------+--------------+---------+--------------------+------+----------+----------------------------+
```

이 실행 계획에서는

1. `employees` 테이블의 레코드마다 `salaries` 테이블에서 `emp_no`가 일치하는 레코드 중에서 `from_date` 컬럼의 역순으로 2건만 가져와 임시 테이블 `derived2`로 저장했다.  
2. `employees` 테이블과 `derived2` 테이블을 조인한다. 여기서 derived2 임시 테이블은 employees 테이블의 레코드마다 새로 내부 임시 테이블이 생성된다.

이렇게 매번 임시 테이블이 새로 생성되는 경우 이 메시지가 표현된다.  

### Select tables optimized away

`MIN()`, `MAX()`만 SELECT 절에 사용되거나 `GROUP BY`로 `MIN()`, `MAX()`를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용된다면 이 메세지가 표현된다.  

```sql
mysql> explain
    -> select max(emp_no), min(emp_no) from employees;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                        |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Select tables optimized away |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------------------+
```

### Start temporary, End temporary

세미 조인 최적화 중에서 `Duplicate Weed-out` 최적화 전략이 사용되면 이 메시지가 표현된다.  
불필요한 중복 건을 제거하기 위해서 내부 임시 테이블을 사용하는데, 이때 조인되어 내부 임시 테이블에 저장되는 테이블을 식별할 수 있게 조인의 첫 번째 테이블에 `Start temporary` 문구를 보여주고 조인이 끝나는 부분에 `End temporary` 문구를 표시해준다.  

### Using filesort ⭐️

`ORDER BY`를 처리하기 위해 인덱스를 이용할 수도 있지만 **적절한 인덱스를 사용하지 못할 때는 조회된 레코드를 다시 한번 정렬해야 한다.**  
ORDER BY 처리가 인덱스를 사용하지 못할 때만 실행 계획의 이 메세지가 표현되며, **조회된 레코드를 소트 버퍼(정렬용 메모리 버퍼)에 복사해 퀵 소트 또는 힙 소트 알고리즘을 이용해 정렬을 수행하게 된다는 의미이다.**  

```sql
mysql> explain
    -> select * from employees
    -> order by last_name desc;

+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299888 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
```

이 메세지가 표현된다면 많은 부하를 일으키므로 가능하다면 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.

### Using index (커버링 인덱스) ⭐️

데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 이 메세지가 표현된다.  
인덱스를 이용해 처리하는 쿼리에서 **가장 큰 부하를 차지하는 부분이 인덱스에서 일치하는 키 값들의 레코드를 읽기 위해 데이터 파일을 검색하는 작업이다.**  
최악의 경우에는 인덱스를 통해 검색된 결과 레코드 각각 디스크를 읽어야 할 수 있다.  

```sql
mysql> explain
    -> select first_name, birth_date
    -> from employees
    -> where first_name between 'Babette' and 'Gad';

+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | ix_firstname  | NULL | NULL    | NULL | 299888 |    31.28 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
```

위의 쿼리는 birth_date에 해당하는 인덱스가 존재하지 않기에 각 레코드가 저장된 데이터 페이지를 조회 결과만큼 읽어야하기에 옵티마이저는 풀 테이블 스캔이 더 효율적이라고 판단한 것이다.  

```sql
mysql> explain
    -> select first_name
    -> from employees
    -> where first_name between 'Babette' and 'Gad';

+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key          | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | employees | NULL       | range | ix_firstname  | ix_firstname | 58      | NULL | 93802 |   100.00 | Using where; Using index |
+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+-------+----------+--------------------------+
```

birth_date가 제거된 쿼리는 인덱스 레인지 스캔으로 처리된 것을 볼 수 있다.  
이 쿼리는 인덱스를 통해서 필요한 레코드를 검색하고 필요한 컬럼까지 인덱스에서 가져올 수 있기 때문에 데이터 파일을 읽어 올 필요가 없기에 빠른 처리가 가능하다.  
  
InnoDB의 모든 테이블은 클러스터링 인덱스로 구성돼 있으며 모든 세컨더리 인덱스는 데이터 레코드의 주솟값으로 프라이머리 키 값을 가진다.  
그렇기에 `first_name` 컬럼만으로 인덱스를 만들어도 결국 그 인덱스에 `emp_no` 컬럼이 같이 저장되는 효과를 낸다.  
**이러한 클러스터링 인덱스 특성 때문에 쿼리가 "커버링 인덱스"로 처리될 가능성이 상당히 높다.**  
즉, InnoDB의 세컨더리 인덱스에는 데이터 레코드를 찾아가기 위한 주소로 사용하기 위해 프라이머리 키를 저장해두는 것이지만, 추가 컬럼을 하나 더 가지는 인덱스의 효과를 동시에 얻을 수 있다.  

> Extra 컬럼에 표시되는 "Using index"와 type 컬럼(접근 방법)에 표시되는 "index"를 혼동할 때가 자주 있다.  
> 이 두 가지는 **성능상 반대되는 개념이라서 반드시 구분해서 이해해야 한다.**  
> type의 "index"는 인덱스 풀 스캔으로 처리하는 방식을 의미하며, 이는 인덱스 레인지 스캔보다 훨씬 느린 처리 방식이다.  
> 하지만 Extra의 "Using index"는 커버링 인덱스가 사용되지 않는 쿼리보다는 훨씬 빠르게 처리한다는 것을 의미힌다.  
> **커버링 인덱스는 실행 계획의 type에 관계없이 사용될 수 있다.**

### Using index for group-by ⭐️

`GROUP BY` 처리를 위해 MySQL 서버는 그루핑 기준 컬럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그루핑하는 형태의 고부하 작업을 필요로 한다.  
하지만 B-Tree 인덱스를 이용하면 별도의 추가 정렬 작업 없이 정렬된 인덱스 컬럼을 순서대로 읽으면서 그루핑 작업만 수행한다.  
즉, **GROUP BY 처리에 인덱스를 이용하게 되면 레코드의 정렬이 필요하지 않고 인덱스의 필요한 부분만 읽으면 되기 때문에 상당히 효율적이고 빠르게 처리된다.**  
이때 `"Using index for group-by"` 메세지가 표현된다. (GROUP BY 처리를 위해 인덱스를 읽는 방법을 루스 인덱스 스캔이라고 한다.)  
  
GROUP BY 처리를 위해 단순히 인덱스를 순서대로 쭉 읽는 것과 인덱스의 필요한 부분만 듬성듬성 읽는 루스 인덱스 스캔은 다르다.  

<h3>타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리</h3>

`AVG()`, `SUM()`, `COUNT()`처럼 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성듬성 읽을 수가 없다.  
이런 쿼리는 단순히 GROUP BY를 위해 인덱스를 사용하기는 하지만, 이를 루스 인덱스 스캔이라고 하지는 않는다.  
이 경우에는 `"Using index for group-by"` 메시지가 표현되지 않는다.  

```sql
mysql> explain
    -> select first_name, count(*) as counter
    -> from employees group by first_name;

+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | index | ix_firstname  | ix_firstname | 58      | NULL | 299888 |   100.00 | Using index |
+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+--------+----------+-------------+
```

<h3>루스 인덱스 스캔을 통한 GROUP BY 처리</h3>

단일 컬럼으로 구성된 인덱스에서는 그루핑 컬럼 말고는 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다.  
그리고 다중 컬럼으로 만들어진 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 함은 물론이고 `MIN()`이나 `MAX()`같이 조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리는 "루스 인덱스 스캔"이 사용될 수 있다.  
이때는 인덱스를 듬성듬성하게 필요한 부분만 읽는다.  

```sql
mysql> explain
    -> select emp_no, min(from_date) as first_changed_date, max(from_date) as last_changed_date
    -> from salaries
    -> group by emp_no;

+----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys     | key     | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | salaries | NULL       | range | PRIMARY,ix_salary | PRIMARY | 4       | NULL | 307243 |   100.00 | Using index for group-by |
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+--------+----------+--------------------------+
```

위의 쿼리는 `salaries` 테이블의 `(emp_no, from_date)`로 만들어진 인덱스에서 각 `emp_no`그룹별로 `첫 번째 from_date`와 `마지막 from_date`를 인덱스로부터 읽으면 되기 때문에 루스 인덱스 스캔 방식으로 처리할 수 있다.  

> GROUP BY에서 인덱스를 사용하려면 GROUP BY 조건에서 우선 인덱스를 사용할 수 있는 요건이 갖춰져야 하며, 그 이전에 WHERE 절에서 사용하는 인덱스에 의해서도 영향을 받는다는 사실이 중요하다.

1. **WHERE 조건절이 없는 경우**
   - GROUP BY 절의 컬럼과 SELECT로 가져오는 컬럼이 "루스 인덱스 스캔"을 사용하는 조건만 갖추면 된다.
   - 그렇지 못한 쿼리는 타이트 인덱스 스캔이나 별도의 정렬 과정을 통해 처리된다.
2. **WHERE 조건절이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우**
   - GROUP BY 절은 인덱스를 사용할 수 있지만 WHERE 조건절이 인덱스를 사용하지 못할 때도 타이트 인덱스 스캔 과정을 통해 GROUP BY가 처리된다.
3. **WHERE 절의 조건이 있고, 검색을 위해 인덱스를 사용하는 경우**
   - WHERE 절의 조건과 GROUP BY 처리가 똑같은 인덱스를 공통으로 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있다.

> WHERE 절의 조건이 검색을 위해 인덱스를 이용하고, GROUP BY가 같은 인덱스를 사용할 수 있는 쿼리라고 하더라도 **WHERE 조건에 의해 검색된 레코드 건수가 적으면 루스 인덱스 스캔을 사용하지 않을 수 있다.**  
> 루스 인덱스 스캔은 주로 대량의 레코드를 GROUP BY하는 경우 성능 향상 효과가 있을 수 있기 때문에 옵티마이저가 적절히 손익분기점을 판단하는 것이다.  

아래의 쿼리와 같이 WHERE절을 통해 검색 범위를 좁히니 Using index for group-by가 사라진 것을 확인할 수 있다. 

```sql
mysql> explain
    -> select emp_no, min(from_date) as first_changed_date, max(from_date) as last_changed_date
    -> from salaries
    -> where emp_no between 10001 and 11000
    -> group by emp_no;
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+-------+----------+--------------------------+
| id | select_type | table    | partitions | type  | possible_keys     | key     | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | salaries | NULL       | range | PRIMARY,ix_salary | PRIMARY | 4       | NULL | 18266 |   100.00 | Using where; Using index |
+----+-------------+----------+------------+-------+-------------------+---------+---------+------+-------+----------+--------------------------+
```

### Using index for skip scan

옵티마이저가 인덱스 스킵 스캔 최적화를 사용하면 이 메세지가 표현된다.  

```sql
mysql> explain
    -> select gender, birth_date
    -> from employees
    -> where birth_date >= '1965-02-01';

+----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+-------+----------+----------------------------------------+
| id | select_type | table     | partitions | type  | possible_keys       | key                 | key_len | ref  | rows  | filtered | Extra                                  |
+----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+-------+----------+----------------------------------------+
|  1 | SIMPLE      | employees | NULL       | range | ix_gender_birthdate | ix_gender_birthdate | 4       | NULL | 99952 |   100.00 | Using where; Using index for skip scan |
+----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+-------+----------+----------------------------------------+
```

MySQL 8.0 부터는 **루스 인덱스 스캔 최적화를 확장한 인덱스 스킵 스캔 최적화가 도입됐다.**

### Using join buffer (Block Nested Loop),(Batched Key Access),(hash join) 

일반적으로 빠른 쿼리 실행을 위해 조인되는 컬럼은 인덱스를 생성한다.  
**실제로 조인에 필요한 인덱스는 조인되는 양쪽 테이블 컬럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 컬럼에만 필요하다.**  
옵티마이저도 조인되는 두 테이블에 있는 각 컬럼에서 인덱스를 조사하고, 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행한다.  
뒤에 읽는 드리븐 테이블은 검색 위주로 사용되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우 크기 때문이다.  
  
조인이 수행될 때 드리븐 테이블의 조인 컬럼에 적절한 인덱스가 있으면 아무런 문제가 되지 않지만, 적절한 인덱스가 없다면 MySQL 서버는 블록 네스티드 루프 조인이나 해시 조인을 사용한다.  
그럼 조인 퍼버를 사용하게 되기 때문에 `"Using join buffer"` 메세지가 표현된다.  
(그 뒤에 괄호로 작성되는 정보는 조인 알고리즘을 표현한다.)  

### Using MRR ⭐️

MySQL 엔진은 실행 계획을 수립하고 그 실행 계획에 맞게 스토리지 엔진의 API를 호출해서 쿼리를 처리한다.  
InnoDB를 포함한 스토리지 엔진 레벨에서는 쿼리 실행의 전체적인 부분을 알지 못하기 때문에 최적화에 한계가 있다.  
그렇기에 스토리지 엔진은 MySQL 엔진이 넘겨주는 키 값을 기준으로 레코드를 각각 읽어서 반환하는 방식으로 작동했다.  
즉, 레코드 단위로 API의 호출이 필요한 것이다.  
  
이 같은 단점을 보완하기 위해 **Multi Range Read** 라는 최적화를 도입하여, MySQL 엔진은 여러 개의 키 값을 한 번에 스토리지 엔진으로 전달하고, 스토리지 엔진은 넘겨받은 키 값들을 정렬해서 최소한의 페이지 접근만으로 필요한 레코드를 읽을 수 있게 최적화한다.  

### Using sort_union(...), Using union(...), Using intersect(...) ⭐️

쿼리가 `index_merge` 접근 방법 (실행 계획의 type 컬럼의 값이 index_merge)으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있다.  
이때 **실행 계획의 Extra 컬럼에는 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명한다.**  

1. **Using intersect(...)** : 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미다.
2. **Using union(...)** : 각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미다.
3. **Using sort_union(...)** : Using union과 같은 작업을 수행하지만 OR로 연결된 상대적으로 대량의 range 조건인 경우에는 이 방식으로 처리된다.
   - Using sort_union은 프라이머리 키만 먼저 읽어서 정렬하고 병합한 이후 비로소 레코드를 읽어서 반환할 수 있다는 차이점이 있다.

실제로는 레코드 건수에 관계없이 각 WHERE 조건에 사용된 비교 조건이 모두 동등 조건이면 `Using union`이 사용되며, 그렇지 않으면 `Using sort_union`이 사용된다.

### Using temporary ⭐️

쿼리를 처리하는 동안 중간 결과를 담아두기 위해 임시 테이블을 사용한다는 뜻이다.  
이 임시 테이블은 메모리상에 생성될 수도 있고 디스크상에 생성될 수도 있다.  

```sql
mysql> explain
    -> select first_name
    -> from employees
    -> group by first_name
    -> order by min(emp_no);

+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------------------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                                                     |
+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------------------------------------+
|  1 | SIMPLE      | employees | NULL       | range | ix_firstname  | ix_firstname | 58      | NULL | 1716 |   100.00 | Using index for group-by; Using temporary; Using filesort |
+----+-------------+-----------+------------+-------+---------------+--------------+---------+------+------+----------+-----------------------------------------------------------+
```

위의 경우 GROUP BY 컬럼과 ORDER BY 컬럼이 다르기 때문에 임시 테이블이 필요한 것을 확인할 수 있다.  

> 실제로 "Using temporary"가 표시되지 않았다고 해서 임시 테이블을 사용하지 않는다고 판단하지 않도록 주의해야 한다.  
> 대표적으로 메모리나 디스크에 임시 테이블을 생성하는 쿼리는 아래와 같다.  
> 1. FROM 절에 사용된 서브쿼리는 무조건 임시 테이블을 생성한다. 이 테이블을 파생 테이블이라고 부르긴 하지만 결국은 임시 테이블이다.
> 2. "COUNT(DISTINCT column1)"를 포함하는 쿼리도 인덱스를 사용할 수 없는 경우에는 임시 테이블이 만들어진다.
> 3. UNION이나 UNION DISTINCT가 사용된 쿼리도 항상 임시 테이블을 사용해 결과를 반환한다. MySQL 8.0 부터는 UNION ALL이 사용된 겨우에는 내부 임시 테이블을 사용하지 않도록 개선됐다.
> 4. 인덱스를 사용하지 못하는 정렬 작업 또한 임시 버퍼 공간을 사용하며, 정렬해야 할 레코드가 많아지면 결국 디스크를 사용한다. 해당 소트 버퍼도 결국 임시 테이블과 같다. Using filesort도 임시 테이블을 사용한다는 것이다.

### Using where ⭐️

MySQL 서버는 내부적으로 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나뉜다.  
MySQL 엔진은 스토리지 엔진으로 부터 받은 레코드를 가공 또는 연산하는 작업을 수행하며,  
스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장하는 역할을 한다.  
  
**MySQL 엔진 레이어에서 별도의 가공을 해서 필터링(여과) 작업을 처리한 경우에만 이 메세지가 표현된다.**  
실제로 작업 범위 결정 조건은 각 스토리지 엔진 레벨에서 처리되지만 체크 조건은 MySQL 엔진 레이어에서 처리되기 때문이다.  

```sql
mysql> explain
    -> select *
    -> from employees
    -> where emp_no between 10001 and 10100
    -> and gender = 'F';

+----+-------------+-----------+------------+-------+-----------------------------+---------+---------+------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys               | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+-----------------------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | range | PRIMARY,ix_gender_birthdate | PRIMARY | 4       | NULL |  100 |    50.00 | Using where |
+----+-------------+-----------+------------+-------+-----------------------------+---------+---------+------+------+----------+-------------+
```

위의 작업 범위 결정 조건으로 `emp_no`와 `gender`가 사용된 것을 확인할 수 있다.  
`emp_no`의 조건에 해당하는 레코드는 총 100건이지만, 두 조건을 만족하는 레코드는 37건 밖에 안된다.  
이 의미는 스토리지 엔진은 100개를 읽어서 MySQL 엔진에 전달하였지만 MySQL 엔진은 그 중에서 63건의 레코드를 필터링해서 버렸다는 의미다.  
"Using where"가 63건의 레코드를 버리는 처리를 의미한다.  
  
유의해야 할점은 "Using where"가 가장 흔히 표시되는 내용이며 왜 표시되는지 전혀 이해할 수 없을 수도 있다.  
성능상의 문제를 일으킬지 아닐지를 선별하기 위해서는 `filtered` 컬럼도 같이 확인해야 한다.  
위의 쿼리는 옵티마이저가 50건은 버려지고 50건이 반환될 것으로 예측했다.  

> 위의 쿼리는 `(emp_no,gender)`로 구성된 인덱스가 존재했다면 필요한 37개의 레코드만 정확하게 읽었을 것이다.

### Deleting all rows

테이블의 모든 레코드를 삭제하는 WHERE 조건절이 없는 DELETE 문의 실행 계획에서 자주 표시된다.  
기존에는 테이블의 레코드를 삭제하기 위해 각 스토리지 엔진의 핸들러 함수를 레코드 건수만큼 호출해서 삭제해야 했는데, 테이블의 모든 레코드를 삭제하는 핸들러 기능을 한 번 호출함으로써 처리됐다는 것을 의미한다.  
MySQL 8.0 버전에서는 표시되지 않으며 DELETE 보다 TRUNCATE를 쓰는것을 권장한다.  

### Distinct

```sql
explain 
select distinct d.dept_no 
from departments d, dept_emp de 
where de.dept_no = d.dept_no;

+----+-------------+-------+------------+-------+---------------------+-------------+---------+---------------------+-------+----------+------------------------------+
| id | select_type | table | partitions | type  | possible_keys       | key         | key_len | ref                 | rows  | filtered | Extra                        |
+----+-------------+-------+------------+-------+---------------------+-------------+---------+---------------------+-------+----------+------------------------------+
|  1 | SIMPLE      | d     | NULL       | index | PRIMARY,ux_deptname | ux_deptname | 162     | NULL                |     9 |   100.00 | Using index; Using temporary |
|  1 | SIMPLE      | de    | NULL       | ref   | PRIMARY             | PRIMARY     | 16      | employees.d.dept_no | 41392 |   100.00 | Using index; Distinct        |
+----+-------------+-------+------------+-------+---------------------+-------------+---------+---------------------+-------+----------+------------------------------+
```

위 쿼리에서 실제 조회하려는 값은 `dept_no`인데, 두 테이블에 모두 존재하는 `dept_no`만 중복 없이 유니크하게 가져오기 위한 쿼리이다.  
`departments` 테이블은 `dept_no`가 기본키 이기 때문에 모두 한 번에 읽으면 그만이지만 `dept_emp` 테이블에서는 `dept_no`가 중복되어 존재할 수 있기 때문에 꼭 필요한 레코드만 읽었다는 것을 표현한다.  

### FirstMatch

세미 조인의 여러 최적화 중에서 `FirstMatch` 전략이 사용된 경우 출력된다.  

```sql
mysql> explain
    -> select *
    -> from employees e
    -> where e.first_name = 'Matt' and
    ->       e.emp_no in (
    ->           select t.emp_no
    ->           from titles t
    ->           where t.from_date between '1995-01-01' and '1995-01-30'
    ->         );
+----+-------------+-------+------------+------+----------------------+--------------+---------+--------------------+------+----------+-----------------------------------------+
| id | select_type | table | partitions | type | possible_keys        | key          | key_len | ref                | rows | filtered | Extra                                   |
+----+-------------+-------+------------+------+----------------------+--------------+---------+--------------------+------+----------+-----------------------------------------+
|  1 | SIMPLE      | e     | NULL       | ref  | PRIMARY,ix_firstname | ix_firstname | 58      | const              |  233 |   100.00 | NULL                                    |
|  1 | SIMPLE      | t     | NULL       | ref  | PRIMARY              | PRIMARY      | 4       | employees.e.emp_no |    1 |    11.11 | Using where; Using index; FirstMatch(e) |
+----+-------------+-------+------------+------+----------------------+--------------+---------+--------------------+------+----------+-----------------------------------------+
```

`FirstMatch({테이블 명})`에 작성된 테이블은 기준 테이블을 의미하며, 위의 경우 `employees` 테이블을 기준으로 `titles` 테이블에서 각 사원 기준 첫 번째로 일치하는 한 건만 검색한다는 것을 의미한다.  

```sql
mysql> explain
    -> select *
    -> from departments d
    -> where d.dept_no in (select distinct de.dept_no from dept_emp de);

mysql> explain
    -> select *
    -> from departments d
    -> where d.dept_no in (select de.dept_no from dept_emp de);

+----+-------------+-------+------------+------+---------------+---------+---------+---------------------+-------+----------+----------------------------+
| id | select_type | table | partitions | type | possible_keys | key     | key_len | ref                 | rows  | filtered | Extra                      |
+----+-------------+-------+------------+------+---------------+---------+---------+---------------------+-------+----------+----------------------------+
|  1 | SIMPLE      | d     | NULL       | ALL  | PRIMARY       | NULL    | NULL    | NULL                |     9 |   100.00 | NULL                       |
|  1 | SIMPLE      | de    | NULL       | ref  | PRIMARY       | PRIMARY | 16      | employees.d.dept_no | 41392 |   100.00 | Using index; FirstMatch(d) |
+----+-------------+-------+------------+------+---------------+---------+---------+---------------------+-------+----------+----------------------------+
```

위의 두 쿼리는 동일한 실행계획을 출력하는 것을 보면 이해할 수 있을 것이다.  

### Full scan on NULL key

이 처리는 `col1 IN (SELECT col2 FROM ...)`과 같은 조건을 가진 쿼리에서 자주 발생하며, `col1`의 값이 NULL이 된다면 조건은 `NULL IN (SELECT col2 FROM ...)`과 같이 바뀐다.  
SQL 표준에서는 NULL을 "알 수 없는 값"으로 정의하고 있으며, NULL에 대한 연산의 규칙까지 정의하고 있다.  
그 정의대로 연산을 수행하기 위해 이 조건은 아래와 같이 비교돼야 한다.  

1. 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL
2. 서브쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE

이 비교 과정에서 `col1`이 NULL이면 서브쿼리에 사용된 테이블에 대해서 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다.  
즉, **서버가 쿼리를 실행하는 중 col1이 NULL을 만나면 차선책으로 서브쿼리 테이블에 대해서 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드다.**  
상당한 성능 문제가 발생할 수 있는 방법이며 가능하다면 조건에 `col1 IS NOT NULL` 조건을 앞에 추가하여 옵티마이저에게 알려주는 것이 좋다.  
만약 `col1`이 NOT NULL 컬럼이라면 이 차선책은 사용되지 않는다.  

### Impossible HAVING

쿼리에 사용된 `HAVING` 절의 조건을 만족하는 레코드가 없을 때 출력된다.  

```sql
mysql> explain
    -> select e.emp_no, COUNT(*) as cnt
    -> from employees e
    -> where e.emp_no = 10001
    -> group by e.emp_no
    -> having e.emp_no IS NULL;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra             |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible HAVING |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------+
```

`employees` 테이블의 `emp_no`는 기본키이기 때문에 NOT NULL 타입의 컬럼이다. HAVING에 이런 조건을 만족할 가능성이 없는 경우 표시된다.  
이런 경우 쿼리의 내용을 다시 점검하는 것이 좋다.  

### Impossible WHERE

Impossible HAVING과 비슷하며, **WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우 이 키워드가 표시된다.**  

```sql
mysql> explain select * from employees where emp_no IS NULL;

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+
```

### No matching min/max row

쿼리의 WHERE 조건절을 만족하는 레코드가 한 건도 없는 경우 일반적으로 Impossible WHERE 메세지가 표현되지만, `MIN()`이나 `MAX()` 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때는 이 메세지가 표현된다.  

```sql
mysql> explain
    -> select min(dept_no), max(dept_no)
    -> from dept_emp where dept_no = '';

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                   |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No matching min/max row |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------------------+
```

### no matching row in const table

조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없다면 이 메세지가 표현된다.

```sql
mysql> explain
    -> select *
    -> from dept_emp de, (select emp_no from employees where emp_no = 0) tb1
    -> where tb1.emp_no = de.emp_no and de.dept_no = 'd005';

+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | no matching row in const table |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+--------------------------------+
```

No matching rows after partition pruning 이 메세지도 비슷한 맥락이다.