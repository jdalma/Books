<!-- TOC -->

- [Buffer Pool](#buffer-pool)
  - [Buffer Pool Flush](#buffer-pool-flush)
- [Redo log](#redo-log)
- [Double Write Buffer](#double-write-buffer)
- [Undo log](#undo-log)
  - [Undo Tablespace](#undo-tablespace)

<!-- /TOC -->


**dev mysql**  
- [버퍼풀](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)
- [glos page](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page)

1. [ ] "사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리할 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다" (83p)
   - 그럼 쓰기 작업은 버퍼에 담아 따로 처리할 수 있는 기능이 있다는 말이고, 읽기 작업은 스레드 캐시에 있는 스레드를 초과한 요청이 오면 스레드를 추가적으로 생성한다고 하는 것 같다
   - 추가적으로 생성된 스레드는 버려진다. 
   - "스레드 캐시에 지정한 개수 이상의 대기 중인 스레드가 있으면 스레드를 종료한다." (82p)
   - 에를 들어 최대 개수 4개의 스레드가 모두 쓰기 작업을 하고 있는 와중에 읽기 요청이 오면 쓰기 요청을 처리하고 있던 백그라운드 스레드는 어떻게 될까?
2. [ ] "`데이터 읽기/쓰기`작업은 대부분 1건의 레코드 단위" (87p)
   - 1건의 레코드 단위라는 말이 무슨 말이지?
3. [ ] `INSERT INTO ... SELECT` 는 어떤 스레드가 사용되나
4. [ ] 컴포넌트 아키텍처
5. [x] "제한된 수의 스레드 만으로 CPU가 처리하도록 적절히 유도한다면 CPU의 프로세서 친화도도 높이고 운영체제 입장에서는 불필요한 `컨텍스트 스위치`를 줄여서 오버헤드를 낮출 수 있다." (94p)
   - "MySQL 서버는 프로세스 기반이 아니라 **스레드 기반으로 작동하며**.." (80p)를 보면 위에서 말한  `컨텍스트 스위치`는 프로세서간이 아니라 스레드간 문맥 전환을 말하는 것 같다.
   - 그리고 "스레드 풀의 개수를 CPU 코어 개수와 비슷하게 설정하면 오버헤드를 낮출 수 있다" 라는 말은 최대한 모든 요청을 병렬 처리하는것이 CPU의 오버헤드를 낮출 수 있다라고 이해했다.
   - 만약 스레드 풀의 개수를 CPU 코어의 개수보다 높게 설정한다면 동시 처리할 가능성이 있기 때문
6. [ ] "InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다." (99p)
   - 서로 다른 테이블이 키들이 같은 컬럼이라면?
   - 기준이라는 말이 무슨 뜻이지?
7. [ ] "프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다." (99p)
   - 세컨더리 인덱스?
   - 프라이머리 키의 값을 논리적인 주소로 사용?
8. [ ] 언두, 리두 로그

***

## Buffer Pool

1. [ ] InnoDB 스토리지 엔진은 크게 `LRU 리스트`와 `Flush 리스트` 그리고 `Free 리스트`라는 3개의 자료구조를 관리한다. (109p)
   1. `Free 리스트` : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다
   2. `LRU 리스트` : 엄밀하게 `MRU (Most Recently Used)`리스트가 결합된 형태이다.
      1. **Old 서브리스트**영역은 `LRU`에 해당하며, **New 서브리스트**영역은 `MRU`에 해당된다.
   3. `Flush 리스트` : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(`더티 페이지`)의 변경 시점 기준의 페이지 목록을 관리한다.
      1. 한 번이라고 데이터가 변경된 데이터 페이지는 플러시 리스트에 관리되고, **특정 시점이 되면 디스크로 기록돼야 한다.**
      2. 데이터가 변경되면 InnoDB는 변경 내용을 **리두 로그**에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
2. [x] InnoDB 스토리지 엔진에서 데이터를 찾는 과정
   1. **필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사**
      1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
      2. 해당 테이블의 인덱스(`B-Tree`)를 이용해 버퍼 풀에서 페이지를 검색
      3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 `MRU`방향으로 승급
   2. **디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 `LRU`헤더 부분에 추가**
   3. **버퍼 풀의 `LRU` 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 `MRU` 헤더 부분으로 이동**
      1. [ ] `Read Ahead`와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우에 `MRU`로 이동되지 않음 
   4. **버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 `나이`가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 `나이`가 오래되고(`Aging`이라고 함) 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지는 쿼리에 의해 사용되면 나이가 초기화되며, 이런 경우에는 `MRU`의 헤더 부분으로 옮겨진다.**
   5. **필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가**
3. [ ] 버퍼 풀은 여러 개로 쪼개어 관리할 수 있는데, 여러 데이터 페이지들은 버퍼 풀에 속한다. `LRU 리스트`와 `Flush 리스트` 그리고 `Free 리스트`라는 3개의 자료구조 
4. [ ] 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다. 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
   1. **엔트리**??
5. [x] InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 `데이터 캐시`와 `쓰기 버퍼링`이라는 두 가지 용도가 있다.


> 버퍼 풀 내부에서 최근 접근 여부에 따라서 데이터 페이지는 서로 `LRU`또는 `MRU`로 이동하는 것이다.  
> 그리고 InnoDB 스토리지 엔진은 `LRU`의 끝으로 밀려난 데이터 페이지들을 버퍼 풀에서 제거해서 새로운 데이터 페이지를 적재할 수 있는 빈 공간을 준비한다.  
> 새로운 페이지는 `New`,`Old` 서브 리스트의 `5/8지점`에 추가되며, 만약 캐시 히트가 된다면 `New`의 머리로 이동한다.  
> 결국 자주 쓰이지 않는 데이터 페이지는 `MRU`의 꼬리로 이동하게 되며, 결국 삭제된다

### Buffer Pool Flush

> 더티 페이지들을 성능에 문제없이 디스크에 동기화하기 위해 2개의 플러시 기능인 **Flush List 플러시**와 **LRU List 플러시**를 백그라운드로 실행한다.  

1. [x] InnoDB 스토리지 엔진은 주기적으로 **Flush List 플러시**함수를 호출해서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. 
   1. 오래된 리두 로그 공간을 지울려면 반드시 InnoDB 버퍼 풀의 데어터 페이지가 먼저 디스크로 동기화 돼야 한다.
   2. **클리너 스레드** : 더티 페이지를 디스크로 동기화하는 스레드 (클리너 스레드 개수 설정과 버퍼 풀의 개수 설정을 동일한 값으로 설정해라)
2. [x] InnoDB 스토리지 엔진은 `LRU 리스트`에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 공간을 만들기 위해 **LRU List 플러시** 함수가 사용된다.
   1. `LRU 리스트`의 끝부분부터 시작해서 시스템 변수에 설정된 개수만큼의 페이지들을 스캔하며 더티 페이지를 디스크에 동기화한다.
   2. **동기화된 클린 페이지는 즉시 `Free 리스트`로 페이지를 옮긴다.
3. [x] InnoDB 스토리지 엔진은 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에서 유지될 수 있도록 디스크 쓰기를 실행하는 **어댑티브 플러시 기능**이 있다.  

***

## Redo log

1. [x] **리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다.** 더티 페이지는 리두 로그에 무한정 머무를 수 없으므로, 기존에 기록됐던 로그 엔트리는 새로운 엔트리로 덮일 가능성이 있기 때문에, **재사용 가능한 공간**과 **당장 재사용 불가능한 공간**부분을 구분해서 관리한다.
   1. 재사용 불가능한 공간을 `활성 리두 로그(Active Redo Log)`라고 한다. (참조 하고있는 데이터 페이지를 가진 엔트리들)
   2. **InnoDB 스토리지 엔진은 체크 포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.**

> 리두 로그는 버퍼 풀의 **쓰기 버퍼링**을 위한 기능이다.  
> 리두 로그가 비약적으로 크다면 급작스럽게 디스크 기록이 폭증(`Disk IO Burst`)할 수 있다  
> 버퍼 풀의 더티 페이지가 `90%`를 넘어가게 되면 InnoDB 스토리지 엔진은 쓰기 작업을 한 번에 몰아서하므로 비율 설정을 적절히 설정하라

***

## Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기위해 페이지의 변경된 내용만 기록한다.
- 페이지가 일부만 기록되는 **Partial Page**또는 **Torn Page**현상이 발생을 대비하여 `Double-Write`기법을 이용한다.
  - 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 **시스템 테이블스페이스의 `Double Write Buffer`** 에 기록한다.
  - 그리고 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.
- 재시작될 때 항상 `Double Write Buffer`의 내용과 데이터 파일의 페이지들을 모두 비교하여 다르다면 데이터 파일의 페이지로 다시 복사한다.

***

## Undo log

- 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
  - **트랜잭션 보장** : 롤백 대비용
  - **격리 수준 보장** : 높은 동시성 제공 (트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그의 데이터를 읽기도 한다.)
- 원래는 언두 로그의 사용 공간을 줄일 수 없었지만 8.0부터 줄일 수 있다.
- 언두 로그 건수 조회 가능

> **Mysql 서버에서 `INSERT` 문장으로 인한 언두 로그와 `UPDATE`,`DELETE` 문장으로 인한 언두 로그는 별도로 관리된다.  
> `UPDATE`와 `DELETE` 문장으로 인한 언두 로그는 **MVCC와 데아터 복구(롤백 포함)에 모두 사용**되지만,  
> `INSERT`문장으로 인한 언두 로그는 **MVCC를 위해서는 사용되지 않고, 롤백이나 데이터 복구만을 위해서 사용**되기 때문이다.  
>  언두 로그의 건수에는 `UPDATE`와 `DELETE` 문장으로 인한 언두 로그 개수만 표시된다.

### Undo Tablespace

- Undo log가 저장되는 공간
