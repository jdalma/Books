<!-- TOC -->

- [버퍼 풀](#%EB%B2%84%ED%8D%BC-%ED%92%80)
    - [버퍼 풀 플러시](#%EB%B2%84%ED%8D%BC-%ED%92%80-%ED%94%8C%EB%9F%AC%EC%8B%9C)
- [리두 로그](#%EB%A6%AC%EB%91%90-%EB%A1%9C%EA%B7%B8)
- [Double Write Buffer](#double-write-buffer)
- [언두 로그](#%EC%96%B8%EB%91%90-%EB%A1%9C%EA%B7%B8)
    - [언두 테이블스페이스](#%EC%96%B8%EB%91%90-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4)
- [체인지 버퍼](#%EC%B2%B4%EC%9D%B8%EC%A7%80-%EB%B2%84%ED%8D%BC)
- [리두 로그 및 로그 버퍼](#%EB%A6%AC%EB%91%90-%EB%A1%9C%EA%B7%B8-%EB%B0%8F-%EB%A1%9C%EA%B7%B8-%EB%B2%84%ED%8D%BC)
- [리두 로그 아카이빙](#%EB%A6%AC%EB%91%90-%EB%A1%9C%EA%B7%B8-%EC%95%84%EC%B9%B4%EC%9D%B4%EB%B9%99)

<!-- /TOC -->


**dev mysql**  
- [버퍼풀](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)
- [glos page](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page)

1. [ ] "사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리할 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다" (83p)
   - 그럼 쓰기 작업은 버퍼에 담아 따로 처리할 수 있는 기능이 있다는 말이고, 읽기 작업은 스레드 캐시에 있는 스레드를 초과한 요청이 오면 스레드를 추가적으로 생성한다고 하는 것 같다
   - 추가적으로 생성된 스레드는 버려진다. 
   - "스레드 캐시에 지정한 개수 이상의 대기 중인 스레드가 있으면 스레드를 종료한다." (82p)
   - 에를 들어 최대 개수 4개의 스레드가 모두 쓰기 작업을 하고 있는 와중에 읽기 요청이 오면 쓰기 요청을 처리하고 있던 백그라운드 스레드는 어떻게 될까?
2. [ ] "`데이터 읽기/쓰기`작업은 대부분 1건의 레코드 단위" (87p)
   - 1건의 레코드 단위라는 말이 무슨 말이지?
3. [ ] `INSERT INTO ... SELECT` 는 어떤 스레드가 사용되나
4. [ ] 컴포넌트 아키텍처
5. [x] "제한된 수의 스레드 만으로 CPU가 처리하도록 적절히 유도한다면 CPU의 프로세서 친화도도 높이고 운영체제 입장에서는 불필요한 `컨텍스트 스위치`를 줄여서 오버헤드를 낮출 수 있다." (94p)
   - "MySQL 서버는 프로세스 기반이 아니라 **스레드 기반으로 작동하며**.." (80p)를 보면 위에서 말한  `컨텍스트 스위치`는 프로세서간이 아니라 스레드간 문맥 전환을 말하는 것 같다.
   - 그리고 "스레드 풀의 개수를 CPU 코어 개수와 비슷하게 설정하면 오버헤드를 낮출 수 있다" 라는 말은 최대한 모든 요청을 병렬 처리하는것이 CPU의 오버헤드를 낮출 수 있다라고 이해했다.
   - 만약 스레드 풀의 개수를 CPU 코어의 개수보다 높게 설정한다면 동시 처리할 가능성이 있기 때문
6. [ ] "InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다." (99p)
   - 서로 다른 테이블이 키들이 같은 컬럼이라면?
   - 기준이라는 말이 무슨 뜻이지?
7. [ ] "프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다." (99p)
   - 세컨더리 인덱스?
   - 프라이머리 키의 값을 논리적인 주소로 사용?
8. [ ] 언두, 리두 로그

***

## 버퍼 풀

1. [ ] InnoDB 스토리지 엔진은 크게 `LRU 리스트`와 `Flush 리스트` 그리고 `Free 리스트`라는 3개의 자료구조를 관리한다. (109p)
   1. `Free 리스트` : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다
   2. `LRU 리스트` : 엄밀하게 `MRU (Most Recently Used)`리스트가 결합된 형태이다.
      1. **Old 서브리스트**영역은 `LRU`에 해당하며, **New 서브리스트**영역은 `MRU`에 해당된다.
   3. `Flush 리스트` : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(`더티 페이지`)의 변경 시점 기준의 페이지 목록을 관리한다.
      1. 한 번이라고 데이터가 변경된 데이터 페이지는 플러시 리스트에 관리되고, **특정 시점이 되면 디스크로 기록돼야 한다.**
      2. 데이터가 변경되면 InnoDB는 변경 내용을 **리두 로그**에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
2. [x] InnoDB 스토리지 엔진에서 데이터를 찾는 과정
   1. **필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사**
      1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
      2. 해당 테이블의 인덱스(`B-Tree`)를 이용해 버퍼 풀에서 페이지를 검색
      3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 `MRU`방향으로 승급
   2. **디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 `LRU`헤더 부분에 추가**
   3. **버퍼 풀의 `LRU` 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 `MRU` 헤더 부분으로 이동**
      1. [ ] `Read Ahead`와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우에 `MRU`로 이동되지 않음 
   4. **버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 `나이`가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 `나이`가 오래되고(`Aging`이라고 함) 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지는 쿼리에 의해 사용되면 나이가 초기화되며, 이런 경우에는 `MRU`의 헤더 부분으로 옮겨진다.**
   5. **필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가**
3. [ ] 버퍼 풀은 여러 개로 쪼개어 관리할 수 있는데, 여러 데이터 페이지들은 버퍼 풀에 속한다. `LRU 리스트`와 `Flush 리스트` 그리고 `Free 리스트`라는 3개의 자료구조 
4. [ ] 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다. 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
   1. **엔트리**??
5. [x] InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 `데이터 캐시`와 `쓰기 버퍼링`이라는 두 가지 용도가 있다.


> 버퍼 풀 내부에서 최근 접근 여부에 따라서 데이터 페이지는 서로 `LRU`또는 `MRU`로 이동하는 것이다.  
> 그리고 InnoDB 스토리지 엔진은 `LRU`의 끝으로 밀려난 데이터 페이지들을 버퍼 풀에서 제거해서 새로운 데이터 페이지를 적재할 수 있는 빈 공간을 준비한다.  
> 새로운 페이지는 `New`,`Old` 서브 리스트의 `5/8지점`에 추가되며, 만약 캐시 히트가 된다면 `New`의 머리로 이동한다.  
> 결국 자주 쓰이지 않는 데이터 페이지는 `MRU`의 꼬리로 이동하게 되며, 결국 삭제된다

### 버퍼 풀 플러시

> 더티 페이지들을 성능에 문제없이 디스크에 동기화하기 위해 2개의 플러시 기능인 **Flush List 플러시**와 **LRU List 플러시**를 백그라운드로 실행한다.  

1. [x] InnoDB 스토리지 엔진은 주기적으로 **Flush List 플러시**함수를 호출해서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. 
   1. 오래된 리두 로그 공간을 지울려면 반드시 InnoDB 버퍼 풀의 데어터 페이지가 먼저 디스크로 동기화 돼야 한다.
   2. **클리너 스레드** : 더티 페이지를 디스크로 동기화하는 스레드 (클리너 스레드 개수 설정과 버퍼 풀의 개수 설정을 동일한 값으로 설정해라)
2. [x] InnoDB 스토리지 엔진은 `LRU 리스트`에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 공간을 만들기 위해 **LRU List 플러시** 함수가 사용된다.
   1. `LRU 리스트`의 끝부분부터 시작해서 시스템 변수에 설정된 개수만큼의 페이지들을 스캔하며 더티 페이지를 디스크에 동기화한다.
   2. **동기화된 클린 페이지는 즉시 `Free 리스트`로 페이지를 옮긴다.
3. [x] InnoDB 스토리지 엔진은 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에서 유지될 수 있도록 디스크 쓰기를 실행하는 **어댑티브 플러시 기능**이 있다.  

***

## 리두 로그

1. [x] **리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다.** 더티 페이지는 리두 로그에 무한정 머무를 수 없으므로, 기존에 기록됐던 로그 엔트리는 새로운 엔트리로 덮일 가능성이 있기 때문에, **재사용 가능한 공간**과 **당장 재사용 불가능한 공간**부분을 구분해서 관리한다.
   1. 재사용 불가능한 공간을 `활성 리두 로그(Active Redo Log)`라고 한다. (참조 하고있는 데이터 페이지를 가진 엔트리들)
   2. **InnoDB 스토리지 엔진은 체크 포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.**

> 리두 로그는 버퍼 풀의 **쓰기 버퍼링**을 위한 기능이다.  
> 리두 로그가 비약적으로 크다면 급작스럽게 디스크 기록이 폭증(`Disk IO Burst`)할 수 있다  
> 버퍼 풀의 더티 페이지가 `90%`를 넘어가게 되면 InnoDB 스토리지 엔진은 쓰기 작업을 한 번에 몰아서하므로 비율 설정을 적절히 설정하라

***

## Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기위해 페이지의 변경된 내용만 기록한다.
- 페이지가 일부만 기록되는 **Partial Page**또는 **Torn Page**현상이 발생을 대비하여 `Double-Write`기법을 이용한다.
  - 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 **시스템 테이블스페이스의 `Double Write Buffer`** 에 기록한다.
  - 그리고 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.
- 재시작될 때 항상 `Double Write Buffer`의 내용과 데이터 파일의 페이지들을 모두 비교하여 다르다면 데이터 파일의 페이지로 다시 복사한다.

***

## 언두 로그

- 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
  - **트랜잭션 보장** : 롤백 대비용
  - **격리 수준 보장** : 높은 동시성 제공 (트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그의 데이터를 읽기도 한다.)
- 트랜잭션의 생명주기가 길면 언두 로그 저장 공간이 늘어나는 것은 큰 문제가 안될수도 있지만, 그동안 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 언두 로그의 이력을 필요한 만큼 스캔해야만 하기 떄문에 성능이 떨어진다.
- 원래는 언두 로그의 사용 공간을 줄일 수 없었지만 8.0부터 줄일 수 있다.
- 언두 로그 건수 조회 가능
  
> **Mysql 서버에서 `INSERT` 문장으로 인한 언두 로그와 `UPDATE`,`DELETE` 문장으로 인한 언두 로그는 별도로 관리된다.  
> `UPDATE`와 `DELETE` 문장으로 인한 언두 로그는 **MVCC와 데아터 복구(롤백 포함)에 모두 사용**되지만,  
> `INSERT`문장으로 인한 언두 로그는 **MVCC를 위해서는 사용되지 않고, 롤백이나 데이터 복구만을 위해서 사용**되기 때문이다.  
>  언두 로그의 건수에는 `UPDATE`와 `DELETE` 문장으로 인한 언두 로그 개수만 표시된다.

### 언두 테이블스페이스

- 8.0부터 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선됐으며, 그 파일을 언두 테이블스페이스 라고 한다.
- 하나의 언두 테이블스페이스에는 1개 이상 128개 이하의 **롤백 세그먼트**를 가지며, 롤백 세그먼트는 1개 이상의 **언두 슬롯**을 가진다.
- **언두 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.**
  - `CREATE UNDO TABLESPACE`나 `DROP TABLESPACE`같은 명령으로 새로운 언두 테이블스페이스를 추가하고 삭제할 수 있다.
  - 공간을 필요한만큼 남기고 과도하게 할당된 공간을 운영체제로 반납하는 것을 `Undo tablespace turncate`라고 하며 , 이 방식에는 **자동**,**수동**으로 나뉜다.
    - **자동** : 퍼지 스레드는 주기적으로 깨어나서 언두 로그 공간에서 불필요한 언두 로그를 삭제하는 작업을 한다.
    - **수동** : 언두 테이블스페이스를 비활성화하면 퍼지 스레드가 정리한다.

> **최대 동시 트랜잭션 수** : (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)

***

## 체인지 버퍼

- 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.
- 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면은 바로 업데이트를 수행하지만, 버퍼 풀에 존재하지 않으면 디스크에서 읽어와서 업데이트 해야한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하게 된다.
- 이 때 사용하는 임시 메모리를 **체인지 버퍼**라고 한다.
  - 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
- InnoDB 버퍼 풀로 설정된 메모리 공간의 `25%`까지 사용할 수 있게 설정되어 있다. 필요하다면 `50%`까지 설정 가능하다.

***

## 리두 로그 및 로그 버퍼

- 리두 로그는 트랜잭션의 4가지 요소인 `ACID` 중에서 `D (Durable)`에 해당하는 영속성과 가장 밀접하게 연관돼 있다.
- 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다.
  1. **커밋됐지만 데이터 파일에 기록되지 않은 데이터**
  2. **롤백됐지만 데이터 파일에 이미 기록된 데이터** : 이 경우에는 리두 로그로만 해결할 수 없고, 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다.
- 리두 로그 버퍼링에 사용되는 공간이 **로그 버퍼**다.
- **데이터베이스 서버에서 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.** 하지만 많은 부하를 유발한다.
  - 어느 주기로 동기화할지를 설정할 수 있다 `innodb_flush_log_at_trx_commit`
- 대부분의 DB는 변경 내용을 로그로 먼저 기록한다.
- 성능을 위해 리두 로그를 버퍼링할 수 있는 **InnoDB 버퍼 풀**이나 **리두 로그 버퍼**와 같은 자료 구조도 가지고 있다.

***

## 리두 로그 아카이빙

- 8.0 부터 InnoDB 스토리지 엔진의 **리두 로그를 아카이빙할 수 있는 기능이 추가됐다.**

