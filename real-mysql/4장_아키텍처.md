<!-- TOC -->

    - [버퍼 풀](#%EB%B2%84%ED%8D%BC-%ED%92%80)
        - [버퍼 풀 플러시](#%EB%B2%84%ED%8D%BC-%ED%92%80-%ED%94%8C%EB%9F%AC%EC%8B%9C)
    - [리두 로그](#%EB%A6%AC%EB%91%90-%EB%A1%9C%EA%B7%B8)
    - [Double Write Buffer](#double-write-buffer)
    - [언두 로그](#%EC%96%B8%EB%91%90-%EB%A1%9C%EA%B7%B8)
        - [언두 테이블스페이스](#%EC%96%B8%EB%91%90-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4)
    - [체인지 버퍼](#%EC%B2%B4%EC%9D%B8%EC%A7%80-%EB%B2%84%ED%8D%BC)
    - [리두 로그 및 로그 버퍼](#%EB%A6%AC%EB%91%90-%EB%A1%9C%EA%B7%B8-%EB%B0%8F-%EB%A1%9C%EA%B7%B8-%EB%B2%84%ED%8D%BC)
        - [리두 로그 아카이빙](#%EB%A6%AC%EB%91%90-%EB%A1%9C%EA%B7%B8-%EC%95%84%EC%B9%B4%EC%9D%B4%EB%B9%99)
    - [어댑티브 해시 인덱스](#%EC%96%B4%EB%8C%91%ED%8B%B0%EB%B8%8C-%ED%95%B4%EC%8B%9C-%EC%9D%B8%EB%8D%B1%EC%8A%A4)
    - [InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교](#innodb%EC%99%80-myisam-memory-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EB%B9%84%EA%B5%90)
- [MySQL 로그 파일](#mysql-%EB%A1%9C%EA%B7%B8-%ED%8C%8C%EC%9D%BC)
    - [에러 로그 파일](#%EC%97%90%EB%9F%AC-%EB%A1%9C%EA%B7%B8-%ED%8C%8C%EC%9D%BC)
    - [제너럴 쿼리 로그 파일](#%EC%A0%9C%EB%84%88%EB%9F%B4-%EC%BF%BC%EB%A6%AC-%EB%A1%9C%EA%B7%B8-%ED%8C%8C%EC%9D%BC)
    - [슬로우 쿼리 로그](#%EC%8A%AC%EB%A1%9C%EC%9A%B0-%EC%BF%BC%EB%A6%AC-%EB%A1%9C%EA%B7%B8)

<!-- /TOC -->


**dev mysql**  
- [버퍼풀](https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html)
- [glos page](https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_page)

1. [ ] "사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리할 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다" (83p)
   - 그럼 쓰기 작업은 버퍼에 담아 따로 처리할 수 있는 기능이 있다는 말이고, 읽기 작업은 스레드 캐시에 있는 스레드를 초과한 요청이 오면 스레드를 추가적으로 생성한다고 하는 것 같다
   - 추가적으로 생성된 스레드는 버려진다. 
   - "스레드 캐시에 지정한 개수 이상의 대기 중인 스레드가 있으면 스레드를 종료한다." (82p)
   - 에를 들어 최대 개수 4개의 스레드가 모두 쓰기 작업을 하고 있는 와중에 읽기 요청이 오면 쓰기 요청을 처리하고 있던 백그라운드 스레드는 어떻게 될까?
2. [ ] "`데이터 읽기/쓰기`작업은 대부분 1건의 레코드 단위" (87p)
   - 1건의 레코드 단위라는 말이 무슨 말이지?
3. [ ] `INSERT INTO ... SELECT` 는 어떤 스레드가 사용되나
4. [ ] 컴포넌트 아키텍처
5. [x] "제한된 수의 스레드 만으로 CPU가 처리하도록 적절히 유도한다면 CPU의 프로세서 친화도도 높이고 운영체제 입장에서는 불필요한 `컨텍스트 스위치`를 줄여서 오버헤드를 낮출 수 있다." (94p)
   - "MySQL 서버는 프로세스 기반이 아니라 **스레드 기반으로 작동하며**.." (80p)를 보면 위에서 말한  `컨텍스트 스위치`는 프로세서간이 아니라 스레드간 문맥 전환을 말하는 것 같다.
   - 그리고 "스레드 풀의 개수를 CPU 코어 개수와 비슷하게 설정하면 오버헤드를 낮출 수 있다" 라는 말은 최대한 모든 요청을 병렬 처리하는것이 CPU의 오버헤드를 낮출 수 있다라고 이해했다.
   - 만약 스레드 풀의 개수를 CPU 코어의 개수보다 높게 설정한다면 동시 처리할 가능성이 있기 때문
6. [ ] "InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다." (99p)
   - 서로 다른 테이블이 키들이 같은 컬럼이라면?
   - 기준이라는 말이 무슨 뜻이지?
7. [ ] "프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며, 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다." (99p)
   - 세컨더리 인덱스?
   - 프라이머리 키의 값을 논리적인 주소로 사용?
8. [ ] 언두, 리두 로그

***

## 버퍼 풀

1. [ ] InnoDB 스토리지 엔진은 크게 `LRU 리스트`와 `Flush 리스트` 그리고 `Free 리스트`라는 3개의 자료구조를 관리한다. (109p)
   1. `Free 리스트` : InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록이며, 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다
   2. `LRU 리스트` : 엄밀하게 `MRU (Most Recently Used)`리스트가 결합된 형태이다.
      1. **Old 서브리스트**영역은 `LRU`에 해당하며, **New 서브리스트**영역은 `MRU`에 해당된다.
   3. `Flush 리스트` : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(`더티 페이지`)의 변경 시점 기준의 페이지 목록을 관리한다.
      1. 한 번이라고 데이터가 변경된 데이터 페이지는 플러시 리스트에 관리되고, **특정 시점이 되면 디스크로 기록돼야 한다.**
      2. 데이터가 변경되면 InnoDB는 변경 내용을 **리두 로그**에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
2. [x] InnoDB 스토리지 엔진에서 데이터를 찾는 과정
   1. **필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사**
      1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
      2. 해당 테이블의 인덱스(`B-Tree`)를 이용해 버퍼 풀에서 페이지를 검색
      3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 `MRU`방향으로 승급
   2. **디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 `LRU`헤더 부분에 추가**
   3. **버퍼 풀의 `LRU` 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 `MRU` 헤더 부분으로 이동**
      1. [ ] `Read Ahead`와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우에 `MRU`로 이동되지 않음 
   4. **버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 `나이`가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 `나이`가 오래되고(`Aging`이라고 함) 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지는 쿼리에 의해 사용되면 나이가 초기화되며, 이런 경우에는 `MRU`의 헤더 부분으로 옮겨진다.**
   5. **필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가**
3. [ ] 버퍼 풀은 여러 개로 쪼개어 관리할 수 있는데, 여러 데이터 페이지들은 버퍼 풀에 속한다. `LRU 리스트`와 `Flush 리스트` 그리고 `Free 리스트`라는 3개의 자료구조 
4. [ ] 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다. 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결된다.
   1. **엔트리**??
5. [x] InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 `데이터 캐시`와 `쓰기 버퍼링`이라는 두 가지 용도가 있다.


> 버퍼 풀 내부에서 최근 접근 여부에 따라서 데이터 페이지는 서로 `LRU`또는 `MRU`로 이동하는 것이다.  
> 그리고 InnoDB 스토리지 엔진은 `LRU`의 끝으로 밀려난 데이터 페이지들을 버퍼 풀에서 제거해서 새로운 데이터 페이지를 적재할 수 있는 빈 공간을 준비한다.  
> 새로운 페이지는 `New`,`Old` 서브 리스트의 `5/8지점`에 추가되며, 만약 캐시 히트가 된다면 `New`의 머리로 이동한다.  
> 결국 자주 쓰이지 않는 데이터 페이지는 `MRU`의 꼬리로 이동하게 되며, 결국 삭제된다

### 버퍼 풀 플러시

> 더티 페이지들을 성능에 문제없이 디스크에 동기화하기 위해 2개의 플러시 기능인 **Flush List 플러시**와 **LRU List 플러시**를 백그라운드로 실행한다.  

1. [x] InnoDB 스토리지 엔진은 주기적으로 **Flush List 플러시**함수를 호출해서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다. 
   1. 오래된 리두 로그 공간을 지울려면 반드시 InnoDB 버퍼 풀의 데어터 페이지가 먼저 디스크로 동기화 돼야 한다.
   2. **클리너 스레드** : 더티 페이지를 디스크로 동기화하는 스레드 (클리너 스레드 개수 설정과 버퍼 풀의 개수 설정을 동일한 값으로 설정해라)
2. [x] InnoDB 스토리지 엔진은 `LRU 리스트`에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 공간을 만들기 위해 **LRU List 플러시** 함수가 사용된다.
   1. `LRU 리스트`의 끝부분부터 시작해서 시스템 변수에 설정된 개수만큼의 페이지들을 스캔하며 더티 페이지를 디스크에 동기화한다.
   2. **동기화된 클린 페이지는 즉시 `Free 리스트`로 페이지를 옮긴다.
3. [x] InnoDB 스토리지 엔진은 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에서 유지될 수 있도록 디스크 쓰기를 실행하는 **어댑티브 플러시 기능**이 있다.  

***

## 리두 로그

1. [x] **리두 로그는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용한다.** 더티 페이지는 리두 로그에 무한정 머무를 수 없으므로, 기존에 기록됐던 로그 엔트리는 새로운 엔트리로 덮일 가능성이 있기 때문에, **재사용 가능한 공간**과 **당장 재사용 불가능한 공간**부분을 구분해서 관리한다.
   1. 재사용 불가능한 공간을 `활성 리두 로그(Active Redo Log)`라고 한다. (참조 하고있는 데이터 페이지를 가진 엔트리들)
   2. **InnoDB 스토리지 엔진은 체크 포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.**

> 리두 로그는 버퍼 풀의 **쓰기 버퍼링**을 위한 기능이다.  
> 리두 로그가 비약적으로 크다면 급작스럽게 디스크 기록이 폭증(`Disk IO Burst`)할 수 있다  
> 버퍼 풀의 더티 페이지가 `90%`를 넘어가게 되면 InnoDB 스토리지 엔진은 쓰기 작업을 한 번에 몰아서하므로 비율 설정을 적절히 설정하라

***

## Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기위해 페이지의 변경된 내용만 기록한다.
- 페이지가 일부만 기록되는 **Partial Page**또는 **Torn Page**현상이 발생을 대비하여 `Double-Write`기법을 이용한다.
  - 실제 데이터 파일에 변경 내용을 기록하기 전에 더티 페이지를 우선 묶어서 한 번의 디스크 쓰기로 **시스템 테이블스페이스의 `Double Write Buffer`** 에 기록한다.
  - 그리고 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.
- 재시작될 때 항상 `Double Write Buffer`의 내용과 데이터 파일의 페이지들을 모두 비교하여 다르다면 데이터 파일의 페이지로 다시 복사한다.

***

## 언두 로그

- 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
  - **트랜잭션 보장** : 롤백 대비용
  - **격리 수준 보장** : 높은 동시성 제공 (트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그의 데이터를 읽기도 한다.)
- 트랜잭션의 생명주기가 길면 언두 로그 저장 공간이 늘어나는 것은 큰 문제가 안될수도 있지만, 그동안 빈번하게 변경된 레코드를 조회하는 쿼리가 실행되면 언두 로그의 이력을 필요한 만큼 스캔해야만 하기 떄문에 성능이 떨어진다.
- 원래는 언두 로그의 사용 공간을 줄일 수 없었지만 8.0부터 줄일 수 있다.
- 언두 로그 건수 조회 가능
  
> **Mysql 서버에서 `INSERT` 문장으로 인한 언두 로그와 `UPDATE`,`DELETE` 문장으로 인한 언두 로그는 별도로 관리된다.  
> `UPDATE`와 `DELETE` 문장으로 인한 언두 로그는 **MVCC와 데아터 복구(롤백 포함)에 모두 사용**되지만,  
> `INSERT`문장으로 인한 언두 로그는 **MVCC를 위해서는 사용되지 않고, 롤백이나 데이터 복구만을 위해서 사용**되기 때문이다.  
>  언두 로그의 건수에는 `UPDATE`와 `DELETE` 문장으로 인한 언두 로그 개수만 표시된다.

### 언두 테이블스페이스

- 8.0부터 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선됐으며, 그 파일을 언두 테이블스페이스 라고 한다.
- 하나의 언두 테이블스페이스에는 1개 이상 128개 이하의 **롤백 세그먼트**를 가지며, 롤백 세그먼트는 1개 이상의 **언두 슬롯**을 가진다.
- **언두 슬롯이 부족한 경우에는 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다.**
  - `CREATE UNDO TABLESPACE`나 `DROP TABLESPACE`같은 명령으로 새로운 언두 테이블스페이스를 추가하고 삭제할 수 있다.
  - 공간을 필요한만큼 남기고 과도하게 할당된 공간을 운영체제로 반납하는 것을 `Undo tablespace turncate`라고 하며 , 이 방식에는 **자동**,**수동**으로 나뉜다.
    - **자동** : 퍼지 스레드는 주기적으로 깨어나서 언두 로그 공간에서 불필요한 언두 로그를 삭제하는 작업을 한다.
    - **수동** : 언두 테이블스페이스를 비활성화하면 퍼지 스레드가 정리한다.

> **최대 동시 트랜잭션 수** : (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)

***

## 체인지 버퍼

- 레코드가 INSERT 되거나 UPDATE 될 때는 **데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.**
- 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면은 바로 업데이트를 수행하지만, 버퍼 풀에 존재하지 않으면 디스크에서 읽어와서 업데이트 해야한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환하게 된다.
- 이 때 사용하는 임시 메모리를 **체인지 버퍼**라고 한다.
  - 유니크 인덱스는 체인지 버퍼를 사용할 수 없다.
- 체인지 버퍼에 임시로 저장된 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 **체인지 버퍼 머지 스레드**라고 한다.
- InnoDB 버퍼 풀로 설정된 메모리 공간의 `25%`까지 사용할 수 있게 설정되어 있다. 필요하다면 `50%`까지 설정 가능하다.

***

## 리두 로그 및 로그 버퍼

- 리두 로그는 트랜잭션의 4가지 요소인 `ACID` 중에서 `D (Durable)`에 해당하는 영속성과 가장 밀접하게 연관돼 있다.
- 리두로그는 서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치다.
  1. **커밋됐지만 데이터 파일에 기록되지 않은 데이터**
  2. **롤백됐지만 데이터 파일에 이미 기록된 데이터** : 이 경우에는 리두 로그로만 해결할 수 없고, 변경되기 전 데이터를 가진 언두 로그의 내용을 가져와 데이터 파일에 복사하면 된다.
- 리두 로그 버퍼링에 사용되는 공간이 **로그 버퍼**다.
- **데이터베이스 서버에서 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장한다.** 하지만 많은 부하를 유발한다.
  - 어느 주기로 동기화할지를 설정할 수 있다 
  - `innodb_flush_log_at_trx_commit`의 기본 값은 1이다.
    - 매번 트랜잭션이 커밋될 때 마다 디스크로 기록되고 동기화까지 수행된다. 그래서 트랜잭션이 커밋되면 트랜잭션에서 변경한 데이터는 사라진다.
  - `innodb_log_files_in_group`의 기본 값은 2이다.
    - 리두 로그 파일의 개수
  - `innodb_log_file_size`의 기본 값은 50331648이다.
- 대부분의 DB는 변경 내용을 로그로 먼저 기록한다.
- 성능을 위해 리두 로그를 버퍼링할 수 있는 **InnoDB 버퍼 풀**이나 **리두 로그 버퍼**와 같은 자료 구조도 가지고 있다.
- **리두 로그 파일의 전체 크기가 InnoDB 버퍼 풀의 크기에 맞게 적절히 선택돼야 InnoDB 스토리지 엔진이 적절히 변경된 내용을 버퍼풀에 모았다가 한 번에 디스크에 기록할 수 있다.**

### 리두 로그 아카이빙

- 8.0 부터 InnoDB 스토리지 엔진의 **리두 로그를 아카이빙할 수 있는 기능이 추가됐다.**
- MySQL 엔터프라이즈 백업이나 Xtrabackup툴은 리두 로그 데이터 파일을 복사하는 동안 InnoDB 스토리지 엔진의 리두 로그에 쌓인 내용을 계속 추적하면서 새로 추가된 리두 로그 엔트리를 복사한다.
- 리두 로그 내용이 복사되기전에 덮어쓰인다면 백업에 실패하게 되는데 MySQL 8.0 리두 로그 아카이빙 기능은 이 문제 해결하여 준다.

> MySQL 서버는 항상 새롭게 시작될 때 리두 로그에서 데이터 파일에 기록되지 못한 데이터가 있는지 검사를 한다.  

***

## 어댑티브 해시 인덱스

- 일반적으로 `인덱스`라고 하면 이는 테이블에 사용자가 생성해둔 **B-Tree 인덱스**를 의미한다.
- 하지만 여기서 언급하는 **어댑티브 해시 인덱스**는 사용자가 수동으로 생성하는 인덱스가 아니라 **InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스** 이며, 사용자는 이 기능을 활성화하거나 비활성화 할 수 있다.
- B-Tree 인덱스에서 특정 값을 찾는 과정이 빠르냐 느리냐의 기준은 상대적인 것이며, 데이터베이스 서버가 얼마나 많은 일을 하느냐에 따라 B-Tree 인덱스에서 값을 찾는 과정이 느려질수도 있고 빨라질 수도 있다.
  - B-Tree 인덱스에서 특정 값을 찾기 위해서는 **루트 노드를 거쳐 브랜치 노드, 최종적으로 리프 노드까지 도달해야 원하는 레코드를 읽을 수 있다.**
- 어댑티브 해시 인데스는 B-Tree 검색 시간을 줄여주기 위해 도입되었으며, **자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때 마다 어댑티브 해시 인덱스를 검색해 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있다.**
  - `인덱스 키 값` : `데이터 페이지 주소`
  - `인덱스 키 값`이란 **B-Tree 인덱스의 고유 번호와 B-Tree 인덱스의 실제 키 값**조합으로 생성된다.
  - `데이터 페이지 주소`란 **InnoDB 버퍼 풀에 로딩된 페이지의 주소**를 의미한다. 버퍼 풀에 올려진 페이지에 대해서만 관리되고 버퍼 풀에 해당 페이지가 없어지면 어댑티브 해시 인덱스에서도 해당 페이지의 정보는 사라진다.
- InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재 한다. (파티션 기능이 있긴 하지만)
- 즉 모든 B-Tree 인덱스에 대한 어댑티브 해시 인덱스가 하나의 해시 인덱스에 저장되며, 특정 키 값이 어느 인덱스에 속한 것인지도 구분 해야하기 때문에 키를 생성할 때 **B-Tree 인덱스의 고유 번호**가 포함된다.
- 위에서 잠깐 말한 파티션 기능은 어댑티브 해시 인덱스의 내부 잠금(세마포어) 경합을 줄이기 위해 어댑티브 해시 인덱스의 파티션 기능을 제공한다.
  - `innodb_adaptive_hash_index` : ON
  - `innodb_adaptive_hash_index_parts` : 8
  
**어댑티브 해시 인덱스가 도움이 되지 않는 경우**  
1. 디스크 읽기가 많은 경우
2. 특정 패턴의 쿼리가 많은 경우 (JOIN이나 LIKE 패턴 검색)
3. 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
  
**어댑티브 해시 인덱스가 도움이 되는 경우**  
1. 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우 (디스크 읽기가 많지 않은 경우)
2. 동등 조건 검색 (동등 비교와 IN 연산자)이 많은 경우
3. 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

**어댑티브 해시 인덱스**는 데이터 페이지를 메모리(버퍼 풀)내에서 접근하는 것을 더 빠르게 만드는 기능이기 때문에 데이터 페이지를 디스크에서 읽어오는 경우가 빈번한 데이터베이스에서는 아무런 도움도 되지 않는다.  
또한 저장 공간인 메모리를 사용하며, 때로는 상당히 큰 공간을 차지할 수도 있다.  
  
테이블을 삭제하거나 변경하려 할 때 InnoDB 스토리지 엔진은 이 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거해야 한다.  

```mysql
SHOW ENGINE INNODB STATUS \G

-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 4 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 0 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
Hash table size 34679, node heap has 1 buffer(s)
1.03 hash searches/s, 2.64 non-hash searches/s
```

초당 `3.67`의 검색이 실행됐는데, 그중 `1.03`번은 어댑티브 해시 인덱스를 사용했으며, `2.64`번은 사용하지 못 했다는 뜻이다.  
`searches`는 쿼리가 처리되기 위해 내부적으러 키 값의 검색이 몇 번 실행됐는지를 의미한다.  
  
***

## InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

- MySQL 8.0에서는 MyISAM은 현재 도태되고 있는 상황이며, MyISAM이나 MEMORY 스토리지 엔진에 대한 성능상 장점을 비교하는 것은 무의미하다고 보인다.
- 사용자의 쿼리를 처리하기 위해 내부적으로 임시 테이블을 사용할 때에 MEMORY 스토리지 엔진이 내부 임시 테이블의 용도로 사용되었지만 가변 길이 타입의 컬럼을 지원하지 않는다는 문제점 때문에 MySQL 8.0부터는 `TempTable` 스토리지 엔진이 사용되고 있다.

***

# MySQL 로그 파일

## 에러 로그 파일

- MySQL 설정 파일 (my.cnf)에서 `log_error`라는 이름의 파라미터로 정의된 경로에 생성된다.
- 별도로 정의되지 않은 경우에는 데이터 디렉터리(datadir 파라미터에 설정된 디렉터리)에 `.err`라는 확장자가 붙은 파일로 생성된다.
- 에러 로그에 대한 상세 내용은 MySQL 메뉴얼의 `The Error Log`절을 확인하자
  
**메시지 내용**
1. MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지
   - MySQL 서버가 정상적으로 기동됐는지 `mysqld: ready for connections` 메시지 확인
2. 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
   - 디스크에 기록되지 못한 데이터가 있다면 다시 기록하는 재처리 작업을 하게 된다.
3. 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
4. 비정상적으로 종료된 커넥션 메시지
   - Aborted Connection
5. InnoDB의 모니터링 또는 상태 조회 명령 (SHOW ENGINE INNODB STATUS \G 같은) 결과 메시지
   - InnoDB의 테이블 모니터링이나 락 모니터링, 또는 InnoDB의 엔진 상태를 조회하는 명령은 큰 메시지를 에러 로그 파일에 기록하기 때문에 모니터링을 사용한 이후에는 다시 비활성화 해야한다.
6. MySQL의 종료 메시지
   - 비정상적으로 종료됐을 경우 확인할 수 있는 유일한 방법이다.
   - 누군가가 종료시켰다면 `Received SHUTDOWN from user ...`이라는 메시지를 확인할 수 있다.
   - 아무런 종료 관련 메시지가 없거나 스택 트레이스 (대표적으로 16진수의 주솟값이 잔뜩 출력되는) 내용이 출력되는 경우에는 `Segmentation fault`로 비정상적으로 종료된 것으로 판단할 수 있다.

## 제너럴 쿼리 로그 파일

쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일로 기록한 다음 파일을 검토할 수 있다.  
**쿼리 요청을 받으면 실행되기 전에 바로 기록하기 때문에 에러가 발생해도 일단 기록된다.**  
상세한 내용은 MySQL 메뉴얼의 `log_output 설정 파라미터`와 `The General Query Log`절을 참조하자.  
추가로 [Selecting General Query and Slow Query Log Output Destinations](https://dev.mysql.com/doc/refman/8.0/en/log-destinations.html)를 참조하자.

## 슬로우 쿼리 로그

`long_query_time` 변수에 설정한 시간 이상아 소요된 (정상적으로 실행이 완료된)쿼리가 모두 기록된다. 기본 값 10초  
로그 파일을 읽을 때 Percona Toolkit의 `pt-query-digest` 스크립트를 이용하면 쉽게 빈도나 처리 성능별로 쿼리를 정렬해서 살펴볼 수 있다.  
1. 슬로우 쿼리 통계
2. 실행 빈도 및 누적 실행 시간순 랭킹
3. 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보
등을 볼 수 있다.  

