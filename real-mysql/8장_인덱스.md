
MySQL에서 사용 가능한 인덱스의 종류 및 특성을 간단히 알아보자  
각 인덱스의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 될 것이다.  
**전문 검색**이나 **위치 기반 검색** 기능도 모두 InnoDB에서 사용할 수 있게 개선됐다.  


# 디스크 읽기 방식

데이터베이스의 성능 튜닝은 **어떻게 디스크 I/O를 줄이느냐**가 관건일 때가 상당히 많다.  

- **Random I/O 와 Sequence I/O**
  - 하드 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 **Random I/O**라고 한다.
  - **Sequence I/O** 또한 이 작업과정은 같지만 **Sequence I/O**는 3개의 페이지를 디스크에 기록하기 위해 `한 번 시스템 콜`을 요청하지만, (헤드를 한 번 움직인다.)
  - **Random I/O**는 3개의 페이지를 디스크에 기록하기 위해 `세 번 시스템 콜`을 요청한다. (헤드를 세 번 움직인다.)
- **HDD 와 SSD**
  - SSD의 장점은 HDD보다 **Random I/O**가 훨씬 빠르다는 것이다.  
  - 데이터베이스 서버에서 **Sequence I/O**작업은 그다지 비중이 크지 않고, **Random I/O**를 통해 `작은 데이터를 읽고 쓰는 작업이 대부분`이므로 DBMS용 스토리지에 최적이다.  
  - SSD는 Random I/O와 Sequence I/O의 차이가 없을 것으로 예상하지만, **여전히 Random I/O가 Sequence I/O보다 전체 Throughput이 떨어진다.**
  
쿼리를 튜닝해서 Random I/O를 Sequence I/O로 바꿔서 실행할 방법은 그다지 많지 않고,  
**쿼리 튜닝이란 꼭 필요한 데이터만 읽도록 쿼리를 개선하여 `Random I/O 자체를 줄여주는것이 목적`이다.**  
- **인덱스 레인지 스캔**은 데이터를 읽기 위해 주로 `Random I/O`를 사용
- **풀 테이블 스캔**은 `Sequence I/O`를 사용
  
Sequence I/O가 Random I/O 보다 훨씬 빨리 많은 레코드를 읽을 수 있기 때문에 **큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있다.**  
- 웹 서비스보다는 데이터 웨어하우스나 통계 작업에서 자주 사용된다.

> 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL 서버에는 **그룹 커밋**이나 **바이너리 로그 버퍼** 또는 **InnoDB 로그 버퍼** 등의 기능이 내장되어 있다.

# 인덱스란?

데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.  
그래서 **컬럼의 값과 해당 레코드가 저장된 주소**를 `키와 값의 쌍 (key-value pair)`으로 삼아 인덱스를 만들어 두는 것이다.  
책의 목차가 `ㄱ,ㄴ,ㄷ..`순으로 되듯이, 인덱스도 마찬가지로 **컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.**  
  
자료구조에 비교하자면 `SortedList`가 **DBMS의 인덱스과 같은 자료구조 이다.**  
이미 정렬이 되어 있어 원하는 값을 아주 빨리 찾아오지만, 저장될때마다 항상 값을 정렬해야 하므로 과정이 복잡하고 느리다.  

> DBMS에서 인덱스는 데이터의 저장 (INSERT, UPDATE, DELETE) 성능을 희생하고 **데이터의 읽기 속도를 높이는 기능**이다.  
> 테이블에서 인덱스를 하나 더 추가할지 말지는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하느냐에 따라 결정해야 한다.  

  
**인덱스는 `데이터를 관리하는 방식(알고리즘)`과 `중복 값의 허용 여부` 등에 따라 여러 가지로 나눠볼 수 있다.**  
프라이머리 키를 제외한 나머지 모든 인덱스는 **세컨더리 인덱스**로 분류한다.  
- 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 `대체 키`라고도 하고 세컨더리 인덱스로 분류하기도 한다.  
  
여기서 **중복 값의 허용 여부**는 단순히 같은 값이 1개만 존재하는지, 1개 이상 존재할 수 있는지를 의미하지만,  
**실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제다.**  
유니크 인덱스로 인한 MySQL 처리 방식의 변화나 차이점이 상당히 많다.  
이러한 부분은 **인덱스**와 **쿼리의 실행 계획**을 살펴보면서 배워보자  
  
대표적으로 **B-Tree 인덱스**와 **Hash 인덱스**로 구분할 수 있다.  
- 최근에는 **Fractal-Tree 인덱스**나 로그 기반의 **Merge-Tree 인덱스**와 같은 알고리즘을 사용하는 DBMS도 개발되고 있다.
  
## B-Tree 인덱스

> `B-Tree 알고리즘`은 가장 일반적으로 사용되는 인덱스 알고리즘으로서, 오래된 만큼 성숙해진 상태다.  
> **컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘**이다.  
> 위치 기반 검색을 지원하기 위한 `R-Tree 인덱스 알고리즘`도 있지만, B-Tree의 응용 알고리즘으로 볼 수 있다.

## Hash 인덱스

> `Hash 인덱스 알고리즘`은 **컬럼의 값으로 해시값을 계산해서 인덱싱 하는 알고리즘**으로, **매우 빠른 검색을 지원한다.**  
> 하지만 값을 변형해서 인덱싱하므로 **전방(prefix) 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.**  
> 주로 **메모리 기반의 데이터베이스에서 많이 사용한다.**

