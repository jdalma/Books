
# 1주차

> 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 생성자가 존재한다.  
> 생성자의 주된 임무는 제공된 인자를 사용해서 캡슐화된 프로퍼티를 초기화하는 것이고, 메서드의 수가 많을수록 SRP을 위반할 확률이 높지만 생성자는 많을수록 클라이언트가 유연하게 사용할 수 있다.  

1. 코틀린스럽게 작성하는 것이 아직 익숙하지 않다.
   1. require, check, backing fields
2. [검증부는 하드코딩 한다.](https://jojoldu.tistory.com/615?category=1036934)
3. 입출력 로직과 비즈니스 로직이 뒤섞여 있다.
4. 테스트하기 쉽게 만들려면 주입이 가능하도록 해야한다.
   1. 이번 과제에서 핵심은 랜덤 값을 만들어내는 부분을 최대한 밖으로 끌어내기 위해 **객체 그래프** 를 활용하여 주입할 지점을 찾는 것이다.
5. 코틀린 클래스는 프로퍼티, 초기화 블록, 부 생성자, 함수, 동반 객체 순으로 작성하는 것이 컨벤션이다.
6. 코틀린은 기본적으로 프로퍼티 기반인 것을 명심해라.
7. 코틀린과 자바와 같이 쓸 수 밖에 없는 환경이라면 어노테이션의 기능에 관심가져라
   1. @JvmField, @PublishedApi, @file:JvmName("${name}")
8. `!!`를 사용하고 있는 것은 코틀린을 잘 못 쓰고 있다는 시그널이다.
9.  `!`을 플랫폼 타입이라고 한다.


# 2주차


10. JvmInline과 value class
12. 리스코프 치환 원칙을 위반한 예제
13. 상속이 문제가 아니라 상속을 잘 활용하는 것이 문제다.
14. 코틀린에서 Int와 Integer를 처리하는 방법과 Int의 캐싱 범위 예제
15. 백킹 프로퍼티를 활용한 방어적 복사
16. [좋은 객체의 7가지 덕목](https://codingnuri.com/seven-virtues-of-good-object/)
17. [우아한객체지향 by 우아한형제들 개발실장 조영호](https://www.youtube.com/watch?v=dJ5C4qRqAgA&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC)
18. [Spring Batch를 더 우아하게 사용하기 - Spring Batch Plus](https://d2.naver.com/helloworld/9879422)

# 3주차

1. 수신 객체 지정 람다를 이용한 Kotlin DSL
11. Builder들의 책임과 비즈니스 로직에서 사용할 값 객체의 책임
   1. 마지막 주차 1단계 예제에서 PersonBuilder 내부 필드를 한 번에 초기화 하는 것이였는데 Skill과 Language 빌더들이 너무 더럽다고 느꼈지만 제이슨님은 PersonBuilder 자체가 더러움을 책임지는 객체라고 생각하셨다.
   2. 비즈니스 로직에서 관심가지는 것은 값 객체에 대한 정보이기 때문에 각 data class들이 불변 필드들을 가지고 있는것에 만족하셨다.


## 까다로운 것

1. 모든 플레이어들이 카드를 요청하여 받는 부분에서 `출력 → 입력 → 카드 배분 → 출력` 흐름을 따르는 부분이 입출력 로직과 비즈니스 로직을 문맥에 맞게 넘나들도록 해야하기 때문에 힘들었다.
   1. 딜러가 추가되면서 카드 받는 로직은 달라지지만 출력되는 부분은 같은 게임 플레이어로 인식해야하는 점
   2. 핵심은 딜러가 추가되면서 기존 플레이어와 중복되는 코드를 어떻게 제거할 것인가? abstract class? interface? sealed class?
2. 카드 점수 결과를 구분하는 것도 플레이어와 딜러가 서로 가지는 MatchResult가 달라서 봉인 클래스로 구분해서 사용했다. 괜찮은건가?