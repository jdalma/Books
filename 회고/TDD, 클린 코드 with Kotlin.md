
# 1주차

> 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 생성자가 존재한다.  
> 생성자의 주된 임무는 제공된 인자를 사용해서 캡슐화된 프로퍼티를 초기화하는 것이고, 메서드의 수가 많을수록 SRP을 위반할 확률이 높지만 생성자는 많을수록 클라이언트가 유연하게 사용할 수 있다.  

1. 코틀린스럽게 작성하는 것이 아직 익숙하지 않다.
   1. require, check, backing fields
2. [검증부는 하드코딩 한다.](https://jojoldu.tistory.com/615?category=1036934)
3. 입출력 로직과 비즈니스 로직이 뒤섞여 있다.
4. 테스트하기 쉽게 만들려면 주입이 가능하도록 해야한다.
   1. 이번 과제에서 핵심은 랜덤 값을 만들어내는 부분을 최대한 밖으로 끌어내기 위해 **객체 그래프** 를 활용하여 주입할 지점을 찾는 것이다.
5. 코틀린 클래스는 프로퍼티, 초기화 블록, 부 생성자, 함수, 동반 객체 순으로 작성하는 것이 컨벤션이다.
6. 코틀린은 기본적으로 프로퍼티 기반인 것을 명심해라.
7. 코틀린과 자바와 같이 쓸 수 밖에 없는 환경이라면 어노테이션의 기능에 관심가져라
   1. @JvmField, @PublishedApi, @file:JvmName("${name}")
8. `!!`를 사용하고 있는 것은 코틀린을 잘 못 쓰고 있다는 시그널이다.
9.  `!`을 플랫폼 타입이라고 한다.


# 2주차


10. JvmInline과 value class
12. 리스코프 치환 원칙을 위반한 예제
13. 상속이 문제가 아니라 상속을 잘 활용하는 것이 문제다.
14. 코틀린에서 Int와 Integer를 처리하는 방법과 Int의 캐싱 범위 예제
15. 백킹 프로퍼티를 활용한 방어적 복사
16. [좋은 객체의 7가지 덕목](https://codingnuri.com/seven-virtues-of-good-object/)
17. [우아한객체지향 by 우아한형제들 개발실장 조영호](https://www.youtube.com/watch?v=dJ5C4qRqAgA&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC)
18. [Spring Batch를 더 우아하게 사용하기 - Spring Batch Plus](https://d2.naver.com/helloworld/9879422)

# 3주차

1. 수신 객체 지정 람다를 이용한 Kotlin DSL
11. Builder들의 책임과 비즈니스 로직에서 사용할 값 객체의 책임
   1. 마지막 주차 1단계 예제에서 PersonBuilder 내부 필드를 한 번에 초기화 하는 것이였는데 Skill과 Language 빌더들이 너무 더럽다고 느꼈지만 제이슨님은 PersonBuilder 자체가 더러움을 책임지는 객체라고 생각하셨다.
   2. 비즈니스 로직에서 관심가지는 것은 값 객체에 대한 정보이기 때문에 각 data class들이 불변 필드들을 가지고 있는것에 만족하셨다.

# 좋은 객체의 7가지 덕목

> 이따금 클래스를 “객체 템플릿”으로 부르는 것(예를 들면 위키피디아에서 그렇게 하고 있다)을 듣곤 한다.  
> 이 같은 정의는 정확하지 않은데, 이 정의에 따르면 클래스는 수동적인 위치에 있기 때문이다.  
> 이 정의는 누군가가 템플릿을 가지고 그것을 사용해 객체를 만들어낸다고 가정한다. 그럴 수도 있지만 엄밀히 말하자면 개념적으로 틀린 말이다.
> 한번 생성된 객체는 스스로 동작한다. 자신을 누가 만들었고 클래스에 형제 자매가 얼마나 더 있는지 알아서는 안 된다.

클래스와 객체를 이야기할 때 "붕어빵"과 "붕어빵을 찍어낼 수 있는 틀" 정도로 설명하는데, 객체지향 프로그래밍에서 클래스와 객체는 더 많은 의미가 담겨있는 것 같다.
[이 글](https://codingnuri.com/seven-virtues-of-good-object/)에서 설명하는 객체는 현실 세계의 객체를 대표해야 한다고 한다.  
개인적으로 소프트웨어의 객체가 현실 세계의 객체를 모두 대표할 수 없다라고 생각한다. 그렇다고 해서 이 연관지으려는 노력이 쓸모 없다는 것은 아니고 노력은 해야하지만 유연하게 생각해야 하지 않을까 생각한다.  

1. 객체는 주체적이어야 한다.
2. 객체 내에 존재하는 기능들은 모두 계약에 따라 동작해야 한다.
   - 여기서 말하는 계약은 인터페이스나 추상 클래스에 선언된 기능들을 구현하는 것이다.
   - 계약되지 않은 기능을 구현한다면 단위 테스트에서 모킹하는 것이 불가능하고, 데코레이션을 통해 확장하는 것이 불가능하기 때문이다.
3. 좋은 객체는 언제나 고유하기 위해 무언가를 캡슐화해야 한다.
   - 하지만 정적 메서드만 담긴 유틸리티 클래스는 클래스의 이점을 아무것도 갖고 있지 않으며 클래스라고 부를 수 조차 없다.
   - 유틸리티 클래스는 단순히 객체 패러다임을 엉터리로 남용하는 것에 불과하다.
4. 객체는 객체의 전 생명주기에 걸쳐 상태가 변하지 않은 채로 머물러야 한다.
   - 불변성이 모든 메서드가 언제나 동일한 값을 반환한다는 것을 의미하지는 않는다.
   - 하지만 자신의 내부 상태는 절대 변경하지 않는다.
   - [Temporal Coupling Between Method Calls](https://www.yegor256.com/2015/12/08/temporal-coupling-between-method-calls.html)
   - [Why NULL is Bad?](https://www.yegor256.com/2014/05/13/why-null-is-bad.html)
   - [How Immutability Helps](https://www.yegor256.com/2014/11/07/how-immutability-helps.html)
   - [Objects Should Be Immutable](https://www.yegor256.com/2014/06/09/objects-should-be-immutable.html)
5. 클래스에 정적 멤버가 존재하는 경우에는 객체지향 패러다임에 완전히 반한다.
   - OOP의 위력은 복잡한 문제를 여러 부분으로 분해하여 각 책임을 객체에 할당하여 특정 과업을 수행하도록 하는 것인데, 정적 멤버는 다른 클래스와의 상호작용을 고립시킬 수 없기 때문이다.
6. 이름은 그것이 무엇인지를 말해야 하고, 무슨 일을 하는지 말해서는 안된다. 일반적으로 `-er`로 끝나는 이름은 피하라
   - [Don't Create Objects That End With -ER](https://www.yegor256.com/2015/03/09/objects-end-with-er.html)
7. 좋은 객체는 `final` 이나 `abstract` 클래스에서 온다.
   - 누군가가 내가 작성한 클래스를 상속받아 리스코프 치환 원칙을 위반하는 경우를 막기위해 `final`을 적절히 사용하라
   - 상속받아 기능을 추가하려 하지말고 데코레이터 패턴을 통해 해당 객체를 주입받아 위임할 생각을 해라
   - 다른 작업자에게 템플릿처럼 확장하기 쉬운 포인트를 제공하고 싶거나 내가 개발한 부분을 오염시키지 않길 원한다면 `abstract`를 적절히 사용하라
   - 추상 클래스로 템플릿 메서드 패턴을 적용하여 구현할 수 있는 포인트를 명시해라