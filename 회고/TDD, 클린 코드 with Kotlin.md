
# 1주차

> 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 더 많은 수의 생성자가 존재한다.  
> 생성자의 주된 임무는 제공된 인자를 사용해서 캡슐화된 프로퍼티를 초기화하는 것이고, 메서드의 수가 많을수록 SRP을 위반할 확률이 높지만 생성자는 많을수록 클라이언트가 유연하게 사용할 수 있다.  

1. 코틀린스럽게 작성하는 것이 아직 익숙하지 않다.
   1. require, check, backing fields
2. [검증부는 하드코딩 한다.](https://jojoldu.tistory.com/615?category=1036934)
3. 입출력 로직과 비즈니스 로직이 뒤섞여 있다.
4. 테스트하기 쉽게 만들려면 주입이 가능하도록 해야한다.
   1. 이번 과제에서 핵심은 랜덤 값을 만들어내는 부분을 최대한 밖으로 끌어내기 위해 **객체 그래프** 를 활용하여 주입할 지점을 찾는 것이다.
5. 코틀린 클래스는 프로퍼티, 초기화 블록, 부 생성자, 함수, 동반 객체 순으로 작성하는 것이 컨벤션이다.
6. 코틀린은 기본적으로 프로퍼티 기반인 것을 명심해라.
7. 코틀린과 자바와 같이 쓸 수 밖에 없는 환경이라면 어노테이션의 기능에 관심가져라
   1. @JvmField, @PublishedApi, @file:JvmName("${name}")
8. `!!`를 사용하고 있는 것은 코틀린을 잘 못 쓰고 있다는 시그널이다.
9.  `!`을 플랫폼 타입이라고 한다.

## 1주차 회고

1주차는 5단계로 이루어져 있었다.
  
1단계: 환경 세팅  
2단계: [문자열 계산기](https://github.com/next-step/kotlin-racingcar/pull/1315)  
3단계: [자동차 경주 구현](https://github.com/next-step/kotlin-racingcar/pull/1381)  
4단계: [자동차 경주 우승자 기능 추가](https://github.com/next-step/kotlin-racingcar/pull/1440)  
5단계: [자동차 경주 리팩토링](https://github.com/next-step/kotlin-racingcar/pull/1473)  
  
자동차 경주는 우테캠 프리코스에서 한 번 해본 경험도 있었고 기능 자체는 간단하지만 책임을 나누는 것 역시 쉽지 않았다.  
그리고 코틀린을 코틀린스럽게 작성하는 것에 익숙하지 않다는 것을 느꼈다.  
  
비즈니스 로직이 UI 로직과 혼재되어 있던 부분을 "결과 객체"를 추가하여 결합도를 낮출 수 있었고,  
테스트를 작성하기 쉽도록 외부에서 필요한 정보들을 주입 받도록 리팩토링 해보았다.  
  
이제 2주차 부터 TDD를 진행하기 위해서는 **요구 사항 분석 및 설계** 가 필수이다.  
과제를 진행하면서 README에 **구현할 기능 목록을 작성하여** 해당 기능들을 한 개씩 TDD로 진행해봐야겠다.  
  
구현할 기능 목록을 작성하고 고민되는 지점을 시각화하는 것 자체가 이미 훈련이다.  