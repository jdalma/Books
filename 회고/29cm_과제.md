
# 29cm 세미나 영상 요약

비즈니스 도메인을 중심으로 모델링된 독립적으로 배포 가능한 서비스  
**마이크로 서비스 도입 이렇게 한다 책 추천하심**  
- 장점
  - 증가하는 트래픽 처리가 쉽고 새로운 기능 추가를 빠르게 적용이 가능
  - 조직 성장에 맞는 아키텍처 적용 가능
  - 마이크로 서비스를 통해서 도메인이 분리되었기 때문에 해당 도메인에 조금 더 집중 가능
- 단점 : 복잡함 상승
   - 개발,운영,모니터링
   - 트랜잭션 관리, 디버깅 (보상 트랜잭션? 트랜잭션 사가?) 📌
   - 적정하게 도메인 나누기의 어려움 (너무 세세하게 분리하거나, 너무 크게 분리하거나) 📌
     - 결제와 주문 도메인을 분리할 때 커머스라는 팀으로 분리했다. 
     - 고려해야 할 사항이 많은 것 같다. 개발자의 수도 영향을 주는 것 같다.

20여개의 주요 도메인마다 독립된 서비스를 운영 중  
쿠버네티스와 istio의 조합, 수백개의 컨테이너를 관리 중  
  
우선 서버와 클라이언트 간의 **API 표준**부터 정의해야함  
`/api/{version}/{도메인명}` 패턴을 사용  
  
> 기술은 고객과 회사의 가치를 만들기 위해 존재한다.  
> 완벽한 계획보다는 빠른 실행을 추구하고, 목표 달성을 위해 구성원들간의 지속적인 소통 **목적 조직**
  
## 장애 케이스

1. **타임딜 오픈 직후 데드 락 발생**
   1. 상품을 관리하는 도메인 item + option
   2. option 재고를 모두 합치면 item의 재고이다. 1 (item) : N (option)
   3. 그래서 두 번의 UPDATE를 실행
   4. A 사용자가 230과 240을 주문, B 사용자가 240을 주문
   5. A 사용자가 230 option의 row lock 획득 -> update 230 option -> B 사용자가 240 option의 row lock 획득 -> update 240 option -> A 사용자가 item의 row lock 획득 -> update item -> A 사용자가 240 option의 row lock 획득 **실패** (B 사용자가 lock을 해제하길 기다림) -> B 사용자가 240 item의 row lock 획득 **실패** (A 사용자가 lock을 해제하길 기다림)
   6. A 사용자는 B 사용자의 option row lock을 해제하길 기다리고 B 사용자는 A 사용자의 item row lock을 해제하길 기다린다.
   7. 그래서 **유저별로 상품 구매 가능 수량을 1개로 제한**
   8. 임시 방편일 뿐, 기술이 비즈니스를 발목 잡는 상황
   9. 동일 상품 당 여러 option을 구매 시, option들을 먼저 차감하고, 일괄로 item 차감으로 개선
   10. 동일한 option 구매 유저가 존재하더라도, 기존 유저가 모든 option에 대한 재고 차감을 완료하여 row lock을 해제하기 전까지 다른 프로세스는 대기하게 된다. **row lock 획득 시점에 대한 언급은 없지만 아마 해당 트랜잭션이 시작될 때 option과 item에 대한 lock획득을 바로 하는 것 같다.** 📌
2. **라이브커머스 푸시 발송 이후 장애**
   1. 밤 8시에 대량의 푸시 발송
   2. 8시 20분쯤에 전면 장애
   3. 대용량의 트래픽이 순간적으로 유입되면서 발생
   4. 기존 레거시 모놀리틱 서비스 (파이썬, 장고) 와 신규 마이크로 서비스 (스프링, 자바, 코틀린)을 같이 운영하고 있었음
      1. 파이썬 인증 로직과 게이트웨이 때문
   5. 대량 유저가 파이썬 장고 서비스를 대량 호출하여 서비스 자체가 다운된 상황
   6. 쿠버네티스의 팟의 리스타트가 무한정으로 도는 상황
   7. 파이썬, 장고에 유입되는 트래픽을 줄이기 위해 장애 호출 API top10 리스트업하여 마이크로서비스를 직접 호출하도록 수정
      1. 추천 계열 API, 리뷰 계열 API
      2. API 호출을 하는 사용자가 누구인지 알아야하는 인증 로직이 필요한 API이다
   8. 기존 모놀리틱 서비스와 마이크로 서비스의 응답을 동일하게 해야하고, 엔드포인트를 마이크로 서비스로 직접 변경했을 떄 장애가 발생할 수 있으니 방향을 바로 변경할 수 있는 **피처플래그**도 개발해야했다. ❓
3. **3rd-party 결제 서비스 장애**
   1. 주문 결제 전면 장애 - 20년 12월, 21년 5월
   2. 한달 반이 지난 시점에 SPOF를 극복
   3. 두 개 이상의 결제 서비스와 계약하여 **결제 트래픽 분배기**를 위치시킴
   4. 특정 결제 서비스의 장애가 발생하더라도 다른 결제 서비스로 결제가 가능해짐

## 코드 품질 이슈

1. 멀쩡한 파이썬 프로젝트를 신규 프로젝트로 새로 구현한다는 것
   1. 기업 관점에서는 투자와 비용이다.
   2. 고로 처음부터 잘 만들어야한다.
   3. **구엔이일 책을 추천해주심**
2. 가독성 vs 성능 , 가독성 vs 추상화 레벨  
   1. 가독성을 중시하고 변경에 유연해야 한다.  
   2. 코드를 새로 작성하는 시간보다, 그 작성된 코드를 이해해야할 경우가 더 많기 때문이다.  
   3. 내부에 **표준 구현 방식**을 문서로 관리하고 있다.  
   4. **장애 회고 문서**, **개발 디자인 문서(서비스 초기 개발 방향과 컨셉)**, **아키텍처 결정 기록 문서(개발 과정에서 발생하는 아키텍처 의사결정 기록)** 작성도 함  
3. 목적에 맞으면서 높은 품질의 코드 구현을 위해 치열하게 고민한다.

# 단단한 성장을 위한 목표 기술 과제

## 도메인 다이어그램 / 데이터베이스 그룹핑

**단방향 호출**을 지향하고 **순환 참조**가 발생되면 책임 범위나 역할 정의가 잘 못되었다고 판단할 수 있다.  
  
```
user > item > commerce > activation > search,reivew,content,extenral...
```
  
주문,주문취소,교환,반품,정산,배송들의 액션은 결제가 일어나야 하는 것 처럼 방향이 존재한다  
shared DB 패턴을 사용하고 있다.  
2023년 안에는 몇몇 그룹핑 도메인을 중심으로 DB를 쪼개고 싶어한다.  

## Materialized view 서버 구축

마이크로 서비스 환경에서는 클라이언트가 여러 Web API 응답들을 모아서 aggregation하거나, aggregation하는 서버를 따로 두거나 해야한다.  
  
다양한 도메인의 데이터를 사전에 별도로 모아서 반정규화된 디비에 미리 저장한다.  
외부에서 데이터를 요청했을 때 상품, 가격, 재고, 할인, 리뷰 데이터가 한 번에 모아진 구조로 반환하는 기능  
  
주기적인 배치를 통해 도메인 데이터를 가져오거나, 비동기 메시징 기반으로 이벤트를 공급하여 데이터를 가져오거나  
  
> 캐시 서버 같은 느낌인데, 데이터를 가공하고 캐시하는 느낌?  
> 성능 측면에서는 장점  

## 이벤트 주도 아키텍처 (EDA)

**비동기 메시징**  
1. 메시지 발행 서버와 수신 서버 간의 의존성 제거 가능
   - 발행 서버는 수신 서버의 호스트 정보나 포트를 알 필요가 없다.
   - 메시지 브로커를 중심으로 퍼블리싱만 하면되고 그 메시지에 관심이있는 컨슈머들이 메시지를 소비하면 된다.
2. 메시지 브로커에 메시지가 전달되기만 하면 컨슈머 서버가 죽었거나 문제가 생기더라도 상관없다.
   - 컨슈머가 메시지를 여러 번 가져갈 수 있는 시간적 여유가 있다고 한다.??
3. 메시지 브로커가 대량의 트래픽을 커버하는 버퍼로 동작한다.
  
**고려해야할 것들**  
1. 발행 메시지 순서 보장 (주문 시도 -> 결제 완료 -> 주문 취소)
   1. 메시지에 키 값을 포함해서 보냄, 키를 해싱하여 특정 토픽의 파티션에만 들어가게끔
2. 컨슈밍할 때 중복 메시징 처리
   1. 메시지가 중복될 수 밖에 없는 구조이다.
   2. 컨슈머가 스스로 메시지를 읽었는지 구분하여야 한다.
3. 트랜잭셔널 메시징 구현
   1. 특정 서비스의 DB 트랜잭션 안에서 메시지도 같이 커밋되거나 롤백되어야 한다. 직접 구현해야 한다. (아웃박스 패턴)
   2. DB log를 tailing하는 프레임워크를 통해 (Debezium)
