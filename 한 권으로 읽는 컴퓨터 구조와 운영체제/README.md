
<!-- TOC -->

- [**3장. 메모리와 디스크의 핵심**](#3%EC%9E%A5-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%ED%95%B5%EC%8B%AC)
- [**4장. 컴퓨터 내부 구조**](#4%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0)
- [**5장. 컴퓨터 아키텍처와 운영체제**](#5%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)

<!-- /TOC -->

> 코딩 교육 열풍의 이면에는 `질 낮은 프로그래머를 회사에 많이 공급함으로써 프로그래머의 급여 수준을 낮추고 회사의 이익을 증가시키려는 목적`이 있다고 진단한다.  
> 따라서 이 덫에 빠지지 않으려면 우리 스스로 문제를 정의할 줄 알아야하고 문제를 효율적으로 풀 줄 알아야 하는데, 그러려면 컴퓨터가 돌아가는 방식을 이해해야 한다고 역설한다.  
> 바다에 빠졌을 때 헤엄쳐 나올 수 있는 사람은 커다란 배를 타고 세계를 일주한 사람이 아니라 맨몸으로 자맥질을 해 본 사람이고, 지도에 없는 보물섬을 찾을 수 있는 사람은 GPS가 안내하는 길로만 다닌 사람이 아니라 지도를 보고 빈 곳을 궁금해 찾아가 보고, 가끔은 허탕도 치면서 지도에 없는 배움을 몸으로 익힌 사람이다.  
> 누구나 프로그래머가 될 수 있지만 **누구나 좋은 프로그래머가 될 수 있는 것은 아니다.**  

1. 프로그래밍을 제대로 잘해야 하는 이유
2. 프로그래밍을 배우는 것은 시작일 뿐이다.
3. 하부 기술 지식의 중요성

이 책의 저자는 학교에서 누구나 코딩하는 법을 배워야 하도록 법안을 바꾸는 것에 대해 비판적이다.  
법안을 바꾸는 것에 대해 비판적이라기 보단, **회사의 이익을 위해 질 낮은 프로그래머를 양산하는 것이 문제라고 지적한다.**  
  
이 책은 좋은 프로그래머가 되고 싶은 사람을 위한 책이며, 좋은 프로그래머는 **좋은 비판적 사고**와 **분석 기술**을 지녀야 한다.  

***

# **3장. 메모리와 디스크의 핵심**
- 발진자
  - 되먹임, 피드백
- 클록
- 래치
- 플립플롭
- 카운터
- **레지스터**
  - `D 플립플롭`을 사용하면 데이터를 쉽게 기억할 수 있다.
  - 레지스터는 **클록을 공유하는 여러 `D 플립플롭`을 한 패키지에 넣은 것**

> 여러가지 덧셈 결과를 저장해야 한다면? **여러 개의 레지스터를 묶어서 사용**  
> 어떤 레지스터를 사용해야할까? **디코더와 셀렉터룰 활용**
  
- **버스** : 비트를 이동시키는 대량 교통수단
  - 주소 버스, 데이터 버스
- **임의 접근 메모리 RAM**
  - `정적 RAM (SRAM)` : 비싸지만 아주 빠르며, 각 비트에 트랜지스터가 6개라는 공간을 차지하며, 수십억-수조 비트를 저장하기에는 좋은 선택은 아니다.
  - `동적 RAM (DRAM)` : 커패시터라는 버킷에 전자를 담고, 트랜지스터를 1개만 사용한다. 하지만 메모리를 갱신해줘야한다. (주기적으로 전자를 다시 채워넣어야 한다.)
    - 집적도(밀도, 단위 면적당 비트 개수)가 높아 큰 메모리 칩에 사용
- **읽기 전용 메모리 ROM**
  - 한 번만 쓸 수 있는 메모리

# **4장. 컴퓨터 내부 구조**
- **메모리**, **입력과 출력**, **CPU** 크게 세 가지 부분으로 나눌 수 있다.
- **메모리**
  - 32bit 컴퓨터는 메모리를 4바이트 덩어리로, 64bit 컴퓨터는 메모리를 8바이트 덩어리로 구성
  - **엔디안** : 0번 바이트가 가장 왼쪽에 위치하지는 `빅 엔디안`, 가장 오른쪽에 위치하는지 `리틀 엔디안`
- 많은 컴퓨터에는 `설계상 표준 입력/출력 슬롯`이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다.
- **CPU**
  - **산술 논리 장치 ALU**
    - `in` : 피연산자 A, 피연산자 B, **연산코드(명령 코드)**
    - `out` : 결과, **조건 코드 레지스터**
  - **실행 장치(제어 장치)**
    - 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.

# **5장. 컴퓨터 아키텍처와 운영체제**
- 중위,전위,후위 표기법
- 인터럽트
 - 인터럽트 요청과 인터럽트 핸들러
 - 인터럽트 벡터 : 메모리 위치를 가리키는 포인터
- 인덱스 레지스터
- 상대 주소 지정
- **메모리 관리 장치 `MMU`**
 - 가상 주소와 물리 주소를 구분
 - 메모리 주소를 두 부분으로 나누며, 주소의 하위 `(LSB)` 부분은 물리적 주소 범위와 같고 상위 `(MSB)` 부분은 **페이지 테이블**이라는 RAM 영역을 통해 주소를 변환한다.
 - 페이지
 - 물리 메모리를 함께 사용하는 **공유 메모리** 기능
 - **실행 불가 비트**
 - **읽기 전용으로 만드는 비트**
 - 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 **페이지 폴트** 예외
- **가상 메모리**
 - OS는 `MMU`를 사용해 사용자 프로그램에게 **가상 메모리**를 제공한다.
 - **스왑 아웃** + **스왑 인** = **요구불 페이징** (demand paging)
- 트랩과 시스템 콜
- **메모리 계층과 성능**
  - **CPU 메모리 컨트롤러** 하드웨어 : 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다.
  - **직접 메모리 접근 `DMA`**