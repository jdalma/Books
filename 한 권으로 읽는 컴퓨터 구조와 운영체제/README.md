
<!-- TOC -->

- [**3장. 메모리와 디스크의 핵심**](#3%EC%9E%A5-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%ED%95%B5%EC%8B%AC)
- [**4장. 컴퓨터 내부 구조**](#4%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0)
- [**5장. 컴퓨터 아키텍처와 운영체제**](#5%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)
- [**6장. 입출력과 네트워킹**](#6%EC%9E%A5-%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9)
- [**7장. 데이터 구조와 처리**](#7%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%B2%98%EB%A6%AC)

<!-- /TOC -->

> 코딩 교육 열풍의 이면에는 `질 낮은 프로그래머를 회사에 많이 공급함으로써 프로그래머의 급여 수준을 낮추고 회사의 이익을 증가시키려는 목적`이 있다고 진단한다.  
> 따라서 이 덫에 빠지지 않으려면 우리 스스로 문제를 정의할 줄 알아야하고 문제를 효율적으로 풀 줄 알아야 하는데, 그러려면 컴퓨터가 돌아가는 방식을 이해해야 한다고 역설한다.  
> 바다에 빠졌을 때 헤엄쳐 나올 수 있는 사람은 커다란 배를 타고 세계를 일주한 사람이 아니라 맨몸으로 자맥질을 해 본 사람이고, 지도에 없는 보물섬을 찾을 수 있는 사람은 GPS가 안내하는 길로만 다닌 사람이 아니라 지도를 보고 빈 곳을 궁금해 찾아가 보고, 가끔은 허탕도 치면서 지도에 없는 배움을 몸으로 익힌 사람이다.  
> 누구나 프로그래머가 될 수 있지만 **누구나 좋은 프로그래머가 될 수 있는 것은 아니다.**  

1. 프로그래밍을 제대로 잘해야 하는 이유
2. 프로그래밍을 배우는 것은 시작일 뿐이다.
3. 하부 기술 지식의 중요성

이 책의 저자는 학교에서 누구나 코딩하는 법을 배워야 하도록 법안을 바꾸는 것에 대해 비판적이다.  
법안을 바꾸는 것에 대해 비판적이라기 보단, **회사의 이익을 위해 질 낮은 프로그래머를 양산하는 것이 문제라고 지적한다.**  
  
이 책은 좋은 프로그래머가 되고 싶은 사람을 위한 책이며, 좋은 프로그래머는 **좋은 비판적 사고**와 **분석 기술**을 지녀야 한다.  

***

# **3장. 메모리와 디스크의 핵심**
- 발진자
  - 되먹임, 피드백
- 클록
- 래치
- 플립플롭
- 카운터
- **레지스터**
  - `D 플립플롭`을 사용하면 데이터를 쉽게 기억할 수 있다.
  - 레지스터는 **클록을 공유하는 여러 `D 플립플롭`을 한 패키지에 넣은 것**

> 여러가지 덧셈 결과를 저장해야 한다면? **여러 개의 레지스터를 묶어서 사용**  
> 어떤 레지스터를 사용해야할까? **디코더와 셀렉터룰 활용**
  
- **버스** : 비트를 이동시키는 대량 교통수단
  - 주소 버스, 데이터 버스
- **임의 접근 메모리 RAM**
  - `정적 RAM (SRAM)` : 비싸지만 아주 빠르며, 각 비트에 트랜지스터가 6개라는 공간을 차지하며, 수십억-수조 비트를 저장하기에는 좋은 선택은 아니다.
  - `동적 RAM (DRAM)` : 커패시터라는 버킷에 전자를 담고, 트랜지스터를 1개만 사용한다. 하지만 메모리를 갱신해줘야한다. (주기적으로 전자를 다시 채워넣어야 한다.)
    - 집적도(밀도, 단위 면적당 비트 개수)가 높아 큰 메모리 칩에 사용
- **읽기 전용 메모리 ROM**
  - 한 번만 쓸 수 있는 메모리

# **4장. 컴퓨터 내부 구조**
- **메모리**, **입력과 출력**, **CPU** 크게 세 가지 부분으로 나눌 수 있다.
- **메모리**
  - 32bit 컴퓨터는 메모리를 4바이트 덩어리로, 64bit 컴퓨터는 메모리를 8바이트 덩어리로 구성
  - **엔디안** : 0번 바이트가 가장 왼쪽에 위치하지는 `빅 엔디안`, 가장 오른쪽에 위치하는지 `리틀 엔디안`
- 많은 컴퓨터에는 `설계상 표준 입력/출력 슬롯`이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다.
- **CPU**
  - **산술 논리 장치 ALU**
    - `in` : 피연산자 A, 피연산자 B, **연산코드(명령 코드)**
    - `out` : 결과, **조건 코드 레지스터**
  - **실행 장치(제어 장치)**
    - 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.

# **5장. 컴퓨터 아키텍처와 운영체제**
- 중위,전위,후위 표기법
- 인터럽트
 - 인터럽트 요청과 인터럽트 핸들러
 - 인터럽트 벡터 : 메모리 위치를 가리키는 포인터
- 인덱스 레지스터
- 상대 주소 지정
- **메모리 관리 장치 `MMU`**
 - 가상 주소와 물리 주소를 구분
 - 메모리 주소를 두 부분으로 나누며, 주소의 하위 `(LSB)` 부분은 물리적 주소 범위와 같고 상위 `(MSB)` 부분은 **페이지 테이블**이라는 RAM 영역을 통해 주소를 변환한다.
 - 페이지
 - 물리 메모리를 함께 사용하는 **공유 메모리** 기능
 - **실행 불가 비트**
 - **읽기 전용으로 만드는 비트**
 - 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 **페이지 폴트** 예외
- **가상 메모리**
 - OS는 `MMU`를 사용해 사용자 프로그램에게 **가상 메모리**를 제공한다.
 - **스왑 아웃** + **스왑 인** = **요구불 페이징** (demand paging)
- 트랩과 시스템 콜
- **메모리 계층과 성능**
  - **CPU 메모리 컨트롤러** 하드웨어 : 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다.
  - **직접 메모리 접근 `DMA`**

# **6장. 입출력과 네트워킹**

- 아날로그 데이터를 컴퓨터가 쓸 수 있는 디지털 형태로 바꾸거나, 역방향으로 바꾸려면 **샘플링**을 해야한다.
- 디스플레이의 애노드와 캐소드
- **병렬 통신**은 I/O핀, 커넥터 핀, 선이 많이 필요하기 때문에 **직렬 통신**을 사용하여 `한 선에 8개의 신호를 보낸다`

> **시간 분할 멀티 플렉싱**  
> 동기화 오류가 발생할 때 송신자가 해야 할 일은 정해진 **문자 시간**동안 조용히 있으면서 수신자가 동기화를 다시 할 때 까지 기다리는 것이다.  
> 이때 시간을 나눈 슬롯을 만들고 각기 다른 비트를 할당해서 데이터를 한 선에 멀티플렉싱 하는 것이다.
  
- **랜덤 백오프 후 재시도** : 송신자와 수신자 중 전송 시에 충돌이 발생하면 임의의 시간을 잠깐 기다린 다음 시도하는 것
- **디지털 숫자를 사용해 어떻게 아날로그 전압을 만들어 낼 수 있을까?** (DA 변환기를 어떻게 만들까?)
  - 높은 워터마크, 낮은 워터마크, `연속적으로 출력이 일어나도록`
- **아날로그를 디지털로 어떻게 변환할까?** (AD 변환기)
  - 입력 파형을 샘플링 (샘플)을 해야한다. `샘플 앤드 홀드` 회로를 사용해 아날로그 파형의 값을 잡아낼 수 있다.
  - `0.125V`보다 낮은 전압의 경우 `00000000`
  - `0.125V 부터 0.250V 사이`라면 `00000001`
  - ...
  - 일차원으로 **샘플링**을 하면 오디오를 디지털화 할 수 있다.
    - 일정 시간 간격으로 신호의 진폭이나 높이를 측정한다는 뜻이다.

# **7장. 데이터 구조와 처리**

> 어떻게 해야 프로그램에서 데이터를 잘 구성하고 처리할까

- **참조 지역성** : `필요한 데이터를 (메모리에서) 서로 근처에 유지하라. 금방 사용할 데이터라면 더 가까운 곳에 저장하라`
  - 한 공간은 1바이트라고 치고 2차원 배열을 예로 들어, `3x4` 배열로 행 기준으로 탐색을 하게 되면 **메모리 공간 상으로는 배열의 열 개수만큼 떨어져 있는 메모리 위치에 있는 원소로 이동해야 한다.**
  - 따라서 주소 공간상에서는 **열 인덱스가 바뀔 때 보다 행 인덱스가 바뀔 때 더 많은 이동이 일어난다.**
- **포인터**
  - 단지 컴퓨터 아키텍처에 따라 결졍되는 크기의 부호가 없는 정수에 불과하며, 정숫값이 아니라 메모리 주소로 해석된다.
  - 집을 찾을 때 주소를 쓸 수 있는 것 처럼 **원하는 값이 있는 위치를 포인터로 알 수 있다.**
- **비트맵**
  - 어떤 원소가 두 가지의 경우만 포함하고 있어 `1비트`로도 충분히 표현할 수 있다면, 바이트로 표현하기 보단 한 개의 비트로 표현하는것이 더 효율적일 것이다.
- **문자열**
  - C는 다른 언어와 달리 문자열을 위한 전용 데이터 타입을 제공하지 않고, `1차원 바이트 배열`을 사용한다.
  - 그리고 C 문자열은 길이를 저장하지 않는다.
  - 대신에 **문자 배열에 들어 있는 문자열 데이터의 끝에 바이트를 하나 추가하고, 여기에 문자열의 끝을 표시하는 문자로 `NUL`을 넣는다.**
  - 즉 0을 **문자열 터미네이터**로 활용한다.
- **복합 데이터 타입**
  - 패딩
  - 공용체 (union) : 구조체 안의 모든 멤버는 각기 다른 메모리를 차지하지만 **공용체의 멤버들은 메모리를 공유할 수 있다.**
 
> 많은 시스템에서 날짜와 시간을 다룰때는 유닉스에서 온 표준적인 방법을 사용하며  
> 1970년 1월 1일부터 시작하는 **유닉스 에포크**를 기준으로 몇 초가 지났는지를 표현하는 32비트 수를 사용한다.  

- **동적 메모리 할당**
  - `malloc` 구현 중에는 **단일 연결 리스트 데이터 구조**를 사용해 작동하는 구현이 있다.
  - 힙은 여러 블록으로 나뉘고, 각 블록에는 크기와 다음 블록에 대한 포인터가 포함된다.
  - 프로그램이 메모리를 요청하면 `malloc`이 충분한 크기의 블록을 찾아서 요청받은 공간에 대한 포인터를 돌려주고, 프로그렘에게 할당한 메모리를 반영해 블록의 크기와 링크를 조정한다.
- **트리 균형을 회복하는 알고리즘**
  - 알고리즘 속도와 삽입/검색 시간 , 재균형 시간 사이에 트레이드 오프 관례가 존재한다.
  - 트리 균형 알고리즘은 계산 비용이 더 많이 들고 일부는 저장 공간도 더 사용한다.  
  - 하지만 `n`보다 log<sub>2</sub>n이 훨씬 더 작기 때문에 트리 크기가 커질수록 이런 부가 비용을 빠르게 극복할 수 있다.
- **대용량 저장장치**
  - 디스크의 기본 단위는 **블록**이고 연속적인 블록을 **클러스터**라고 부른다.
  - **아이노드**
    - 디스크 블록에 대한 `인덱스`와 `노드`를 합친 단어다.
    - 보통 `직접 블록` 포인터가 12개 있으며, 최대 `4,096 * 12 = 49,512` 바이트 까지 데이터를 보관할 수 있다.
    - 파일이 더 커지면 `n중 간접 블록`을 사용하기 시작한다.
  - **심볼릭 링크** (이로 인해 그래프에 루프가 생긴다.)
  - `fsck` ❓
  - **저널링 시스템** ❓
- **데이터베이스**
  - 2진 트리는 데이터를 메모리에 저장할 때는 훌륭한 방법이지만, 메모리 안에 들어갈 수 없을 정도로 커다란 데이터를 저장할 때는 그리 잘 작동하지 않는다.
  - 트리 노드는 크기가 작은 경향이 있어서 디스크 섹터에 잘 들어맞지 않기 때문이다.
  - DBMS는 보통 **맨 아래의 데이터 저장 메커니즘을 감싼 여러 계층의 인터페이스로 구성된다.**
  - `B 트리`는 균형 트리이지만 2진 트리는 아니며, 공간을 덜 효율적으로 사용하지만 데이터를 저장할 때 균형 2진 트리보다 더 성능이 좋다.
- **인덱스**
- **데이터 이동**
  - `루프 언롤링` 기법
    - Loop unrolling이란 loop를 풀어서 바이너리 코드의 크기는 증가하지만, 하드웨어 가속을 추구하는 기법이다. 
    - 루프 언롤링을 통해서 루프에서 다음 루프로 이동하는 동안 일어나는 동기화, 인덱스 증가, 비교문과 같은 불필요한 계산 시간을 줄여서 프로그램이 수행하는 시간을 줄일 수 있다.
- **벡터를 사용한 I/O**
  - 벡터는 같은 데이터가 연속적으로 모여 있는 고정된 크기의 데이터 구조를 뜻한다
  - TCP는 패킷이 올바른 순서로 전달되게 할 책임이 있다고 설명했다. 소켓으로부터 도착하는 패킷은 사용자 프로그램에게 전달되기 전에 `연속적인 스트림`으로 수집된다.
- **정렬** 📌
  - 정렬을 직접 만들 가능성은 드물지만 `정렬 대상이 포인터 크기보다 크다면 데이터를 직접 정렬하는 대신 데이터를 가리키는 포인터를 재배열하는 방식`으로 정렬하자
  - `qsort`라는 라이브러리 함수는 데이터를 정렬하는 방법은 정의되어 있지만, **데이터를 비교하는 방법은 정의되어 있지 않다.**
  - 그래서 C 언어의 함수 포인터 (함수를 가리키는 포인터)를 함께 전달해야 한다.
- **데이터베이스 샤딩** : 수평 파티셔닝
  - 샤딩의 변종으로 **맵리듀스**가 있다.