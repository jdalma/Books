
<!-- TOC -->

- [**무지 목록**](#%EB%AC%B4%EC%A7%80-%EB%AA%A9%EB%A1%9D)
- [**3장. 메모리와 디스크의 핵심**](#3%EC%9E%A5-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC%EC%9D%98-%ED%95%B5%EC%8B%AC)
- [**4장. 컴퓨터 내부 구조**](#4%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0)
- [**5장. 컴퓨터 아키텍처와 운영체제**](#5%EC%9E%A5-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%99%80-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C)
- [**6장. 입출력과 네트워킹**](#6%EC%9E%A5-%EC%9E%85%EC%B6%9C%EB%A0%A5%EA%B3%BC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9)
- [**7장. 데이터 구조와 처리**](#7%EC%9E%A5-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%B2%98%EB%A6%AC)
- [**8장. 프로그래밍 언어 처리**](#8%EC%9E%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4-%EC%B2%98%EB%A6%AC)
- [**9장. 웹 브라우저**](#9%EC%9E%A5-%EC%9B%B9-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80)
- [**10장. 애플리케이션 프로그래밍과 시스템 프로그래밍**](#10%EC%9E%A5-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- [**11장. 성능 향상을 위한 알고리즘 기법**](#11%EC%9E%A5-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B8%B0%EB%B2%95)
- [**12장. 병렬성과 비동기성**](#12%EC%9E%A5-%EB%B3%91%EB%A0%AC%EC%84%B1%EA%B3%BC-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%84%B1)

<!-- /TOC -->

> 코딩 교육 열풍의 이면에는 `질 낮은 프로그래머를 회사에 많이 공급함으로써 프로그래머의 급여 수준을 낮추고 회사의 이익을 증가시키려는 목적`이 있다고 진단한다.  
> 따라서 이 덫에 빠지지 않으려면 우리 스스로 문제를 정의할 줄 알아야하고 문제를 효율적으로 풀 줄 알아야 하는데, 그러려면 컴퓨터가 돌아가는 방식을 이해해야 한다고 역설한다.  
> 바다에 빠졌을 때 헤엄쳐 나올 수 있는 사람은 커다란 배를 타고 세계를 일주한 사람이 아니라 맨몸으로 자맥질을 해 본 사람이고, 지도에 없는 보물섬을 찾을 수 있는 사람은 GPS가 안내하는 길로만 다닌 사람이 아니라 지도를 보고 빈 곳을 궁금해 찾아가 보고, 가끔은 허탕도 치면서 지도에 없는 배움을 몸으로 익힌 사람이다.  
> 누구나 프로그래머가 될 수 있지만 **누구나 좋은 프로그래머가 될 수 있는 것은 아니다.**  

1. 프로그래밍을 제대로 잘해야 하는 이유
2. 프로그래밍을 배우는 것은 시작일 뿐이다.
3. 하부 기술 지식의 중요성

이 책의 저자는 학교에서 누구나 코딩하는 법을 배워야 하도록 법안을 바꾸는 것에 대해 비판적이다.  
법안을 바꾸는 것에 대해 비판적이라기 보단, **회사의 이익을 위해 질 낮은 프로그래머를 양산하는 것이 문제라고 지적한다.**  
  
이 책은 좋은 프로그래머가 되고 싶은 사람을 위한 책이며, 좋은 프로그래머는 **좋은 비판적 사고**와 **분석 기술**을 지녀야 한다.  

***

# **무지 목록**

1. 배커스-나우르 표기법 `BNF`
   - 언어를 정의하는 형식적인 방법
   - RFC등에서 BNF가 쓰이기 때문에 익숙해져야만 한다.

# **3장. 메모리와 디스크의 핵심**
- 발진자
  - 되먹임, 피드백
- 클록
- 래치
- 플립플롭
- 카운터
- **레지스터**
  - `D 플립플롭`을 사용하면 데이터를 쉽게 기억할 수 있다.
  - 레지스터는 **클록을 공유하는 여러 `D 플립플롭`을 한 패키지에 넣은 것**

> 여러가지 덧셈 결과를 저장해야 한다면? **여러 개의 레지스터를 묶어서 사용**  
> 어떤 레지스터를 사용해야할까? **디코더와 셀렉터룰 활용**
  
- **버스** : 비트를 이동시키는 대량 교통수단
  - 주소 버스, 데이터 버스
- **임의 접근 메모리 RAM**
  - `정적 RAM (SRAM)` : 비싸지만 아주 빠르며, 각 비트에 트랜지스터가 6개라는 공간을 차지하며, 수십억-수조 비트를 저장하기에는 좋은 선택은 아니다.
  - `동적 RAM (DRAM)` : 커패시터라는 버킷에 전자를 담고, 트랜지스터를 1개만 사용한다. 하지만 메모리를 갱신해줘야한다. (주기적으로 전자를 다시 채워넣어야 한다.)
    - 집적도(밀도, 단위 면적당 비트 개수)가 높아 큰 메모리 칩에 사용
- **읽기 전용 메모리 ROM**
  - 한 번만 쓸 수 있는 메모리

# **4장. 컴퓨터 내부 구조**
- **메모리**, **입력과 출력**, **CPU** 크게 세 가지 부분으로 나눌 수 있다.
- **메모리**
  - 32bit 컴퓨터는 메모리를 4바이트 덩어리로, 64bit 컴퓨터는 메모리를 8바이트 덩어리로 구성
  - **엔디안** : 0번 바이트가 가장 왼쪽에 위치하지는 `빅 엔디안`, 가장 오른쪽에 위치하는지 `리틀 엔디안`
- 많은 컴퓨터에는 `설계상 표준 입력/출력 슬롯`이 있어서 일관된 방식으로 I/O 장치를 연결할 수 있다.
- **CPU**
  - **산술 논리 장치 ALU**
    - `in` : 피연산자 A, 피연산자 B, **연산코드(명령 코드)**
    - `out` : 결과, **조건 코드 레지스터**
  - **실행 장치(제어 장치)**
    - 메모리의 정해진 장소에서 명령코드와 피연산자들을 가져와서 ALU에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.

# **5장. 컴퓨터 아키텍처와 운영체제**
- 중위,전위,후위 표기법
- 인터럽트
 - 인터럽트 요청과 인터럽트 핸들러
 - 인터럽트 벡터 : 메모리 위치를 가리키는 포인터
- 인덱스 레지스터
- 상대 주소 지정
- **메모리 관리 장치 `MMU`**
 - 가상 주소와 물리 주소를 구분
 - 메모리 주소를 두 부분으로 나누며, 주소의 하위 `(LSB)` 부분은 물리적 주소 범위와 같고 상위 `(MSB)` 부분은 **페이지 테이블**이라는 RAM 영역을 통해 주소를 변환한다.
 - 페이지
 - 물리 메모리를 함께 사용하는 **공유 메모리** 기능
 - **실행 불가 비트**
 - **읽기 전용으로 만드는 비트**
 - 프로그램이 물리적 메모리에 연관되지 않은 주소에 접근하면 **페이지 폴트** 예외
- **가상 메모리**
 - OS는 `MMU`를 사용해 사용자 프로그램에게 **가상 메모리**를 제공한다.
 - **스왑 아웃** + **스왑 인** = **요구불 페이징** (demand paging)
- 트랩과 시스템 콜
- **메모리 계층과 성능**
  - **CPU 메모리 컨트롤러** 하드웨어 : 메모리에서 연속된 열에 있는 데이터를 한꺼번에 가져온다.
  - **직접 메모리 접근 `DMA`**

# **6장. 입출력과 네트워킹**

- 아날로그 데이터를 컴퓨터가 쓸 수 있는 디지털 형태로 바꾸거나, 역방향으로 바꾸려면 **샘플링**을 해야한다.
- 디스플레이의 애노드와 캐소드
- **병렬 통신**은 I/O핀, 커넥터 핀, 선이 많이 필요하기 때문에 **직렬 통신**을 사용하여 `한 선에 8개의 신호를 보낸다`

> **시간 분할 멀티 플렉싱**  
> 동기화 오류가 발생할 때 송신자가 해야 할 일은 정해진 **문자 시간**동안 조용히 있으면서 수신자가 동기화를 다시 할 때 까지 기다리는 것이다.  
> 이때 시간을 나눈 슬롯을 만들고 각기 다른 비트를 할당해서 데이터를 한 선에 멀티플렉싱 하는 것이다.
  
- **랜덤 백오프 후 재시도** : 송신자와 수신자 중 전송 시에 충돌이 발생하면 임의의 시간을 잠깐 기다린 다음 시도하는 것
- **디지털 숫자를 사용해 어떻게 아날로그 전압을 만들어 낼 수 있을까?** (DA 변환기를 어떻게 만들까?)
  - 높은 워터마크, 낮은 워터마크, `연속적으로 출력이 일어나도록`
- **아날로그를 디지털로 어떻게 변환할까?** (AD 변환기)
  - 입력 파형을 샘플링 (샘플)을 해야한다. `샘플 앤드 홀드` 회로를 사용해 아날로그 파형의 값을 잡아낼 수 있다.
  - `0.125V`보다 낮은 전압의 경우 `00000000`
  - `0.125V 부터 0.250V 사이`라면 `00000001`
  - ...
  - 일차원으로 **샘플링**을 하면 오디오를 디지털화 할 수 있다.
    - 일정 시간 간격으로 신호의 진폭이나 높이를 측정한다는 뜻이다.

# **7장. 데이터 구조와 처리**

> 어떻게 해야 프로그램에서 데이터를 잘 구성하고 처리할까

- **참조 지역성** : `필요한 데이터를 (메모리에서) 서로 근처에 유지하라. 금방 사용할 데이터라면 더 가까운 곳에 저장하라`
  - 한 공간은 1바이트라고 치고 2차원 배열을 예로 들어, `3x4` 배열로 행 기준으로 탐색을 하게 되면 **메모리 공간 상으로는 배열의 열 개수만큼 떨어져 있는 메모리 위치에 있는 원소로 이동해야 한다.**
  - 따라서 주소 공간상에서는 **열 인덱스가 바뀔 때 보다 행 인덱스가 바뀔 때 더 많은 이동이 일어난다.**
- **포인터**
  - 단지 컴퓨터 아키텍처에 따라 결졍되는 크기의 부호가 없는 정수에 불과하며, 정숫값이 아니라 메모리 주소로 해석된다.
  - 집을 찾을 때 주소를 쓸 수 있는 것 처럼 **원하는 값이 있는 위치를 포인터로 알 수 있다.**
- **비트맵**
  - 어떤 원소가 두 가지의 경우만 포함하고 있어 `1비트`로도 충분히 표현할 수 있다면, 바이트로 표현하기 보단 한 개의 비트로 표현하는것이 더 효율적일 것이다.
- **문자열**
  - C는 다른 언어와 달리 문자열을 위한 전용 데이터 타입을 제공하지 않고, `1차원 바이트 배열`을 사용한다.
  - 그리고 C 문자열은 길이를 저장하지 않는다.
  - 대신에 **문자 배열에 들어 있는 문자열 데이터의 끝에 바이트를 하나 추가하고, 여기에 문자열의 끝을 표시하는 문자로 `NUL`을 넣는다.**
  - 즉 0을 **문자열 터미네이터**로 활용한다.
- **복합 데이터 타입**
  - 패딩
  - 공용체 (union) : 구조체 안의 모든 멤버는 각기 다른 메모리를 차지하지만 **공용체의 멤버들은 메모리를 공유할 수 있다.**
 
> 많은 시스템에서 날짜와 시간을 다룰때는 유닉스에서 온 표준적인 방법을 사용하며  
> 1970년 1월 1일부터 시작하는 **유닉스 에포크**를 기준으로 몇 초가 지났는지를 표현하는 32비트 수를 사용한다.  

- **동적 메모리 할당**
  - `malloc` 구현 중에는 **단일 연결 리스트 데이터 구조**를 사용해 작동하는 구현이 있다.
  - 힙은 여러 블록으로 나뉘고, 각 블록에는 크기와 다음 블록에 대한 포인터가 포함된다.
  - 프로그램이 메모리를 요청하면 `malloc`이 충분한 크기의 블록을 찾아서 요청받은 공간에 대한 포인터를 돌려주고, 프로그렘에게 할당한 메모리를 반영해 블록의 크기와 링크를 조정한다.
- **트리 균형을 회복하는 알고리즘**
  - 알고리즘 속도와 삽입/검색 시간 , 재균형 시간 사이에 트레이드 오프 관례가 존재한다.
  - 트리 균형 알고리즘은 계산 비용이 더 많이 들고 일부는 저장 공간도 더 사용한다.  
  - 하지만 `n`보다 log<sub>2</sub>n이 훨씬 더 작기 때문에 트리 크기가 커질수록 이런 부가 비용을 빠르게 극복할 수 있다.
- **대용량 저장장치**
  - 디스크의 기본 단위는 **블록**이고 연속적인 블록을 **클러스터**라고 부른다.
  - **아이노드**
    - 디스크 블록에 대한 `인덱스`와 `노드`를 합친 단어다.
    - 보통 `직접 블록` 포인터가 12개 있으며, 최대 `4,096 * 12 = 49,512` 바이트 까지 데이터를 보관할 수 있다.
    - 파일이 더 커지면 `n중 간접 블록`을 사용하기 시작한다.
  - **심볼릭 링크** (이로 인해 그래프에 루프가 생긴다.)
  - `fsck` ❓
  - **저널링 시스템** ❓
- **데이터베이스**
  - 2진 트리는 데이터를 메모리에 저장할 때는 훌륭한 방법이지만, 메모리 안에 들어갈 수 없을 정도로 커다란 데이터를 저장할 때는 그리 잘 작동하지 않는다.
  - 트리 노드는 크기가 작은 경향이 있어서 디스크 섹터에 잘 들어맞지 않기 때문이다.
  - DBMS는 보통 **맨 아래의 데이터 저장 메커니즘을 감싼 여러 계층의 인터페이스로 구성된다.**
  - `B 트리`는 균형 트리이지만 2진 트리는 아니며, 공간을 덜 효율적으로 사용하지만 데이터를 저장할 때 균형 2진 트리보다 더 성능이 좋다.
- **인덱스**
- **데이터 이동**
  - `루프 언롤링` 기법
    - Loop unrolling이란 loop를 풀어서 바이너리 코드의 크기는 증가하지만, 하드웨어 가속을 추구하는 기법이다. 
    - 루프 언롤링을 통해서 루프에서 다음 루프로 이동하는 동안 일어나는 동기화, 인덱스 증가, 비교문과 같은 불필요한 계산 시간을 줄여서 프로그램이 수행하는 시간을 줄일 수 있다.
- **벡터를 사용한 I/O**
  - 벡터는 같은 데이터가 연속적으로 모여 있는 고정된 크기의 데이터 구조를 뜻한다
  - TCP는 패킷이 올바른 순서로 전달되게 할 책임이 있다고 설명했다. 소켓으로부터 도착하는 패킷은 사용자 프로그램에게 전달되기 전에 `연속적인 스트림`으로 수집된다.
- **정렬** 📌
  - 정렬을 직접 만들 가능성은 드물지만 `정렬 대상이 포인터 크기보다 크다면 데이터를 직접 정렬하는 대신 데이터를 가리키는 포인터를 재배열하는 방식`으로 정렬하자
  - `qsort`라는 라이브러리 함수는 데이터를 정렬하는 방법은 정의되어 있지만, **데이터를 비교하는 방법은 정의되어 있지 않다.**
  - 그래서 C 언어의 함수 포인터 (함수를 가리키는 포인터)를 함께 전달해야 한다.
- **데이터베이스 샤딩** : 수평 파티셔닝
  - 샤딩의 변종으로 **맵리듀스**가 있다.

# **8장. 프로그래밍 언어 처리**

> 컴퓨터는 프로그램을 어떻게 해석하고 변환하는가?  
> 코드를 작성하면 무슨 일이 벌어지는지 이해하고, 작성한 코드가 어떻게 실행 가능한 **기계어**형태로 변화되는지 알아보자

어셈블리 언어를 쓰면 모든 비트 조합을 외우지 않고 이해하기 쉬운 **나모닉**을 통해 명령어를 쓸 수 있다.  
어셈블리 언어에서는 주소에 이름, 즉 **레이블**을 붙힐 수 있고 코드에 **주석**을 달 수 있다.  
**어셈블리 언어**로 작성된 코드를 읽어서 동등한 **기계어 코드**를 생성해주는 프로그램을 **어셈블러**라고 한다.  
- 이런 변환 과정에서 어셈블러는 `레이블`이나 `심볼`의 값을 결정해 채워 넣어준다.  
  
**고수준 언어**는 어셈블리 언어보다 `더 높은 추상화 단계`에서 작동한다.  
고수준 언어의 소스 코드는 **컴파일러**라는 프로그램에 의해 실행된다.  
컴파일러는 소스 코드를 기계어로 번역, 즉 **컴파일**해준다.  
- 기게어 코드를 다른 말로 `목적 코드`라고도 한다.  
  
**어휘 분석**은 **코드를 기호로부터 단어와 같은 성격의 `토큰`으로 변환하는 과정**이다.  
`토큰`을 추출하는 것만으로는 충분하지 않다. 이름,숫자,연산자 등 토큰 유형도 많기 때문에 각 토큰을 구분해야 한다.  
  
**정규식**은 유닉스 [`grep`명령어](https://man7.org/linux/man-pages/man1/grep.1.html)로 인해 널리 알려졌고, 정규식은 **패턴 매칭**에서 중추적 역할을 한다.  
- 왼쪽에서 오른쪽 순으로 처리된다.
- 어떤 패턴 뒤에 오는 `?`는 패턴이 0번 또는 1번 나타난다 는 뜻
- `*`는 패턴이 0번 이상, `+`는 1번 이상
- `[]` 각괄호로 둘러싸인 문자 집합은 그 집합 안에 있는 어느 한 문자와 매치된다는 뜻 `[abc]`는 a나 b나 c중 하나와 매치될 수 있다는 뜻
- `.`은 아무 글자든 한 글자와 매치될 수 있다
  
앞에서 고수준 언어 컴파일에 대해 설명했는데, 컴파일 할 수도 있지만 **인터프리트**할 수도 있다.  
- 인터프리트냐 컴파일이냐의 선택은 언어 설계 자체 보다는 구현에 의해 이뤄진다.
  
컴파일러는 소스 코드를 구체적인 기계에 맞는 기계어로 변환한다.  
**인터프리터 언어는 실제 하드웨어에서 사용할 기계어를 만들어 내지는 않는다.**  
대신 인터프리터 언어는 **가상머신에서 실행된다.**  
  
일반적으로 컴파일러나 인터프리터는 **파스 트리**를 구성한다.  
- 언어 문법으로부터 만들어낸 `DAG (directed acyclic graph)` **유향 비순환 그래프** 데이터 구조다.
  
각 노드에는 `노드 유형을 표시하는 code`와 `잎의 배열`이 있다.  
인터프리터는 파스 트리를 깊이 우선 순회를 통해 재귀적으로 계산을 한다.  

> 자바와 파이썬에서는 파스 트리를 파일에 저장했다가 나중에 읽어서 실행하는 방식을 사용한다.

**인터프리터 구조**
```

입력 -> [ 어휘 분석 ] , [ 문법 파싱 ] -> 파스 트리 -> 기계n 백엔드

```
어휘 분석과 문법 파싱은 파스 트리를 만드는 프론트 엔드에 해당하며,  
파스 트리는 어떤 **중간 언어**로 표현된다.  
이 중간 언어를 실행할 환경마다 존재하는 기계가 백엔드에 해당한다.  
  
**컴파일러**  
```
                                            -> 기계1 코드 생성기 -> 기계1 어셈블리어 -> 기계1 어셈블러 -> 기계1 기계어
입력 -> [ 어휘 분석 ] , [ 문법 파싱 ] -> 파스 트리  -> 기계2 코드 생성기 -> 기계2 어셈블리어 -> 기계2 어셈블러 -> 기계2 기계어
                                            -> 기계3 코드 생성기 -> 기계3 어셈블리어 -> 기계3 어셈블러 -> 기계3 기계어
```
**코드 생성기**는 특정 대상 기계의 어셈블러를 사용해 어셈블리 언어 코드를 기계어 코드로 만들어낸다.  
  
대부분의 언어 도구에는 **최적화기**라는 추가 단계가 파스 트리와 코드 생성기 사이에 들어간다.  

# **9장. 웹 브라우저**

웹 브라우저는 그 자체가 **가상 머신**이다.  
- 아주 복잡한 명령어 집합을 완전히 소프트웨어로만 구현한 추상적인 컴퓨터다.
- 웹 브라우저는 인터프리터에 속한다.
  
**마크업**은 `본문(텍스트)`와 구분할 수 있는 `마크`를 추가할 수 있는 시스템이다.  
  
브라우저는 **균일 자원 위치 지정자 `URL`** 를 사용해 HTTP 프로토콜을 통해 서버에게 문서를 요청한다.  
  
**DOM:문서 객체 모델**  
브라우저는 DOM 파스 트리를 기계어로 컴파일 할 일은 없고, **깊이 우선 순회**를 하면서 트리를 해석하는 일을 한다.  

# **10장. 애플리케이션 프로그래밍과 시스템 프로그래밍**

**터미널과 장치 드라이버**  
터미널은 `I/O 장치` 이며, 사용자 프로그램은 직접 `I/O 장치`와 통신하지 않고 운영체제가 중간에서 중재한다.  

**문맥 전환**  
컴퓨터는 레지스터 집합이 하나뿐이므로 운영체제는 **한 사용자 프로그램을 다른 사용자 프로그램으로 바꿀 때 마다 레지스터들을 저장하고 복구해야 한다.**  
- MMU 레지스터나 I/O 상태 등도 저장하고 복구해야 한다.  

이때 저장하고 복구해야 하는 모든 내용을 **프로세스 문맥**이라고 부른다.  

> 사용자가 키를 누를 때마다 문맥 전환이 일어나기를 바라지는 않는다.  
> 물리적 장치와 관련한 처리를 담당하는 **장치 드라이버**는 터미널에서 들어오는 문자를 **버퍼 (선입선출)**에 저장하고,  
> 사용자가 키를 누를 때가 아니라 ENTER를 누를 때에만 사용자 프로그램을 **깨운다**


# **11장. 성능 향상을 위한 알고리즘 기법**

> 계산을 효율적으로 하는 것보다 더 나은 것은 바로 계산을 전혀 하지 않는 것이다.  
> 계산을 피하는 두 가지 방법은 **지름길**과 **근삿값 계산**이다.

**표 찾기**  
- MIP 매핑
- 문자 종류 판별
  
**공간을 채우는 곡선**  
공간을 채우는 곡선은 멀리서 보나 가까이 다가가서 보나 비슷해 보이는 **자기 유사성**을 띄며, 이런 곡선은 **프랙탈**이라는 집합의 부분집합이다.

# **12장. 병렬성과 비동기성**

- **멀티태스킹**
- **경합조건**
- **스레드 스케줄러**
  - 스레드 (경량 프로세스)
- **락**
  - 원자적
  - 상호 배제
  - 어드바이저리 락
  - 락 기능은 블로킹이나 논블로킹 모드로 락을 요청할 수 있다. **블로킹**은 시스템이 락을 할당할 수 있을 때 까지 락을 요청한 프로그램을 일시중단시키며, **논블로킹**은 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 통지받게 된다는 뜻이다.
  - **단기 락**
    - 여러 프로세서가 락에 사용하기 위한 **검사 후 설정**이라는 명령어를 제공한다. 이 명령어는 **원자적 명령**이며, `어떤 메모리 위치에 들어있는 값을 1로 설정하고, 원래 그 위치에 들어있던 값을 돌려준다.`
    - 락을 얻으려고 동시에 경합하는 프로세스가 아주 많을 때 잘 작동하는 다른 버전으로 **비교 후 바꾸기**가 있다.
      - 검사 후 설정과 비슷하지만, `한 값만 설정하는 대신 명령어를 호출하는 쪽에서 예전 값과 새 값을 모두 제공한다.`
  - **장기 락**
    - 메모리보다 조금 더 영구적인 저장소에 저장돼야 한다.
    - **파일**을 사용해 구현되는 경우가 자주 있다.
    - 배타적으로 사용할 수 있는 파일을 생성할 수 있고, 가장 먼저 요청한 프로세스가 성공하게 되는 시스템 콜이 있다.
    - 이런 시스템 콜은 내부에 숨겨진 원자적 연산을 더 높은 수준으로 추상화한 것이다.
- **브라우저 자바스크립트**
  - 단일 스레드
  - 이벤트 루프 모델
  - `이벤트 큐 → 이벤트 도착을 기다림 → 이벤트를 큐에서 꺼냄 → 이벤트 코드를 실행`
  - 자바스크립트 인터프리터는 프로그래머에게 단일 스레드 모델을 제공하지만 내부에서는 멀티스레드를 활용하기 때문이다.
  - **비동기 함수와 프로미스**
    - **프로미스**
      - 비동기 콜백 메커니즘을 얻어 라이브러리가 잘못 비동기 연산을 구현하지 못하게 한다??
      - 프로미스 정의는 실행과 분리된다.
    - **비동기 함수는 근본적으로 `인터럽트 할 수 없는 스레드`이다**