
- [ ] URL 문법 중 파라미터와 쿼리스트링의 차이점

# 1. HTTP 개관  

## 1.1 HTTP: 인터넷의 멀티미디어 배달부

HTTP는 **신뢰성 있는 데이터 전송 프로토콜**을 사용하기 때문에 전송 중 손상되거나 꼬이지 않음을 보장한다.  

> HTTP는 신뢰할 수 있거나 메세지 손실이 없는 연결을 요구할 뿐이다.  
> 인터넷 상의 가장 일반적인 두 개의 전송 프로토콜 중에서 TCP는 신뢰할 수 있으며 UDP는 그렇지 않다.  
> 그러므로 HTTP는 연결이 필수는 아니지만 연결 기반인 **TCP 표준에 의존**한다.

- [`mozilla` HTTP와 연결](https://developer.mozilla.org/ko/docs/Web/HTTP/Overview#http%EC%99%80_%EC%97%B0%EA%B2%B0)

## ~~1.2 웹 클라이언트와 서버~~

## 1.3 리소스

웹 서버는 웹 리소스를 관리하고 제공한다.  
- 웹 서버 파일 시스템의 정적파일 : 텍스트 파일, HTML파일, 이미지, 동영상 ...
- 요청에 따라 콘테츠를 생성하는 동적 콘텐츠 리소스
- **어떤 종류의 콘텐츠 소스도 리소스가 될 수 있다.**

### 1.3.1 미디어 타입

인터넷은 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 `MIME (Multipurpose Internet Mail Extensions)` 타입이라는 **데이터 포멧 라벨**을 붙인다.  
- **{주 타입} `/` {부 타입}**
- `Mail`이라는 단어가 있는 이유는 설계된 이유가 메일 시스템에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었기 때문이다.
- HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해 채택되었다.
- [`mozilla` MIME 타입의 전체 목록](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types)
  
웹 서버는 모든  HTTP 객체 데이터(데이터 콘텐츠)와 함께 `MIME`타입을 보내준다.  
웹 브라우저는 서버로 부터 객체를 돌려 받을 때, **다룰 수 있는 객체인지 MIME 타입을 통해 확인한다.**  
  
### 1.3.2 URI (Uniform Resource Identifier)

**통합 자원 식별자**는 리소스를 지목하는 것이다.  
정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.  
  
[`footprint` URI,URL,URN](https://github.com/jdalma/footprints/blob/main/%EC%A0%95%EB%A6%AC/URI.md)
[`RFC3986` Uniform Resource Identifier (URI): Generic Syntax](https://www.ietf.org/rfc/rfc3986.txt)
  
A URI can be further classified as `a locator`, `a name`, or both.  
- **URL (Uniform Resource Locator)**
  - **통합 자원 지시자**는 리소스 식별자의 가장 흔한 형태이다.  
  - 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.  
  - 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려준다.  
- **URN (Uniform Resource Name)**
  - 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 한다.  
  - 리소스를 다른 곳으로 옮기더라도 문제 없이 동작한다.  

## 1.4 트랜잭션

**HTTP 트랜잭션**은 `요청 명령`과 `응답 결과`로 구성되어 있고, `HTTP 메시지`라고 불리는 정형화된 데이터 구조로 이루어져있다.  

### 1.4.1 메서드

**리소스와 행위를 분리**  
- **URI는 리소스만 식별**
- **리소스**와 해당 리소스를 대상으로 하는 **행위**를 분리
  - 리소스 : 회원
  - 행위 : 조회 , 등록 , 삭제 , 변경
- **GET** : 리소스 조회
- **POST** : 요청 데이터 처리 , 주로 등록에 사용
- **PUT** : 리소스를 대체 , 해당 리소스가 없으면 생성
- **PATCH** : 리소스 부분 변경
- **DELETE** : 리소스 삭제
- **HEAD** : GET과 동일하지만 메시지 부분을 제외하고 , 상태 줄과 헤더만 반환
- **OPTIONS** : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명 (주로 CORS에서 사용)
- **CONNECT** : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- **TRACE** : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### 1.4.2 상태 코드

[`mozilla` HTTP response status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)

## ~~1.5 메시지~~

## 1.6 TCP 커넥션

메시지가 어떻게 TCP 커넥션을 통해 한 곳에서 다른 곳으로 옮겨갈까?  

### 1.6.1 TCP/IP

HTTP는 애플리케이션 계층 프토콜이며, TCP/IP는 전송 계층 프로토콜이다.  
- [`footprints` TCP와 UDP](https://github.com/jdalma/footprints/blob/main/%EC%A0%95%EB%A6%AC/TCP%EC%99%80UDP.md)
  
HTTP는 자신의 **메시지 데이터를 전송하기 위해 TCP를 사용한다.**  

### 1.6.2 접속, IP 주소 그리고 포트번호

인터넷 프로토콜 + 호스트 주소 + 포트 번호를 사용해 `TCP/IP` 커넥션을 맺어야 한다.  
  
1. 클라이언트는 서버의 URL에서 호스트 추출
2. 클라이언트는 서버의 호스트 명을 DNS를 통해 IP로 변환
3. 클라이언트는 서버의 URL에서 포트번호가 있으면 추출, 없으면 기본값 `80`
4. 클라이언트는 서버와 TCP 커넥션을 맺는다.
5. 클라이언트와 서버가 통신한다.

### ~~1.6.3 Telnet을 이용한 실제 예제~~

## 1.7 프로토콜 버전

1. `HTTP/0.9`
   - GET 메소드만 지원
   - MIME 타입 미지원
   - HTTP 헤더, 버전 번호 미지원
   - 간단한 HTML 객체를 받아오기 위해 만들어졌지만, 금방 HTTP/1.0으로 대체되었다.
2. `HTTP/1.0`
   - 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리 추가
   - 급성장하던 시기에 만들어진, 잘 동작하는 용례들의 모음에 가깝다.
3. `HTTP/1.0+`
   - (공식적이진 않지만) `keep-alive` 커넥션, 가상 호스팅 지원, 프락시 연결 지원 등등
4. `HTTP/1.1`
   - HTTP 설계의 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거에 집중
5. `HTTP/2.0`
   - [HTTP/2 더 스마트한 규모](https://www.cncf.io/blog/2018/07/03/http-2-smarter-at-scale/)
   - [HTTP/2 소개](https://web.dev/performance-http2/)
   - [`RFC7540` HTTP/2](https://httpwg.org/specs/rfc7540.html#top)
   - [`RFC7540` HTTP/2 WINDOW_UPDATE](https://httpwg.org/specs/rfc7540.html#WINDOW_UPDATE)

  
> **1대로 멀티 도메인을 가능하게 하는 `가상 호스트`**  
> HTTP/1.1 에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있다  
> - 1대의 서버에 여러 고객의 웹 사이트를 넣을 수 있다
> - HTTP 리퀘스트를 보내는 경우에는 호스트 명과 도메인 명을 완전하게 포함한 URI를 지정하거나, 반드시 Host 헤더 필드에서 지정해야 한다  
> [그림으로 배우는 HTTP & Network](http://www.yes24.com/Product/Goods/15894097)

## 1.8 웹의 구성요소

### 1.8.1 프록시 

클라이언트와 서버 사이에 위치한 HTTP 중개자, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달(대개 요청을 수정한 뒤에)한다.  
사용자를 대신해서 서버에 접근하며, 주로 보안을 위해 사용한다.  
  
> 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램으로 , 클라이언트로 부터의 리퀘스트를 서버에 전송하고 , 서버로 부터의 리스폰스를 클라이언트로 전달  
> 리소스 본체를 가진 서버를 `origin server`라고 부른다  
> 프록시 서버를 경유해서 요청과 응답이 릴레이 될 때마다 **Via**헤더 필드에 경유한 호스트 정보를 추가해야 한다  
> 프록시 서버를 사용하는 이유는 **캐시를 사용해서 네트워크 대역등을 호율적으로 사용하는 것과 조직 내에 특정 웹사이트에 대한 엑세스 제한 등등**  
> 프록시와 게이트웨이의 차이는 프록시로 보낸다기 보다는 `origin server`를 보냈지만 중간에 프록시가 끼게 되는 것  

### 1.8.2 캐시

자신을 거쳐가는 문서들 중 자주 찾는 것의 사본을 저장해 두는, **특별한 종류의 HTTP 프록시 서버**다.  
통신량과 통신시간을 절약하고 캐시에 저장된 사본을 동기화하기 위한 많은 기술들이 적용된다.  

### 1.8.3 게이트웨이

다른 서버들의 중개자로 동작하는 특별한 서버다.  
주로 **HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용된다.**  
스스로가 리소스를 갖고 있는 진짜 서버인 것 처럼 요청을 다룬다.  

### 1.8.4 터널 ❓

두 커넥션 사이에서 `raw` 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션이다.  
대표적인 예로, 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이다.  
  
### 1.8.5 에이전트

사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램  
**웹 요청을 만드는 애플리케이션은 뭐든 HTTP 에이전트다.**  
지금까지는 웹브라우저에 대한 HTTP 에이전트를 얘기한 것이므로 이 외에도 여러가지 종류가 더 있다.  
  
예를 들어, 사람의 통제 없이 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 콘텐츠를 받아오는 자동화된 사용자 에이전트가 있다.  
- 스파이더, 웹로봇


## ~~1.9 시작의 끝~~

***

# 2. URL과 리소스

> **리소스?**  
> 이 장에서 아용되는 **리소스**는 텍스트,이미지,동영상 같이 웹에서 사용되는 식별을 할 수 있는 모든 자원을 가리킨다.  
> [`RFC2396` Resource](https://www.rfc-editor.org/rfc/rfc2396#section-1.1)

**리소스를 분류하기 위해서 모든 것은 그만의 표준화된 이름을 가지고 있다.**  

## 2.1 인터넷의 리소스 탐색하기

`URL`은 브라우저가 정보를 찾는데 필요한 리소스의 위치 가리키고, `URL`을 통해 HTTP 및 다른 프로토콜을 통해 접근할 수 있다.  
- 브라우저가 화면 뒤에서 사용자가 원하는 리소스를 얻기 위해서 적절한 프로토콜을 사용하여 메시지를 전송한다.
  
> `URL`은 `URI`의 부분 집합이다. 대부분의 `URL`은 **스킴://서버위치/경로** 구조로 이루어져있다. (단일 방식의 작명 규칙)  
> `URI` = `URL` + `URN`


![](imgs/uri_url.png)
- [출처](https://programming119.tistory.com/194)

많은 사용자는 브라우저가 요청하는 리소스를 가져오는데 사용되는 프로토콜과 접근 방식이 무엇인지 모른다.  
`URL`은 브라우저가 정보를 찾을 때 필요한 정보를 모두 제공하며, **원하는 리소스가 어디에 위치하고 어떻게 가져오는지 정의하는 것**이다.  

## 2.2 URL 문법

리소스들은 여러 스킴을 사용하며 (`HTTP`, `FTP`, `SMTP`), 대부분의 URL은 일반 URL문법을 따르며, 서로 다른 URL 스킴도 형태와 문법 면에서 매우 유사하다.  
  
**`<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`**

## 2.3 단축 URL

### 2.3.1 상대 URL

URL은 **상대 URL**과 **절대 URL** 두 가지로 나뉜다.  

**절대 URL**  
- 리소스에 접근하는데 필요한 모든 정보를 가지고 있다.
  
**상대 URL**  
- URL을 짧게 표기하는 방식
- 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는 `기저(base)`라고 하는 다른 `URL`을 사용해야 한다.
- 특정 `HTML`파일에 `<a>`링크로 작성되어있는 URL은 **문서의 URL을 기준으로 상대 경로로 해석할 수 있다.**
- 컴포넌트가 포함된 리소스의 `기저 URL`에서 알아낼 수 있다.