
# "5장" 웹 서버

## 5.1 다채로운 웹 서버

기능은 달라도, **모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.**  
**웹 서버는 HTTP 및 그와 관련된 TCP처리를 구현한 것이다.**  
- TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

1. **커넥션을 맺는다.**
2. **요청을 받는다.** : HTTP 요청 메시지를 네트워크로부터 읽어들인다.
3. **요청을 처리한다.** : 요청 메시지를 해석하고 행동을 취한다.
4. **리소스에 접근한다.** : 메시지에서 지정한 리소스에 접근한다.
5. **응답을 만든다.** : 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. **응답을 보낸다.** : 응답을 클라이언트에게 돌려준다.
7.  **트랜잭션을 로그로 남긴다.** : 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.
  
### **단계 1 : 클라이언트 커넥션 수락**

1. **새 커넥션 다루기**
   - 클라이언트가 웹 서버에 TCP 커넥션을 요청하면, **웹서버는 커넥션을 맺고 TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인한다.**  
   - 동일한 커넥션이 생성되지 않도록 새 커넥션을 커넥션 목록에 추가한다.  
2. **클라이언트 호스트 명 식별**
   - 대부분의 웹 서버는 `reverse DNS`를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 반환하도록 설정되어 있다.
   - 아파치에서는 `HostnameLookups` 설정 지시자로 호스트 명 룩업을 켤 수 있다.
3. **`ident`를 통해 클라이언트 사용자 알아내기**
   - [`RFC1413` Identification Protocol](https://www.rfc-editor.org/rfc/rfc1413)
   - 몇몇 웹서버는 `IETF ident 프로토콜`을 지원한다. 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해준다.
   - 여러 이유로 인해 보통 `ident 로그 필드`를 `-`으로 채우며, 잘 사용되지 않는다.

### **단계 2 : 요청 메시지 수신**

커넥션에 데이터가 도착하면, 수신자는 네트워크 커넥션에서 데이터를 읽어들이고 파싱하여 요청 메시지를 구성한다.  

1. 요청줄을 파싱하여 `요청 메서드`, `지정된 리소스의 식별자(URI)`, `버전 번호`를 찾는다.
   1. 각 값은 스페이스 한 개로 분리되어 있고, 요청줄은 캐리지 줄바꿈 문자열(CRLF)로 끝난다.
2. 메시지 헤더들을 읽는다. 각 메시지 헤더도 CRLF로 끝난다.
3. 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다 (존재한다면)
4. 요청 본문이 있다면 길이는 `Content-Length` 헤더로 정의하며, 본문을 읽어들인다.
  
#### 메시지의 내부 표현

몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.  

![](imgs/messageExpression.png)

#### 커넥션 I/O 아키텍처 📌

고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다.  
**웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.**  

![](imgs/connectionArchitecture.png)

- **단일 스레드 웹 서버**
  - **한 번에 하나씩 요청을 처리한다.**
  - 하나의 트랜잭션이 완료되면 다음 커넥션이 처리된다.
  - 처리 도중에 다른 커넥션은 무시되어 심각한 성능 문제를 만들어낸다.
- **멀티프로세스와 멀티스레드 웹 서버**
  - 멀티프로세스와 멀티스레드 웹 서버는 **여러 요청을 동시에 처리하기 위해 `여러 개의 프로세스 혹은 고효율 스레드를 할당한다.`**
  - 스레드/프로세스는 필요할 때 마다 만들어질 수도 있고 미리 만들어질 수 있다.
  - 많은 멀티 웹 스레드 서비스는 스레드/프로세스의 개수에 최대 제한을 건다.
- **다중 I/O 서버**
  - 대량의 커넥션을 지원하기 위해, 많은 웹 서버가 채택한 방식이다.
  - **모든 커넥션은 동시에 그 활동을 감시당한다.**
  - 커넥션의 상태가 바뀌면 처리가 수행되고, 완료되면 커넥션은 다음 번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다.
  - 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 해야 할 일이 있을 때뿐이다.
  - 유휴 상태의 커넥션을 기다리지 않는다.
- **다중 멀티스레드 웹 서버**
  - 몇몇 시스템은 자신이 가지고 있는 여러 개의 CPU 시스템을 효율적이게 활용하기 위해 **멀티스레딩**과 **다중화**를 결합한다.
  - 여러 개의 스레드는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다.

### ~~단계 3 : 요청 처리~~

### **단계 4 : 리소스의 매핑과 접근**

웹 서버가 클라이언트에 콘텐츠를 전달하려면, 그전에 요청 메시지의 `URI`에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아서 그 콘텐츠의 원천을 식별해야 한다.  

#### Docroot

일반적으로 **웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약**해 둔다.  
- `httpd.conf` 설정 파일에 `DocumentRoot`줄을 추가하여 아파치 웹 서버의 문서 루트를 설정할 수 있다.
  - `DocumentRoot /usr/local/httpd/files`

  
**가상 호스팅된 docroot**  *18장에서 자세히..*
- 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅한다.
- 가상 호스팅 웹 서버는 `URI`, `Host Header`, `IP`, `호스트명`을 이용해 문서 루트를 식별한다.
- 하나의 웹 서버위 에서 두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 할 수 있다.
  
#### 디렉터리 목록

웹 서버는, **경로가 파일이 아닌 디렉터리를 가리키는, 디렉터리 URL에 대한 요청을 받을 수 있다.**  
클라이언트가 디렉터리 URL을 요청했을 때 다음과 같이 몇 가지 행동을 취할 수 있다.  
1. 에러를 반환
2. 디렉터리 대신 특별한 `색인 파일`을 반환
3. 디렉터리를 탐색해서 그 내용을 담은 `HTML 페이지`를 반환
  
기본 색인 파일과 디렉터리 색인 기능이 없다면, 많은 웹 서버는 자동으로 파일들을 나열하는 HTML 파일을 반환한다.

#### 서버사이드 인클루드

JSP 처럼 서버사이드 렌더링을 의미하는 것 같다.

#### 접근 제어

웹 서버는 클라이언트의 `IP`주소에 근거하여 접근을 제어할 수 있고, 리소스의 비밀번호를 물어볼 수도 있다.  

### **단계 5 : 응답 만들기**

#### 응답 엔티티

- 응답 본문의 `MIME` 타입을 서술하는 `Content-Type`헤더
- 응답 본문의 길이를 서술하는 `Content-Length`헤더
- 실제 응답 본문의 내용

#### MIME 타입 결정하기

웹 서버는 **응답 본문의 MIME 타입을 결정해야하는 책임이 있다.**  
MIME 타입과 리소스를 연결하는 여러가지 방법이다.
  
1. `mime.types`
   - 파일 이름의 확장자를 사용
   - 웹 서버는 각 리소스의 MIME 타입을 계산하기 위해 **확장자별 MIME 타입이 담겨있는 파일을 탐색**한다. (서버 MIME 타입 테이블)
   - **확장자 기반 타입 연계**가 가장 흔한 방법이다.
2. `매직 타이핑`
   - 아파치 웹 서버는 각 파일의 MIME 타입을 알아내기 위해 파일의 내용을 검사해서 알려진 패턴에 대한 테이블(매직 파일이라 불린다.)에 해당하는 패턴이 있는지 찾아볼 수 있다.
   - 느리긴 하지만, 파일이 표준 확장자 없이 작성되어 있을 경우 유용하다
3. `유형 명시 (Explicit typing)`
   - 특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이 어떤 MIME 타입을 갖도록 웹 서버를 설정할 수 있다.
4. `유형 협상 (Type negotiation)`
   - 어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다.

#### 리다이렉션 📌

`Location` 응답 헤더는 콘텐츠의 위치에 대한 URI를 포함한다.  

- **영구히 리소스가 옮겨진 경우**
  - 클라이언트는 북마크를 갱신할 수 있다.
  - `301 Moved Permanently`
- **임시로 리소스가 옮겨진 경우**
  - 임시적인 변경이기 때문에 서버는 클라이언트가 나중에는 원래 URL로 찾아오게 하고, 북마크도 갱신하지 않기를 원한다.
  - `303 See Other`, `307 Temporary Redirect`
- **URL 증강**
  - 서버는 종종 문맥 정보를 포함시키기 위해 재작성된 URL로 리다이렉트 한다. `fat URL`
  - 서버는 상태 정보를 내포한 새 URL을 생성하고 사용자를 이 새 URL로 리다이렉트 한다.
  - **트랜잭션 간 상태를 유지하는 유용한 방법**
  - `303 See Other`, `307 Temporary Redirect`
- **부하 균형**
  - 만약 과부하된 서버가 요청을 받으면, 서버는 클라이언트를 다른 서버로 리다이렉트 할 수 있다.
  - `303 See Other`, `307 Temporary Redirect`
- **친밀한 다른 서버가 있을 때**
  - 서버는 클라이언트를 그 클라이언트에 대한 정보를 갖고 있는 다른 서버로 리다이렉트 할 수 있다.
  - `303 See Other`, `307 Temporary Redirect`
- **디렉터리 이름 정규화**
  - 클라이언트가 디렉터리 이름에 대한 URI에서 `/`을 빠뜨렸다면, 대부분의 웹 서버는 슬래시를 추가한 URI로 리다이렉트한다.


### **단계 6 : 응답 보내기**

서버는 여러 클라이언트에 대한 많은 커넥션을 가질 수 있다.  
**서버는 커넥션 상태를 추적해야 하며 지속적인 커넥션은 특별히 주의해서 다루어야 한다.**  

### **단계 7 : 로깅**

트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다. (21장 에서)