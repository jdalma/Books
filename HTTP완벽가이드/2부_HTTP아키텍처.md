<!-- TOC -->

- ["5장" 웹 서버](#5%EC%9E%A5-%EC%9B%B9-%EC%84%9C%EB%B2%84)
    - [다채로운 웹 서버](#%EB%8B%A4%EC%B1%84%EB%A1%9C%EC%9A%B4-%EC%9B%B9-%EC%84%9C%EB%B2%84)
        - [**단계 1 : 클라이언트 커넥션 수락**](#%EB%8B%A8%EA%B3%84-1--%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%BB%A4%EB%84%A5%EC%85%98-%EC%88%98%EB%9D%BD)
        - [**단계 2 : 요청 메시지 수신**](#%EB%8B%A8%EA%B3%84-2--%EC%9A%94%EC%B2%AD-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%88%98%EC%8B%A0)
            - [메시지의 내부 표현](#%EB%A9%94%EC%8B%9C%EC%A7%80%EC%9D%98-%EB%82%B4%EB%B6%80-%ED%91%9C%ED%98%84)
            - [커넥션 I/O 아키텍처 📌](#%EC%BB%A4%EB%84%A5%EC%85%98-io-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-)
        - [~~단계 3 : 요청 처리~~](#%EB%8B%A8%EA%B3%84-3--%EC%9A%94%EC%B2%AD-%EC%B2%98%EB%A6%AC)
        - [**단계 4 : 리소스의 매핑과 접근**](#%EB%8B%A8%EA%B3%84-4--%EB%A6%AC%EC%86%8C%EC%8A%A4%EC%9D%98-%EB%A7%A4%ED%95%91%EA%B3%BC-%EC%A0%91%EA%B7%BC)
            - [Docroot](#docroot)
            - [디렉터리 목록](#%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EB%AA%A9%EB%A1%9D)
            - [서버사이드 인클루드](#%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EC%9D%B8%ED%81%B4%EB%A3%A8%EB%93%9C)
            - [접근 제어](#%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4)
        - [**단계 5 : 응답 만들기**](#%EB%8B%A8%EA%B3%84-5--%EC%9D%91%EB%8B%B5-%EB%A7%8C%EB%93%A4%EA%B8%B0)
            - [응답 엔티티](#%EC%9D%91%EB%8B%B5-%EC%97%94%ED%8B%B0%ED%8B%B0)
            - [MIME 타입 결정하기](#mime-%ED%83%80%EC%9E%85-%EA%B2%B0%EC%A0%95%ED%95%98%EA%B8%B0)
            - [리다이렉션 📌](#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98-)
        - [**단계 6 : 응답 보내기**](#%EB%8B%A8%EA%B3%84-6--%EC%9D%91%EB%8B%B5-%EB%B3%B4%EB%82%B4%EA%B8%B0)
        - [**단계 7 : 로깅**](#%EB%8B%A8%EA%B3%84-7--%EB%A1%9C%EA%B9%85)
- ["6장" 프록시](#6%EC%9E%A5-%ED%94%84%EB%A1%9D%EC%8B%9C)
    - [웹 중개자](#%EC%9B%B9-%EC%A4%91%EA%B0%9C%EC%9E%90)
        - [개인 프록시와 공유 프록시](#%EA%B0%9C%EC%9D%B8-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EA%B3%B5%EC%9C%A0-%ED%94%84%EB%A1%9D%EC%8B%9C)
        - [프록시 vs 게이트웨이](#%ED%94%84%EB%A1%9D%EC%8B%9C-vs-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)
    - [프록시를 왜 사용하고 종류는 뭐가 있나?](#%ED%94%84%EB%A1%9D%EC%8B%9C%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B3%A0-%EC%A2%85%EB%A5%98%EB%8A%94-%EB%AD%90%EA%B0%80-%EC%9E%88%EB%82%98)
    - [프록시는 어디에 있는가?](#%ED%94%84%EB%A1%9D%EC%8B%9C%EB%8A%94-%EC%96%B4%EB%94%94%EC%97%90-%EC%9E%88%EB%8A%94%EA%B0%80)
        - [프록시 서버 배치](#%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84-%EB%B0%B0%EC%B9%98)
        - [프록시 계층](#%ED%94%84%EB%A1%9D%EC%8B%9C-%EA%B3%84%EC%B8%B5)
        - [어떻게 프록시가 트래픽을 처리하는가](#%EC%96%B4%EB%96%BB%EA%B2%8C-%ED%94%84%EB%A1%9D%EC%8B%9C%EA%B0%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94%EA%B0%80)
        - [클라이언트 프록시 설정](#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%A4%EC%A0%95)
    - [~~6.5 프록시 요청의 미묘한 특징들~~](#65-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%9A%94%EC%B2%AD%EC%9D%98-%EB%AF%B8%EB%AC%98%ED%95%9C-%ED%8A%B9%EC%A7%95%EB%93%A4)
    - [메시지 추적](#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%B6%94%EC%A0%81)
        - [Via 헤더](#via-%ED%97%A4%EB%8D%94)
        - [TRACE 메서드](#trace-%EB%A9%94%EC%84%9C%EB%93%9C)
- ["7장" 캐시](#7%EC%9E%A5-%EC%BA%90%EC%8B%9C)
    - [적중과 부적중](#%EC%A0%81%EC%A4%91%EA%B3%BC-%EB%B6%80%EC%A0%81%EC%A4%91)
        - [재검사 Revalidation](#%EC%9E%AC%EA%B2%80%EC%82%AC-revalidation)
        - [적중률](#%EC%A0%81%EC%A4%91%EB%A5%A0)
        - [바이트 적중률](#%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%A0%81%EC%A4%91%EB%A5%A0)
        - [적중과 부적중의 구별](#%EC%A0%81%EC%A4%91%EA%B3%BC-%EB%B6%80%EC%A0%81%EC%A4%91%EC%9D%98-%EA%B5%AC%EB%B3%84)
    - [캐시 토폴로지](#%EC%BA%90%EC%8B%9C-%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80)
        - [개인 전용 캐시 private cache](#%EA%B0%9C%EC%9D%B8-%EC%A0%84%EC%9A%A9-%EC%BA%90%EC%8B%9C-private-cache)
        - [공용 프록시 캐시 public cache](#%EA%B3%B5%EC%9A%A9-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%BA%90%EC%8B%9C-public-cache)
        - [프록시 캐시 계층들](#%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%BA%90%EC%8B%9C-%EA%B3%84%EC%B8%B5%EB%93%A4)
        - [캐시망, 컨텐츠 라우팅, 피어링](#%EC%BA%90%EC%8B%9C%EB%A7%9D-%EC%BB%A8%ED%85%90%EC%B8%A0-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%94%BC%EC%96%B4%EB%A7%81)
    - [캐시 처리의 7단계](#%EC%BA%90%EC%8B%9C-%EC%B2%98%EB%A6%AC%EC%9D%98-7%EB%8B%A8%EA%B3%84)
    - [사본을 신선하게 유지하기](#%EC%82%AC%EB%B3%B8%EC%9D%84-%EC%8B%A0%EC%84%A0%ED%95%98%EA%B2%8C-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0)
        - [문서 만료, 유효기간과 나이](#%EB%AC%B8%EC%84%9C-%EB%A7%8C%EB%A3%8C-%EC%9C%A0%ED%9A%A8%EA%B8%B0%EA%B0%84%EA%B3%BC-%EB%82%98%EC%9D%B4)
        - [서버 재검사](#%EC%84%9C%EB%B2%84-%EC%9E%AC%EA%B2%80%EC%82%AC)
        - [조건부 메서드와의 재검사](#%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80%EC%9D%98-%EC%9E%AC%EA%B2%80%EC%82%AC)
        - [If-Modified-Since: 날짜 재검사](#if-modified-since-%EB%82%A0%EC%A7%9C-%EC%9E%AC%EA%B2%80%EC%82%AC)
        - [If-None-Match : 엔티티 태그 재검사](#if-none-match--%EC%97%94%ED%8B%B0%ED%8B%B0-%ED%83%9C%EA%B7%B8-%EC%9E%AC%EA%B2%80%EC%82%AC)
    - [캐시 제어](#%EC%BA%90%EC%8B%9C-%EC%A0%9C%EC%96%B4)
        - [no-cache와 no-store 응답 헤더](#no-cache%EC%99%80-no-store-%EC%9D%91%EB%8B%B5-%ED%97%A4%EB%8D%94)
        - [Max-Age 응답 헤더](#max-age-%EC%9D%91%EB%8B%B5-%ED%97%A4%EB%8D%94)
        - [Expires 응답 헤더](#expires-%EC%9D%91%EB%8B%B5-%ED%97%A4%EB%8D%94)
        - [Must-Revalidate 응답 헤더](#must-revalidate-%EC%9D%91%EB%8B%B5-%ED%97%A4%EB%8D%94)
        - [휴리스틱 만료](#%ED%9C%B4%EB%A6%AC%EC%8A%A4%ED%8B%B1-%EB%A7%8C%EB%A3%8C)
        - [클라이언트 신선도 제약](#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%8B%A0%EC%84%A0%EB%8F%84-%EC%A0%9C%EC%95%BD)
    - [캐시 제어 설정](#%EC%BA%90%EC%8B%9C-%EC%A0%9C%EC%96%B4-%EC%84%A4%EC%A0%95)
        - [아파치로 HTTP 헤더 제어하기](#%EC%95%84%ED%8C%8C%EC%B9%98%EB%A1%9C-http-%ED%97%A4%EB%8D%94-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0)
        - [HTML-EQUIV를 통한 HTML 캐시 제어](#html-equiv%EB%A5%BC-%ED%86%B5%ED%95%9C-html-%EC%BA%90%EC%8B%9C-%EC%A0%9C%EC%96%B4)
    - [캐시 신선도를 계산하는 알고리즘](#%EC%BA%90%EC%8B%9C-%EC%8B%A0%EC%84%A0%EB%8F%84%EB%A5%BC-%EA%B3%84%EC%82%B0%ED%95%98%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
- ["8장" 통합점: 게이트웨이, 터널, 릴레이](#8%EC%9E%A5-%ED%86%B5%ED%95%A9%EC%A0%90-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%ED%84%B0%EB%84%90-%EB%A6%B4%EB%A0%88%EC%9D%B4)
    - [게이트워이](#%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%8C%EC%9D%B4)
        - [클라이언트 측 게이트웨이와 서버 측 게이트웨이](#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4%EC%99%80-%EC%84%9C%EB%B2%84-%EC%B8%A1-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)
    - [프로토콜 게이트 웨이](#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EA%B2%8C%EC%9D%B4%ED%8A%B8-%EC%9B%A8%EC%9D%B4)
        - [HTTP/* : 서버 측 웹 게이트웨이](#http--%EC%84%9C%EB%B2%84-%EC%B8%A1-%EC%9B%B9-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)
        - [HTTP/HTTPS : 서버 측 보안 게이트웨이](#httphttps--%EC%84%9C%EB%B2%84-%EC%B8%A1-%EB%B3%B4%EC%95%88-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)
        - [HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이](#httpshttp--%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1-%EB%B3%B4%EC%95%88-%EA%B0%80%EC%86%8D-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)
    - [리소스 게이트웨이](#%EB%A6%AC%EC%86%8C%EC%8A%A4-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4)

<!-- /TOC -->


# "5장" 웹 서버

## 5.1 다채로운 웹 서버

기능은 달라도, **모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다.**  
**웹 서버는 HTTP 및 그와 관련된 TCP처리를 구현한 것이다.**  
- TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

1. **커넥션을 맺는다.**
2. **요청을 받는다.** : HTTP 요청 메시지를 네트워크로부터 읽어들인다.
3. **요청을 처리한다.** : 요청 메시지를 해석하고 행동을 취한다.
4. **리소스에 접근한다.** : 메시지에서 지정한 리소스에 접근한다.
5. **응답을 만든다.** : 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. **응답을 보낸다.** : 응답을 클라이언트에게 돌려준다.
7.  **트랜잭션을 로그로 남긴다.** : 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.
  
### **단계 1 : 클라이언트 커넥션 수락**

1. **새 커넥션 다루기**
   - 클라이언트가 웹 서버에 TCP 커넥션을 요청하면, **웹서버는 커넥션을 맺고 TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인한다.**  
   - 동일한 커넥션이 생성되지 않도록 새 커넥션을 커넥션 목록에 추가한다.  
2. **클라이언트 호스트 명 식별**
   - 대부분의 웹 서버는 `reverse DNS`를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 반환하도록 설정되어 있다.
   - 아파치에서는 `HostnameLookups` 설정 지시자로 호스트 명 룩업을 켤 수 있다.
3. **`ident`를 통해 클라이언트 사용자 알아내기**
   - [`RFC1413` Identification Protocol](https://www.rfc-editor.org/rfc/rfc1413)
   - 몇몇 웹서버는 `IETF ident 프로토콜`을 지원한다. 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해준다.
   - 여러 이유로 인해 보통 `ident 로그 필드`를 `-`으로 채우며, 잘 사용되지 않는다.

### **단계 2 : 요청 메시지 수신**

커넥션에 데이터가 도착하면, 수신자는 네트워크 커넥션에서 데이터를 읽어들이고 파싱하여 요청 메시지를 구성한다.  

1. 요청줄을 파싱하여 `요청 메서드`, `지정된 리소스의 식별자(URI)`, `버전 번호`를 찾는다.
   1. 각 값은 스페이스 한 개로 분리되어 있고, 요청줄은 캐리지 줄바꿈 문자열(CRLF)로 끝난다.
2. 메시지 헤더들을 읽는다. 각 메시지 헤더도 CRLF로 끝난다.
3. 헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다 (존재한다면)
4. 요청 본문이 있다면 길이는 `Content-Length` 헤더로 정의하며, 본문을 읽어들인다.
  
#### 메시지의 내부 표현

몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.  

![](imgs/messageExpression.png)

#### 커넥션 I/O 아키텍처 📌

고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다.  
**웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.**  

![](imgs/connectionArchitecture.png)

- **단일 스레드 웹 서버**
  - **한 번에 하나씩 요청을 처리한다.**
  - 하나의 트랜잭션이 완료되면 다음 커넥션이 처리된다.
  - 처리 도중에 다른 커넥션은 무시되어 심각한 성능 문제를 만들어낸다.
- **멀티프로세스와 멀티스레드 웹 서버**
  - 멀티프로세스와 멀티스레드 웹 서버는 **여러 요청을 동시에 처리하기 위해 `여러 개의 프로세스 혹은 고효율 스레드를 할당한다.`**
  - 스레드/프로세스는 필요할 때 마다 만들어질 수도 있고 미리 만들어질 수 있다.
  - 많은 멀티 웹 스레드 서비스는 스레드/프로세스의 개수에 최대 제한을 건다.
- **다중 I/O 서버**
  - 대량의 커넥션을 지원하기 위해, 많은 웹 서버가 채택한 방식이다.
  - **모든 커넥션은 동시에 그 활동을 감시당한다.**
  - 커넥션의 상태가 바뀌면 처리가 수행되고, 완료되면 커넥션은 다음 번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다.
  - 어떤 커넥션에 대해 작업을 수행하는 것은 그 커넥션에 실제로 해야 할 일이 있을 때뿐이다.
  - 유휴 상태의 커넥션을 기다리지 않는다.
- **다중 멀티스레드 웹 서버**
  - 몇몇 시스템은 자신이 가지고 있는 여러 개의 CPU 시스템을 효율적이게 활용하기 위해 **멀티스레딩**과 **다중화**를 결합한다.
  - 여러 개의 스레드는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다.

### ~~단계 3 : 요청 처리~~

### **단계 4 : 리소스의 매핑과 접근**

웹 서버가 클라이언트에 콘텐츠를 전달하려면, 그전에 요청 메시지의 `URI`에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아서 그 콘텐츠의 원천을 식별해야 한다.  

#### Docroot

일반적으로 **웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 예약**해 둔다.  
- `httpd.conf` 설정 파일에 `DocumentRoot`줄을 추가하여 아파치 웹 서버의 문서 루트를 설정할 수 있다.
  - `DocumentRoot /usr/local/httpd/files`

  
**가상 호스팅된 docroot**  *18장에서 자세히..*
- 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로 한 웹 서버에서 여러 개의 웹 사이트를 호스팅한다.
- 가상 호스팅 웹 서버는 `URI`, `Host Header`, `IP`, `호스트명`을 이용해 문서 루트를 식별한다.
- 하나의 웹 서버위 에서 두 개의 사이트가 완전히 분리된 콘텐츠를 갖고 호스팅 되도록 할 수 있다.
  
#### 디렉터리 목록

웹 서버는, **경로가 파일이 아닌 디렉터리를 가리키는, 디렉터리 URL에 대한 요청을 받을 수 있다.**  
클라이언트가 디렉터리 URL을 요청했을 때 다음과 같이 몇 가지 행동을 취할 수 있다.  
1. 에러를 반환
2. 디렉터리 대신 특별한 `색인 파일`을 반환
3. 디렉터리를 탐색해서 그 내용을 담은 `HTML 페이지`를 반환
  
기본 색인 파일과 디렉터리 색인 기능이 없다면, 많은 웹 서버는 자동으로 파일들을 나열하는 HTML 파일을 반환한다.

#### 서버사이드 인클루드

JSP 처럼 서버사이드 렌더링을 의미하는 것 같다.

#### 접근 제어

웹 서버는 클라이언트의 `IP`주소에 근거하여 접근을 제어할 수 있고, 리소스의 비밀번호를 물어볼 수도 있다.  

### **단계 5 : 응답 만들기**

#### 응답 엔티티

- 응답 본문의 `MIME` 타입을 서술하는 `Content-Type`헤더
- 응답 본문의 길이를 서술하는 `Content-Length`헤더
- 실제 응답 본문의 내용

#### MIME 타입 결정하기

웹 서버는 **응답 본문의 MIME 타입을 결정해야하는 책임이 있다.**  
MIME 타입과 리소스를 연결하는 여러가지 방법이다.
  
1. `mime.types`
   - 파일 이름의 확장자를 사용
   - 웹 서버는 각 리소스의 MIME 타입을 계산하기 위해 **확장자별 MIME 타입이 담겨있는 파일을 탐색**한다. (서버 MIME 타입 테이블)
   - **확장자 기반 타입 연계**가 가장 흔한 방법이다.
2. `매직 타이핑`
   - 아파치 웹 서버는 각 파일의 MIME 타입을 알아내기 위해 파일의 내용을 검사해서 알려진 패턴에 대한 테이블(매직 파일이라 불린다.)에 해당하는 패턴이 있는지 찾아볼 수 있다.
   - 느리긴 하지만, 파일이 표준 확장자 없이 작성되어 있을 경우 유용하다
3. `유형 명시 (Explicit typing)`
   - 특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이 어떤 MIME 타입을 갖도록 웹 서버를 설정할 수 있다.
4. `유형 협상 (Type negotiation)`
   - 어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다.

#### 리다이렉션 📌

`Location` 응답 헤더는 콘텐츠의 위치에 대한 URI를 포함한다.  

- **영구히 리소스가 옮겨진 경우**
  - 클라이언트는 북마크를 갱신할 수 있다.
  - `301 Moved Permanently`
- **임시로 리소스가 옮겨진 경우**
  - 임시적인 변경이기 때문에 서버는 클라이언트가 나중에는 원래 URL로 찾아오게 하고, 북마크도 갱신하지 않기를 원한다.
  - `303 See Other`, `307 Temporary Redirect`
- **URL 증강**
  - 서버는 종종 문맥 정보를 포함시키기 위해 재작성된 URL로 리다이렉트 한다. `fat URL`
  - 서버는 상태 정보를 내포한 새 URL을 생성하고 사용자를 이 새 URL로 리다이렉트 한다.
  - **트랜잭션 간 상태를 유지하는 유용한 방법**
  - `303 See Other`, `307 Temporary Redirect`
- **부하 균형**
  - 만약 과부하된 서버가 요청을 받으면, 서버는 클라이언트를 다른 서버로 리다이렉트 할 수 있다.
  - `303 See Other`, `307 Temporary Redirect`
- **친밀한 다른 서버가 있을 때**
  - 서버는 클라이언트를 그 클라이언트에 대한 정보를 갖고 있는 다른 서버로 리다이렉트 할 수 있다.
  - `303 See Other`, `307 Temporary Redirect`
- **디렉터리 이름 정규화**
  - 클라이언트가 디렉터리 이름에 대한 URI에서 `/`을 빠뜨렸다면, 대부분의 웹 서버는 슬래시를 추가한 URI로 리다이렉트한다.


### **단계 6 : 응답 보내기**

서버는 여러 클라이언트에 대한 많은 커넥션을 가질 수 있다.  
**서버는 커넥션 상태를 추적해야 하며 지속적인 커넥션은 특별히 주의해서 다루어야 한다.**  

### **단계 7 : 로깅**

트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다. (21장 에서)

***

# "6장" 프록시

## 웹 중개자

프록시는 **클라이언트와 서버 사이에 위치하여 그들 사이의 HTTP 메시지를 정리하는 중개인처럼 동작한다.**  
HTTP 프록시 서버는 웹 서버이기도 하고 웹 클라이언트 이기도 하다.  

```
          요청 →       요청 →
클라이언트         프록시        서버
          ← 응답       ← 응답
```

### 개인 프록시와 공유 프록시

프록시 서버는 하나의 클라이언트가 독점적으로 사용할 수도 있고, 여러 클라이언트가 공유할 수도 있다.  

**공유 프록시**  
- 대부분의 프록시는 공용이며, 중앙 집중형 프록시를 관리하는게 더 비용효율이 높고 쉽다.
- **캐시 프록시 서버**와 같은 몇몇 프록시 애플리케이션은 프록시를 이용하는 사용자가 많을수록 유리하다.

  
**개인 프록시**  
- 클라이언트 컴퓨터에서 직접 실행되는 형태로 흔하진 않지만 꾸준히 사용되고 있다.  
- 여러 브라우저 보조 제품들 또는 ISP 서비스에서 브라우저의 기능을 확장하거나 성능을 개선하거나 광고를 운영하기 위해 **작은 프록시를 사용자의 컴퓨터에서 직접 실행하기도 한다.**

### 프록시 vs 게이트웨이

- **프록시** : **같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결**  
- **게이트웨이** : **클라이언트와 서버가 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해주는 `프로토콜 변환기`처럼 동작한다.**

하지만 둘의 차이점은 모호하다.  
브라우저와 서버는 다른 버전의 HTTP를 구현하기 때문에, 프록시는 때때로 **약간의 프로토콜 변환을 하기도 한다.**  
그리고 `상용 프록시 서버`는 **SSL 보안 프로토콜**, **SOCKS 방화벽**, **FTP 접근**, 그리고 **웹 기반 애플리케이션을 지원하기 위해 게이트웨이 기능을 구현**한다.  

## 프록시를 왜 사용하고 종류는 뭐가 있나?

프록시 서버는 **보안을 개선**하고, **성능을 높여주며**, **비용을 절약**한다.  
프록시 서버는 `모든 HTTP 트래픽을 들여다보고 건드릴 수 있기 때문에, 부가적인 가치를 주는 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있다.`  

**사용 예시**  
1. **어린이 필터**
2. **문서 접근 제어자**
   - 중앙 프록시 서버에서 접근 제어를 설정
3. **보안 방화벽**
   - 보안을 강화하기 위해 조직안에 들어오거나 나가는 **응용 레벨 프로토콜**의 흐름을 통제
4. **웹 캐시**
5. **대리 프록시**
   - 웹 서버인 것처럼 위장하며, **대리 혹은 리버스 프록시**라 불리는 이들은 **진짜 웹 서버 요청을 받지만 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션을 시작한다.**
   - 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용될 수 있다.
   - 콘텐츠 라우팅 기능과 결합되어 주문형 복제 컨텐츠의 분산 네트워크를 만들기 위해 사용될 수 있다.
6. **콘텐츠 라우터**
   - 프록시 서버는 **인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작할 수 있다.**
   - VIP고객의 요청은 가까운 캐시 프록시에게 보내는 행위
7. **트랜스코더**
   - 프록시 서버는 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정할 수 있다.
   - 크기를 줄이기위해 `GIF`를 `JPF` 이미지로 변환하거나, 색 강도를 줄일 수 있다.
   - 텍스트 파일을 압축하거나, 외국어 문서로 변환하는 것 또한 가능하다.
8. **익명화 프록시**
   - HTTP 메시지에서 신원을 식별할 수 있는 특성들(클라이언트 IP 주소, Form 헤더, Referer 헤더, 쿠키, URI 세션 아이디)을 적극적으로 제거함으로써 **개인정보보호와 익명성 보장**에 기여한다.

## 프록시는 어디에 있는가?

어떻게 사용할지에 따라서 프록시는 어디에든 배치할 수 있다.  

### 프록시 서버 배치

![](imgs/proxyCollocate.png)

1. **출구(Egress) 프록시**
   - 로컬 네트워크와 인터넷 사이를 오가는 트래픽을 제어하기 위해 프록시를 로컬 네트워크의 출구에 놓을 수 있다.
   - 회사 밖의 해커들을 막는 방화벽을 제공하거나, 부적절한 콘텐츠를 막고 인터넷 트래픽의 성능을 개선하기 위해 사용할 수 있다.
2. **접근(입구) 프록시**
   - 외부로부터의 모든 요청을 종합적으로 처리하기 위해 프록시는 ISP 접근 지점에 위치하기도 한다.
   - 인터넷 대역폭 비용을 줄이기 위해 캐시 프록시를 사용해 많이 찾는 문서들의 사본을 저장한다.
3. **대리 프록시**
   - **네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청할 수 있다.**
   - 또한 보안 기능을 추가하거나 캐시를 웹 서버 앞에 놓아 성능을 개선할 수도 있다.
   - **일반적으로 웹 서버의 이름과 IP 주소로 스스로를 가장하기 때문에, 모든 요청은 서버가 아닌 이 프록시로 가게 된다.**
4. **네트워크 교환 프록시**
   - 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고 트래픽 흐름을 감시하기 위해, 네트워크 사이의 인터넷 피어링 교환 지점들에 놓일 수 있다.

### 프록시 계층

**프록시 들은 `프록시 계층`이라고 불리는 연쇄를 구성할 수 있다.**  
- 부모와 자식의 관계를 갖는다
- 부모 : 다음번 인바운드 프록시(서버에 가까운 쪽)
- 자식 : 다음번 아웃바운드 프록시(클라이언트 가까운 쪽)

**프록시 계층 콘텐츠 라우팅**
- 프록시 계층의 구성이 정적이어야 하는 것은 아니다.
- **여러가지 판단 근거에 의해 `메시지를 다양하고 유동적인` 프록시 서버와 원 서버들의 집합에게 보낼 수 있다.**
  - **부하 균형** : 자식 프록시는 부하를 분산하기 위해 부모들의 작업량 수준에 근거하여 부모 프록시를 고른다.
  - **지리적 인접성에 근거한 라우팅** : 자식 프록시는 원 서버의 지역을 담당하는 부모를 선택할 수 있다.
  - **프로토콜/타입 라우팅**
  - **유료 서비스 가입자를 위한 라우팅**

### 어떻게 프록시가 트래픽을 처리하는가

> HTTP 트래픽이 어떻게 프록시로 향하는 길을 찾아내지?
  
**클라이언트 트래픽이 프록시로 가도록 만드는 방법**  
1. **클라이언트를 수정한다.**
   - 많은 웹 클라이언트들은 **수동 혹은 자동 프록시 설정을 지원한다.**
2. **네트워크를 수정한다.**
   - 클라이언트는 알지도 못하게, **스위칭 장치와 라우팅 장치**를 통해 네트워크 인프라를 가로채서 웹 트래픽을 프록시로 가도록 조정할 수 있다. (**인터셉트 프록시**)
3. **DNS 이름공간을 수정한다.**
   - DNS 이름 테이블을 수동으로 편집하거나 사용할 적절한 프록시나 서버를 계산해주는 특별한 동적 DNS 서버를 이용해서 조정할 수 있다.
4. **웹 서버를 수정한다**
   - 몇몇 웹 서버는 HTTP 리다이렉션 명령(응답 코드305)을 통해 프록시에게 요청하도록 할 수 있다.

### 클라이언트 프록시 설정

모든 현대적인 브라우저는 프록시를 사용할 수 있도록 설정할 수 있다.  

1. **수동 설정**
   - 명시적으로 설정
2. **브라우저 기본 설정**
3. **프록시 자동 설정** Proxy Auto-Configuration
   - 자바스크립트 프록시 자동 설정 파일에 대한 URI를 제공할 수 있다. (PAC파일을 직접 자바스크립트로 작성하는 것)
   - 클라이언트는 어떤 프록시 서버를 써야하는지 판단하기 위해 자바스크립트 파일을 가져와서 실행한다.
4. **WPAD 프록시 발견**
   - 대부분의 브라우저는 **웹 프록시 자동발견 프로토콜 (Web Proxy Autodiscovery Protocol)**을 통해 자동설정 파일을 다운 받을 수 있는 설정 서버를 자동으로 찾는다.
   - 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘

## ~~6.5 프록시 요청의 미묘한 특징들~~

## 메시지 추적

### Via 헤더

메시지가 지나는 각 중간노드 (프록시나 게이트웨이)의 정보를 나열한다.  
**메시지의 전달을 추적**하고, **메시지 루프를 진단**하고, **요청을 보내고 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력**을 알아보기 위헤 사용된다. (프로토콜 변환도 기록한다.)  
  
각 `Via waypoint`는 최대 4개의 구성요소를 담을 수 있다.
1. 프로토콜 이름
2. 프로토콜 버전
3. 노드 이름
4. 코멘트

**요청 메시지와 응답 메시지 모두 프록시를 지나므로 둘 모두 `Via 헤더`를 가진다.**  

### TRACE 메서드

HTTP 프록시 네트워크를 통해 홉에서 홉으로 전달될 때 마다 메시지의 내용이 어떻게 변하는지 관찰하기 위해 `TRACE`메소드를 사용한다.  
- 프록시 흐름을 디버깅하는데 매우 유용하지만, 널리 구현되진 않았다

`Max-Forwards` 헤더를 통해 거치는 프록시 홉 개수를 제한할 수 있다.  


***

# "7장" 캐시

웹 캐시는 **자주 쓰이는 문서의 사본을 자동으로 보관하는 `HTTP 장치`다.**  
어떻개 캐시가 성능을 개선하고 비용을 줄이늕, 어떻게 그 효과를 측정하는지, 그리고 효과를 극대화하기 위해 캐시를 어디에 위치시켜야하는지, HTTP 캐시된 사본을 어떻게 동기화하는지 알아보자.  
  
여러 클라이언트가 자원을 한 서버에게 요청한다면, 서버는 각각 한 번씩 응답하게 될 것이다.  
똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동하는 것이다.  
이런 **불필요한 데이터 전송**은 `네트워크 대역폭`을 잡아먹고, `전송을 느리게`만들며, `웹 서버에 부하`를 준다.  
  
캐시를 적용하게 되면 **병목을 줄여주며**, 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.  
- 클라이언트들이 서버에 접근할 떄의 속도는 **그 경로에 있는 가장 느린 네트워크의 속도와 같다.**
  
갑작스럽게 요청이 많이 몰리거나 거리로 인한 지연으로 인해 네트워크와 웹 서버의 심각한 장애를 야기할 수 있다.  

> 모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다.  
> 신호는 빛의 속도보다 약간 느리게 이동하므로 거리로 인한 지연은 더 클 것이다.  

## 적중과 부적중

HTTP는 서버로 부터 전체 객체를 가져오지 않고도 `신선도 검사`를 빠르게 확인할 수 있는 특별한 요청을 정의했다. (뒷 장에서 알아보자)
캐시는 유용하지만, **캐시가 세상 모든 문서의 사본을 저장하지는 않는다.**  
이로인해 `cache hit`가 될수도, `cache miss`가 일어날 수도 있다.  

### 재검사 `Revalidation`

원 서버 콘텐츠는 변경될 수 있기 때문에, **캐싱되어 있는 사본이 최신인지 서버를 통해 때때로 확인을 해야 한다.**  
이러한 `신선도 검사`를 **HTTP 재검사**라 부른다.  

> 캐시는 스스로 원한다면 언제든지 사본을 재검사할 수 있다.  
> 하지만, 캐시가 문서를 수백만 개씩 갖고 있는 경우가 흔하여  
> **대부분의 캐시는 클라이언트가 사본을 요청하였을 때 그 사본이 검사가 필요할 만큼 오래되었을 경우를 확인하고 재검사를 한다.**  
> 콘텐츠가 변경되지 않았다면 `304 Not Modified` 응답을 보낸다.
    
HTTP는 캐시된 객체를 재확인하기 위한 몇 가지 도구를 제공하는데, 그중에서 가장 많이 쓰이는 것은 `If-Modified-Since`헤더다.  
`GET` 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미가 된다.  
이때 서버는

1. **재검사 적중** : `304 Not Modified`로 응답
2. **재검사 부적중** : 만약 서버 객체가 캐시된 사본과 다르다면, **서버는 콘텐츠 전체와 함께 200 OK로 응답한다.**
3. **객체 삭제** : 콘텐츠가 존재하지 않는다면 `404 Not Found`로 응답하며, 클라이언트 캐시는 사본을 삭제한다.

### 적중률

캐시가 요청을 처리하는 비율을 **캐시 적중률 (캐시 적중비)**, **문서 적중률 (문서 적중비)**라고 부른다.  

> 적중률이 **40%** 정도라면 웹 캐시로 괜찮은 편이다.

**얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다.**  
트랜잭션은 고정된 소요 시간을 포함하기 때문에, 해당 적중률을 개선하면 전체 대기시간이 줄어든다.

### 바이트 적중률

문서들이 모두 같은 크기인 것은 아니기 때문에 적중률만으로는 정확한 확인을 할 수 없다.  
**바이트 단위 적중률**은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.  
- 트래픽이 절감된 정도를 포착해낸다.
- **대역폭 절약을 최적화한다.**

### 적중과 부적중의 구별

**HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 원 서버 접근이었는지 확인할 수 있는 방법을 제공하지 않는다.**  
- 두 경우 모두 응답 코드는 `200 OK`가 될 것이다.
  
**클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 응답의 `Date 헤더`를 이용하여 현재 시각보다 응답의 생성일이 더 오래 되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다.**  
또는 `Age 헤더`를 확인하여 응답이 얼마나 오래 되었는지 확인할 수 있다.  

## 캐시 토폴로지

캐시는 한 명의 사용자에게만 할당될 수도 있고, 반대로 수천 명의 사용자들 간에 공유될 수도 있다.  

### 개인 전용 캐시 (private cache)

**웹 브라우저는 개인 전용 캐시를 내장하고 있다.**  
자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.  

### 공용 프록시 캐시 (public cache)

**캐시 프록시 서버**라고 불리는 **특별한 종류의 공유된 프록시 서버다.**  
로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근한다.  

### 프록시 캐시 계층들

**작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 `남겨진 트래픽`을 처리하도록 계층을 만드는 방식이 합리적인 경우가 많다.**  

![](imgs/cacheLayer.png)

하지만 **캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 되어, 각 중간 프록시는 성능 저하가 발생**하기 떄문에 스스로 제한한다.  

### 캐시망, 컨텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 **복잡한 캐시망**을 만든다.  
각각의 프록시 캐시는 동적으로 대화한다.  
- 어떤 부모 캐시와 대화할 것인지
- 요청이 캐시를 완전히 우회할지

선택적인 피어링을 지원하는 캐시는 **형제 캐시**라고 불린다.  
- HTTP는 형제 캐시를 지원하지 않기 떄문에, `인터넷 캐시 프로토콜 ICP`와 `하이퍼텍스트 캐시 프로토콜 HTCP` 같은 프로토콜을 이용해 HTTP를 확장했다. (20장에서 자세히)

## 캐시 처리의 7단계

오늘날 상용 프록시 캐시는 꽤 복잡하고 고성능이며, HTTP와 그외 다른 기술의 고급 기능을 지원하도록 만들어졌다.  
하지만 **웹 캐시의 기본적인 동작은 `HTTP GET 메시지` 하나를 처리하는 일곱 단계로 정의된다.**  

![](imgs/cacheHitProcess.png)

1. **요청 받기** : 네트워크로부터 도착한 요청 메시지를 읽는다.
   1. 고성능 캐시는 여러 개의 커넥션들로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다.
2. **파싱** : 메시지를 파싱하여 URL과 헤더들을 추출한다.
3. **검색** : 로컬 복사본이 있는지 검사하고, 없다면 사본을 받아와 로컬에 저장한다.
   1. 캐시는 URL을 알아내고 그에 해당하는 로컬 사본을 확인한다.
   2. 문서를 로컬에서 가져올 수 없다면, 원 서버나 부모 프록시에서 가져오거나 실패를 반환한다.
4. **신선도 검사** : 사본이 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.
5. **응답 생성** : 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
   1. 캐시된 응답을 **원 서버에서 온 것처럼 보이게 하기 위해, 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다.**
   2. 이 `기저 헤더`들은 캐시에 의해 수정되고 늘어난다. (`Cache-Control`, `Age`, `Expires`, `Via`)
   3. `Date`헤더는 조정해서는 안된다.
6. **발송** : 응답을 클라이언트에게 돌려준다.
   1. 프록시 캐시는 클라이언트와의 커넥션을 유지해야 한다.
7. **로깅** : 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다.


## 사본을 신선하게 유지하기

### 문서 만료, 유효기간과 나이

HTTP는 `Cache-Control`과 `Expires`라는 특별한 헤더들을 이용해 **원 서버가 각 문서에 유효기간을 설정할 수 있게 해준다.**  
- [`ZeroCho` 알아둬야 할 HTTP 쿠키 & 캐시 헤더](https://www.zerocho.com/category/HTTP/post/5b594dd3c06fa2001b89feb9)

### 서버 재검사

원 서버에게 문서가 변경되었는지 확인해야 할 필요가 있음을 의미한다.  

### 조건부 메서드와의 재검사

HTTP는 캐시가 서버에게 `조건부 GET` 이라는 요청을 보낼 수 있도록 해준다.  
이 요청은 **서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것이다.**  
웹 서버는 위의 조건이 참인 경우에만 객체를 반환한다.  
  
**모든 조건부 헤더는 `If-` 접두어로 시작하며, HTTP는 다섯 가지 조건부 요청 헤더를 정의한다.**  

### If-Modified-Since: 날짜 재검사

재검사 요청은 흔히 `IMS` 요청이라고 불리며, **서버에게 리소스가 이 날짜에 마지막 변경이 일어난 것이 아닌 경우에만 요청한 본문을 보내달라고 한다.**  
위의 조건이 참이면 `GET 요청`은 평범하게 성공하고, 거짓이라면 효율을 위해 본문은 보내지 않고 `304 Not Modified`를 응답한다.  
  
`If-Modified-Since`헤더는 서버 응답 헤더의 `Last-Modified` 헤더와 함께 동작한다.  

### If-None-Match : 엔티티 태그 재검사

다음과 같이 최근 변경 일시 재검사를 확인하기 힘든 경우가 있다.  
- 최근 변경 일시를 판별하기 힘들거나
- 간단한 주석이나 의미없는 수정이거나
- 각 문서들의 캐시 정밀도 특성들
  
`If-None-Match`헤더를 통해 버전 값(ex `v2.6`)을 넣고 `GET 요청`을 한다면 해당 버전이 아닌 경우에만 사본을 요청할 수 있다.  
요청 버전과 다르다면 새로운 `ETag`와 함께 반환할 것이다.  
- 여러 개의 엔티티 태그를 보낼 수 있다.
- `W/`를 통해 기준이 꽤 약한 검사기를 구분한다.

## 캐시 제어

HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 응답 헤더를 설정할 수 있는 여러가지 방법이 있다.  
우선순위대로 나열해보면

1. `Cache-Control: no-store`
2. `Cache-Control: no-cache`
3. `Cache-Control: must-revalidate`
4. `Cache-Control: max-age`
5. `Expires`
6. 아무 만료 정보도 주지않고, 캐시가 스스로 결정하게 할 수 있다.

### no-cache와 no-store 응답 헤더

**캐시가 검증되지 않은 개시된 객체로 응답하는 것을 막는다.**  
- `no-store` : 캐시가 그 응답의 사본을 만드는 것을 금지한다.
- `no-cache` : 로컬 캐시 저장소에 저장될 수 있지만, **서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.**
- `Pragma: no-cache` : HTTP/1.0+ 와의 하위호환성을 위해 HTTP/1.1에 포함되어 있다.
  - HTTP/1.0 애플리케이션에 대응해야하는 경우가 아니라면 `Cache-Control: no-cache`를 사용해야 한다.

### Max-Age 응답 헤더

신선하다고 간주되었던 문서가 서버로부터 온 이후로 **흐른 시간**이고, 초로 나타낸다.  
또한 `s-maxage`헤더도 `max-age`처럼 행동하지만 **공유된(공용) 캐시에만 적용**된다.  
- `Cache-Control: max-age=3600`
- `Cache-Control: s-maxage=3600`
  
`maximum aging`을 0으로 설정하여, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.  

### Expires 응답 헤더

**초 단위의 시간 대신 실제 만료 날짜를 명시한다.**  
만료를 절대시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단되어, `Expires`헤더는 더 이상 사용하지 않기를 권장한다.  
- `Expries: Fri, 05 Jul 2002, 05:00:00 GMT`

### Must-Revalidate 응답 헤더

**캐시는 성능을 개선하기 위해 신선하지 않은(만료된) 객체를 제공하도록 설정될 수 있다.**  
만료 정보를 엄격하게 확인하길 원한다면, 원 서버는 `Cache-Control: must-revalidate`를 사용할 수 있다.  
  
사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미하며, 이때 원 서버가 사용할 수 없는 상태라면 `504 Gateway Timeout Error`를 반환해야 한다.  

### 휴리스틱 만료

응답이 `Cache-Control: max-age`헤더나 `Expires`헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인 방법(`humetric`)으로 최대 나이를 계산한다.  
**계산 결과 얻은 최대 나이 값이 24시간 보다 크다면, Heuristic Expriation 경고(경고 13)헤더가 응답 헤더에 추가되어야 한다.**  

> 휴리스틱 신선도 계산은 생각보다 흔히 하게 되는 일이다.  
> 많은 원 서버들이 아직도 `Expires`와 `Max-Age`헤더를 생성하지 못 한다.

### 클라이언트 신선도 제약

**웹브라우저는 브라우저나 프록시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시나 리로드 버튼을 갖고 있다.**  
이 버튼은 `Cache-Control` 요청 헤더가 추가된 GET 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 컨텐츠를 무조건 가져온다.  

- `Cache-Control: max-stale`
- `Cache-Control: min-fresh`
- `Cache-Control: only-if-cached`

## 캐시 제어 설정

웹 서버들은 캐시 제어와 만료 HTTP 헤더들을 설정하는 메커니즘을 제공한다.  
아파치 웹 서버가 캐시 제어를 어떻게 지원하는지 간략하게 알아보자.  

### 아파치로 HTTP 헤더 제어하기

아래와 같은 아파치 확장 모듈이 있다.  

- **mod_headers**
  - 개별 헤더들을 설정할 수 있게 해준다.
  - 개별 HTTP 헤더를 설정할 수 있는 지시어를 이용해 아파치 설정 파일에 설정을 추가할 수 있다.
  - 아파치의 정규표현식과 필터를 사용하여 설정할 수 있다.
- **mod_expires**
  - 적절한 만료 날짜가 담긴 `Expires`헤더를 자동으로 생성하는 프로그램 로직을 제공한다.
  - `access plus 1 month`와 같은 편리한 기술 형식을 사용할 수도 있다.
- **mode_cem_meta**
  - HTTP 헤더들의 파일을 특정 객체와 연결시켜준다.
  - 제어하고자 하는 파일에 각각 대응되는 메타파일들을 생성하게 되므로, 메타파일에 원하는 헤더를 추가하면 된다.

### HTML-EQUIV를 통한 HTML 캐시 제어

HTTP 서버 응답 헤더는 문서의 만료와 캐시 제어 정보를 돌려주기 위해 사용된다.  
저자가 웹 서버 설정 파일과의 상호작용 없이도 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 하기 위해 HTTP 2.0 `META-HTTP-EQUIV` 태그를 정의 했다.  
**이 선택적인 태그는 HTML 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의한다.**  
- 하지만 대부분의 웹 서버나 프록시들 조차 해당 태그를 처리하지 않지만, 클라이언트 캐시는 받아들이는 문제가 있다.

## 캐시 신선도를 계산하는 알고리즘

캐시된 문서가 제공하기에 충분히 신선한지 알려주려면, 캐시는 `캐시된 사본의 나이`와 `신선도 수명`만 계산하면 된다.  
- 만약 캐시된 사본의 나이가 신선도 수명보다 작으면 사본은 제공해주기에 충분히 신선한 것이다.

```
$충분히_신선한가 = ($나이 < $신선도_수명>)
```

**문서의 나이는 서버가 문서를 보낸 (혹은 서버가 마지막으로 재검사 한) 후 그 문서가 나이를 먹은 시간의 총합이다.**  
- `Age`헤더나 `Date`헤더를 통해 계산하여 문서의 나이를 판별해야 한다.
- `Cache-Control: max-stale` 헤더를 사용해서 약간 신선하지 않은 문서도 받아들이려고 할 수 있다.
- `Cache-Control: min-fresh` 헤더를 사용해서 신선하지 않게 될 문서 조차 안받아들이려 할 수 있다.

***

# "8장" 통합점: 게이트웨이, 터널, 릴레이

## 게이트워이

HTTP의 확장과 인터페이스는 사람들의 필요에 따라 발전해왔다.  
**모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것은 분명해졌다.**  
- 리소스를 받기 위한 경로를 안내하는 역할
  
**리소스와 애플리케이션을 연결하는 역할을 한다.**  
게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다.  
  
1. **FTP URL을 가리키는 HTTP 요청을 받게 되면**
   1. 게이트웨이는 FTP 커넥션을 맺고 FTP 서버에 명렁을 전송하여, 클라이언트는 HTTP를 통해서 문서를 받는다.
2. **SSL을 통해 암호화된 웹 요청을 받게 되면**
   1. 요청을 해독해서 생성한 일반 HTTP요청을 목적지 서버로 전달한다.
   2. **원 서버에 고성능 암호화 기능을 제공할 목적으로 웹 서버의 바로 앞단에 위치시킬 수 있다.**
3. **애플리케이션 서버 게이트웨이 API를 통해서 HTTP 클라이언트를 서버 측 애플리케이션 프로그램에 연결하는 경우도 있다.**

### 클라이언트 측 게이트웨이와 서버 측 게이트웨이

웹 게이트웨이 한쪽에서는 HTTP로 통신하고 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.  
클라이언트 측 프로토콜과 서버 측 프로토콜을 `빗금 /`으로 구분해 기술한다.  
- `HTTP/NNTP`
  
## 프로토콜 게이트웨이

프록시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있다.  

### HTTP/* : 서버 측 웹 게이트웨이

**클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.**  

![](imgs/serverSideGateway.png)

게이트웨이는 객체를 받는대로 HTTP 응답에 실어서 클라이언트에게 반환한다.  

### HTTP/HTTPS : 서버 측 보안 게이트웨이

**기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있다.**  

![](imgs/serverSideSSLGateway.png)

### HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이

`HTTPS/HTTP` 게이트웨이는 **보안 가속기**로 유명하다.  
웹 서버 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리거스 프록시 역할을 한다.  
이 게이트웨이는 **HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만든다.**  
  
![](imgs/serverSideHTTPSGateway.png)

- 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야 한다.

## 리소스 게이트웨이

지금까지는 네트워크상에서 클라이언트와 서버를 연결하는 게이트웨이 관해 이야기하였다.  
그러나 가장 일반적인 형태인 **애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합한다.**  

## 터널

우리는 여러 종류의 리소스에 게이트웨이를 통해 접근하거나 애플리케이션 간에 통신하는 데 HTTP를 사용하는 여러 가지 방법에 대해 알아보았다.  
HTTP의 또 다른 사용 방식인 **웹 터널**에 대해 알아보자.  



