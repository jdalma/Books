
# "11장" 클라이언트 식별과 쿠키

**사용자 식별 관련 정보를 전달하는 HTTP 헤더들**  
- `From`            : 사용자의 이메일 주소
- `User-Agent`      : 사용자의 브라우저 정보
- `Referer`         : 사용자가 현재 링크를 타고 온 근원 페이지
- `Authorization`   : 사용자 이름과 비밀번호
- ~~`Client-ip`, `X-Forwarded-For`~~ : 클라이언트 IP , **NAT 또는 ISP, 프록시를 통해서 IP와 포트가 변경되기 때문에 확실하게 식별할 수 없다.**
- `Cookie` 
  
**사용자 로그인 인증을 통한 사용자 식별**  
- 웹 사이트 로그인이 더 쉽도록 HTTP는 `WWW-Authenticate`와 `Authorization` 헤더를 사용해 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.  
  
**URL에 식별자를 포함하는 기술인 뚱뚱한 URL**  
- `사용자의 상태 정보`를 포함하고 있는 URL을 의미한다.
- 특정 식별 번호를 할당하여 URL에 계속 유지시키는 것이다.
- **URL이 달라지기 때문에 캐시를 적용할 수 없다**
  
## 식별 정보를 지속해서 유지하는 쿠키** 📌  

- 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.  
- 브라우저는 쿠키 정보를 저장할 `책임`이 있고, 이 시스템을 **클라이언트 측 상태**라고 한다.
- 쿠키는 크게 `세션 쿠키`와 `지속 쿠키` 두 가지 타입으로 나눌 수 있다.
  - 세션 쿠키 : 사용자가 사이트를 탐색할 때 관련한 설정과 선호 사항들을 저장하는 임시 쿠키, 브라우저를 닫으면 삭제
  - 지속 쿠키 : 사이트에 대한 설정 정보나 로그인 정보를 저장, 클라이언트 디스크에 저장되어 컴퓨터를 재시작하더라도 남아있다.
- 두 가지의 쿠키가 다른 점은 **파기되는 시점**이다.
  - `Discard` 파라미터 또는 `Expires` 혹은 `Max-Age` 파라미터가 없으면 **세션 쿠키**다.
- **브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다.**
  - 보통 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다.
  - 쿠키를 생성한 서버에게만 쿠키를 전달하며, 서버는 쿠키를 생성할 때 **`Set-Cookie` 응답 헤더에 `Domain` 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.**
  - `path` 속성까지 지정해줘서 특정 API에만 쿠키를 전달할 수 있게도 할 수 있다.
  - `secure` 속성은 SSL 보안 연결을 사용할 때만 전송하게 한다.
  
**쿠키와 캐싱**  
쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.  
  
1. **캐시되지 말아야 할 문서가 있다면 표시하라**
   1. 캐시하면 안되는 헤더가 있다면 `Cache-Control: no-cache="Set-Cookie"`와 같이 명시해주어야 한다.
   2. 캐시를 해도 된다면 문서에 `Cache-Control: public`을 사용하자
2. **`Set-Cookie`헤더를 캐시 하는것에 유의하라**
   1. `Cache-Control: must-revalidate, max-age=0`으로 캐시된 문서를 항상 재검사를 시킬 수 있다.
3. **`Cookie`헤더를 가지고 있는 요청을 주의하라**
   1. 개인정보는 캐시되지 않도록 표시해야 하지만, 표시하지 않는 서버도 있다.
   2. 보수적인 캐시는 `Cookie`헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것이다. [질문](https://github.com/SeolYoungKim/http-definitive-guide-study/issues/21)

# "12장" 기본 인증

> 완벽한 인증이란 없다.
  
HTTP는 **인증요구/응답 프레임워크**를 제공한다.  
HTTP에는 `기본 인증`과 `다이제스트 인증`이라는 **두 가지 공식적인 프로토콜**이 있다.  
- OAuth가 해당 프레임워크를 사용하는 인증 프로토콜이다.

1. **인증 요구** `WWW-Authenticate`
   1. 사용자 이름과 비밀번호를 제공하라는 의미로 `401 Unauthorized`응답을 반환한다.
   2. `realm` 속성을 이용해서 보안 영역을 그룹별로 나눌 수 있다.
2. **인증** `Authorization`
   1. 위의 응답을 받은 뒤 사용자 이름과 비밀번호를 기술한 `Authorization` 헤더를 함께 보낸다
3. **성공** `Authentication-Info`
   1. 사용자 정보가 정확하면 (선택적으로) `Authentication-Info`헤더에 인증 세션에 관한 정보를 기술해서 응답한다.
  
프록시에서 인증을 관리할 때는 `407 코드`를 사용하고 `Proxy-`가 접두어로 있는 헤더를 사용할 수 있다.  

# "13장" 다이제스트 인증

기본 인증과 호환되는 더 안전한 대체재로서 개발되었다.  


1. **비밀번호를 안전하게 지키기 위해 요약 사용하기**
   1. `절대로 비밀번호를 네트워크를 통해 보내지 않는다.`
   2. 클라이언트는 비밀번호를 비가역적으로 뒤섞은 `지문`혹은 `요약`을 보낸다.
   3. 비밀번호로 인증하는 것이 아니라 서버가 신원을 알 수 있는 힌트로 인증하는 것
2. **단방향 요약**
   1. `MD5`를 통해 압축한다. 요약 함수는 보통 **암호 체크섬**으로 불린다.
3. **재전송 방지를 위한 nonce 사용**
   1. 악의적인 사용자가 요약을 가로채 서버에 재전송을 하는 경우를 막기 위해 **난스라고 불리는 자주 바뀌는 증표를 추가로 전송한다.**
   2. 난스를 비밀번호에 섞어 난스가 바뀔 때 마다 요약도 바뀌게 만든다.
4. **다이제스트 인증 핸드쉐이크 순서**
   1. 서버는 난스 값을 계산한다.
   2. 서버는 난스 값을 `WWW-Authenticate` 헤더에 담고, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 응답한다.
   3. 클라이언트는 알고리즘을 선택하고 데이터에 대한 요약을 계산하여 `Authentication` 헤더를 작성하고 서버에 요청한다.
   4. 서버는 받은 정보들을 사용하여 그대로 요약을 계산해본 후 클라이언트에게 받은 요약과 비교한다.