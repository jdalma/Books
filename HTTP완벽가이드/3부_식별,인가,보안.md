
# "11장" 클라이언트 식별과 쿠키

**사용자 식별 관련 정보를 전달하는 HTTP 헤더들**  
- `From`            : 사용자의 이메일 주소
- `User-Agent`      : 사용자의 브라우저 정보
- `Referer`         : 사용자가 현재 링크를 타고 온 근원 페이지
- `Authorization`   : 사용자 이름과 비밀번호
- ~~`Client-ip`, `X-Forwarded-For`~~ : 클라이언트 IP , **NAT 또는 ISP, 프록시를 통해서 IP와 포트가 변경되기 때문에 확실하게 식별할 수 없다.**
- `Cookie` 
  
**사용자 로그인 인증을 통한 사용자 식별**  
- 웹 사이트 로그인이 더 쉽도록 HTTP는 `WWW-Authenticate`와 `Authorization` 헤더를 사용해 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.  
  
**URL에 식별자를 포함하는 기술인 뚱뚱한 URL**  
- `사용자의 상태 정보`를 포함하고 있는 URL을 의미한다.
- 특정 식별 번호를 할당하여 URL에 계속 유지시키는 것이다.
- **URL이 달라지기 때문에 캐시를 적용할 수 없다**
  
## 식별 정보를 지속해서 유지하는 쿠키** 📌  

- 쿠키는 캐시와 충돌할 수 있어서, 대부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.  
- 브라우저는 쿠키 정보를 저장할 `책임`이 있고, 이 시스템을 **클라이언트 측 상태**라고 한다.
- 쿠키는 크게 `세션 쿠키`와 `지속 쿠키` 두 가지 타입으로 나눌 수 있다.
  - 세션 쿠키 : 사용자가 사이트를 탐색할 때 관련한 설정과 선호 사항들을 저장하는 임시 쿠키, 브라우저를 닫으면 삭제
  - 지속 쿠키 : 사이트에 대한 설정 정보나 로그인 정보를 저장, 클라이언트 디스크에 저장되어 컴퓨터를 재시작하더라도 남아있다.
- 두 가지의 쿠키가 다른 점은 **파기되는 시점**이다.
  - `Discard` 파라미터 또는 `Expires` 혹은 `Max-Age` 파라미터가 없으면 **세션 쿠키**다.
- **브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다.**
  - 보통 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다.
  - 쿠키를 생성한 서버에게만 쿠키를 전달하며, 서버는 쿠키를 생성할 때 **`Set-Cookie` 응답 헤더에 `Domain` 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.**
  - `path` 속성까지 지정해줘서 특정 API에만 쿠키를 전달할 수 있게도 할 수 있다.
  - `secure` 속성은 SSL 보안 연결을 사용할 때만 전송하게 한다.
  
**쿠키와 캐싱**  
쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다.  
  
1. **캐시되지 말아야 할 문서가 있다면 표시하라**
   1. 캐시하면 안되는 헤더가 있다면 `Cache-Control: no-cache="Set-Cookie"`와 같이 명시해주어야 한다.
   2. 캐시를 해도 된다면 문서에 `Cache-Control: public`을 사용하자
2. **`Set-Cookie`헤더를 캐시 하는것에 유의하라**
   1. `Cache-Control: must-revalidate, max-age=0`으로 캐시된 문서를 항상 재검사를 시킬 수 있다.
3. **`Cookie`헤더를 가지고 있는 요청을 주의하라**
   1. 개인정보는 캐시되지 않도록 표시해야 하지만, 표시하지 않는 서버도 있다.
   2. 보수적인 캐시는 `Cookie`헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것이다. [질문](https://github.com/SeolYoungKim/http-definitive-guide-study/issues/21)

# "12장" 기본 인증

> 완벽한 인증이란 없다.
  
HTTP는 **인증요구/응답 프레임워크**를 제공한다.  

