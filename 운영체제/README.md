
- [`인프런` 운영체제 공룡책 강의](https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98)
- [`KOCW` 반효경 운영체제](http://www.kocw.net/home/search/kemView.do?kemId=1046323)
- [혼자 공부하는 컴퓨터 구조+운영체제](http://www.yes24.com/Product/Goods/111378840)
  - [컴퓨터 구조 몰아보기](https://www.youtube.com/watch?v=kFWP6sFKyp0&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC&index=1&ab_channel=%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%95%EB%AF%BC%EC%B2%A0)
  - [운영체제 몰아보기](https://www.youtube.com/watch?v=isj4sZhoxjk&list=PLYH7OjNUOWLUz15j4Q9M6INxK5J3-59GC&index=2&ab_channel=%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%95%EB%AF%BC%EC%B2%A0)

***

1. 프로세스/쓰레드 생성 : fork()/pthread_create() 함수 등을 호출 -> 라이브러리 단에서 clone 시스템 콜을 호출 -> 커널의 kthread_create() 함수가 호출되어서 커널이 관리할 새로운 task_struct 객체가 만들어짐  
2. 프로세스/쓰레드 런큐 : 어떠어떠한 이유로 프로세스 상태가 run 상태가 됨 -> 커널에 있는 자료구조 중 rq(런큐) 라는 곳에 들어감
3. 스케줄링 : 타이머 인터럽트 발생 -> 인터럽트 핸들러 수행 (이거 과정이 Top/Bottom 하면서 좀 복잡한데 생략합니다) -> 현재 프로세스의 실행 시간을 증가시킴 -> 인터럽트 핸들러 수해잉 마무리되고 기존 실행되고 있던 프로세스로 돌아감 -> 돌아가는 과정에서 현재 프로세스가 선점될 조건인지 판단 -> 선점될 조건이라면 schedule() 함수 실행 -> schedule() 함수에서 pick_next_task() 함수를 호출하여 rq에 있는 프로세스(쓰레드) 중 가장 우선 순위가 높은 태스크를 골라서 다음 태스크로 등록 -> 이 후 실제 프로세스 복귀하는 시점에 기존 프로세스가 다음 태스크로 컨텍스트 스위칭
  
참고로 저 스케줄링 과정 중에 pick_next_task()로 다음 태스크를 꺼내오는 과정에서 스케줄러 루틴이 동작합니다
  
보통 일반적으로 스케줄러라는게 있어서 그 스케줄러가 프로세스를 선택해준다 라고 생각하잖아요?  
그게 아닙니다  
커널에 스케줄링에 필요한 자료구조나 함수(루틴)들이 존재하고, 각각의 프로세스들이 동작하다가 타이머 인터럽트를 기반으로 (사실 다른 트리거들이 더 있긴 하지만) 프로세스 루틴 실행 중에 인터럽트가 발생하면 인터럽트 핸들러로 명령어가 넘어가고, 인터럽트 핸들러가 종료되면 기존 프로세스로 복귀하게 되는데 이 핸들러 넘어가고 복귀하는 과정에서 스케줄링할지를 판단해서 하겠다라고 한다면 기존에 준비되어있던 커널의 자료구조 및 함수들을 불러가지고 스케줄링 알고리즘이 동작하고, 그 결과 선택된 다음 태스크를 현재 태스크와 컨텍스트 스위칭하게 됩니다  
뭔가 스케줄러라는 백그라운드 관리 프로세스같은게 동작하면서 얘가 프로세스를 선택해주는게 아니고, 프로세스 자기 자신이 직접 인터럽트 핸들러와 상호동작하며 다음 프로세스를 선택합니다  