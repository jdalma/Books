
엘라스틱서치를 실제 서비스 환경에 도입해 사용하기 위한 주요 설정과 클러스터 구성 전략에 대해 정리한다.  
노드 역할을 어떻게 지정해야 하는지, 어떤 조합으로 클러스터를 구성해야 하는지 학습할 수 있다.  
그리고 데이터의 기밀성, 무결성을 지키고 인증, 권한 분리를 할 수 있도록 보안 기능을 활성화하는 방법도 학습할 수 있다.  
  
# 노드의 역할

엘라스틱서치의 노드에는 **역할** 이라는 개념이 있으며, 클러스터 구성을 위해 반드시 노드에 역할을 지정해야 한다.  
지정된 역할에 따라 노드가 클러스터 내에서 어떤 작업을 담당할지 정해진다.  
**각 노드는 여러 역할을 수행할 수도 있다.**  
  
1. **마스터 후보(master-eligible) 노드**
   - 노드의 역할에 master를 지정하면 해당 노드는 마스터 후보 노드가 된다.
   - 마스터 후보 노드 중에서 선거를 통해 마스터 노드가 선출된다.
   - 마스터 노드는 인덱스 생성이나 삭제, 어떤 샤드를 어느 노드에 할당할 것인지 등 **클러스터를 관리하는 역할을 수행한다.**
2. **데이터 노드**
   - 실제 데이터를 들고 있는 노드다.
   - CRUD, 검색, 집계와 같이 데이터와 관련된 작업을 수행한다.
3. **인제스트(ingest) 노드**
   - 데이터가 색인되기 전에 전처리를 수행하는 **[인제스트 파이프라인](https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html)** 을 수행하는 노드다.
4. **조정 노드**
   - 클라이언트의 요청을 받아서 다른 노드에 요청을 분배하고 클라이언트에게 최종 응답을 돌려주는 노드를 조정 노드라고 한다.
   - **기본적으로 모든 노드가 조정 역할을 수행한다.**
   - 마스터나 데이터 등 주요 역할을 수행하지 않고 조정 역할만 수행하는 노드는 **조정 전용 노드** 라고 부른다.
5. **원격 클러스터 클라이언트 노드**
   - 다른 엘라스틱서치 클러스터에 클라이언트로 붙을 수 있는 노드다
   - 노드 역할에 `remote_cluster_client`를 추가해 지정하며 키바나의 스택 모니터링 기능을 활용해서 모니터링 전용 클러스터를 구축한 뒤 얼럿 메시지를 보내도록 구성하거나 유료 기능인 클러스터간 검색 기능 등을 활용할 때 사용된다.
7. **데이터 티어 노드**
   - 노드를 용도 및 성능별로 `hot-warm-cold-frozen` 티어로 구분해 저장하는 데이터 티어 구조 채택 시 사용하는 역할이다.

# 설정 정보

```yml
# 노드 역할 지정
# master, data, ingest 등을 0개 이상 조합해 지정한다.
# []와 같이 내용을 비워 두면 조정 전용 노드가 된다.
node.roles: [ master, data ]

cluster.name: test-es
node.name: test-es-node01

# HTTP 통신을 위해 사용하는 포트를 지정하며, 기본값은 9200-9300이다.
# 범위를 지정하면 범위 내의 선점되지 않은 포트 중 가장 앞쪽 포트를 사용한다.
http.port: 9200

# transport 통신을 위해 사용하는 포트를 지정하며, 기본값은 9300-9400이다.
# transport 프로토콜은 엘라스틱서치의 노드 사이의 내부 통신에 사용되는 프로토콜이다.
# 그렇다고 노드 사이의 모든 통신들이 transport를 사용하는 것은 아니며, 일부 HTTP 통신을 하기도 한다.
transport.port: 9300-9400

# 데이터 디렉터리로 pata.data처럼 여러 경로를 지정할 수 있다.
# 주로 여러 디스크를 골고루 사용하기 위해 여러 경로를 지정하는 경우가 많다.
# 하지만 여러 경로를 지정하는 설정은 7.13 버전 부터 지원 중단 선언되었다.
path.data1: /Users/jeonghyeonjun/Desktop/elasticsearch-data/data1
path.data2: /Users/jeonghyeonjun/Desktop/elasticsearch-data/data2
path.logs: /Users/jeonghyeonjun/Desktop/elasticsearch-data/logs

network.host: 10.0.0.1
# 엘라스틱서치에 바인딩할 네트워크 주소를 지정
network.bind_host: 0.0.0.0

# network.publish_host는 클러스터의 다른 노드에게 자신을 알릴 때 쓰는 주소를 지정한다.

# 마스터 노드로 동작할 수 있는 노드 목록을 지정한다.
discovery.seed_hosts: ["10.0.0.1", "10.0.0.2", "some-host-name.net"]

# 클러스터를 처음 기동할 때 첫 마스터 선거를 수행할 후보 노드 목록을 지정한다.
cluster.initial_master_nodes: ["test-es-node01", "test-es-node02", "test-es-node03"]
xpack.security.enabled: false
```

## 힙 크기

첫 번째 대원칙은 **최소한 시스템 메모리의 절반 이하로 지정해야 한다는 것이다.**  
루씬이 커널 시스템 캐시를 많이 활용하기 때문에 시스템 메모리의 절반은 운영체제가 캐시로 쓰도록 놔두는 것이 좋다.  
  
두 번째 대원칙은 **힙 크기를 32GB 이상 지정하지 않아야 한다는 것이다.**  
512GB 이상의 고용량 메모리를 갖춘 서버를 사용하더라도 힙 크기는 32GB 아래로 설정하라고 가이드 한다.  
JVM이 힙 영역에 생성된 객체에 접근하기 위한 포인터를 **Ordinary Object Pointer** 라고 하며 이 OOP는 메모리 주소를 직접 가리킨다.  
  
32비트 환경에서는 포인터 1개를 32비트로, 64비트 환경에서는 포인터 1개를 64비트로 표현한다.  
32비트 환경에서는 4GB 까지 힙 영역을 사용하기 때문에 4GB를 넘어서는 힙 영역을 사용해야 한다면 32비트 OOP로는 불가능하고 64비트 OOP를 사용해야 한다.  
  
하지만 32GB 이내의 힙 영역에만 접근한다면 **Compressed OOP** 라는 기능을 적용해 포인터를 32비트로 유지할 수 있다.  
자바는 기본적으로 힙 영역에 저장하는 객체를 **8바이트 단위로 정렬해 할당** 하기 때문에 객체 간의 주소는 항상 8바이트의 배수만큼 차이가 나기 때문에 적용 가능한 최적화 방법이다.  
따라서 포인터가 메모리의 주소를 직접 가리키도록 하지 않고 객체의 상대적인 위치 차이를 나타내도록 하면 포인터의 1비트가 1바이트 단위의 메모리 주소가 아니라 8바이트 단위의 메모리 주소를 가리키도록 할 수 있다.  
  
## 스와핑

스와핑은 성능과 노드에 큰 영향을 끼치고, 밀리세컨드 단위로 끝나야 할 GC를 분 단위 시간까지 걸리게 만들기 때문에 엘라스틱서치는 스와핑을 사용하지 않도록 강력히 권고한다.  
공식 문서에서는 스와핑을 켜느니 차라리 운영체제가 노드를 kill 시키도록 놔두는 것이 낫다고 가이드 한다.  
  
스와핑을 끄는 방법에 대한 설명은 [공식 문서](https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html#setup-configuration-memory)를 참고하자.  

# 클러스터 구성 전략

1. **마스터 후보 노드와 데이터 노드를 분리**
   - 상대적으로 데이터 노드가 죽을 확률이 높다.
   - 분리된 상황에서 데이터 노드만 죽으면 마스터 노드가 주 샤드가 없어진 샤드의 복제본을 새로운 주 샤드로 변경시키고, 복제본 개수를 새로 채우는 과정을 수행하며 자연스럽게 클러스터가 문제 상황에서 복구된다.
   - 마스터 후보 노드와 데이터 노드를 분리하지 않으면 마스터 재선출 과정과 샤드 복구 과정이 같이 수행되기 때문에 장애 상황에 대응하기에는 리스크가 너무 크다.
   - **마스터 후보 노드는 디스크나 메모리를 많이 필요로 하지 않기 때문에 데이터 노드보다 상대적으로 성능이 많이 낮은 서버를 사용해도 괜찮다.**
2. **마스터 후보 노드와 투표 구성원**
   - 마스터 노드는 클러스터를 관리하는 중요한 역할을 수행한다.
   - 클러스터가 운영되는 동안 항상 마스터 노드가 선출되어 있어야 하며, 이 마스터 노드를 선출하는 집단이 **투표 구성원** 이다.
   - **투표 구성원** : 마스터 후보 노드 중 일부 혹은 전체이며, 마스터 선출이나 클러스터 상태 저장 등의 의사결정에 참여하는 노드의 모임
   - 마스터 후보 노드가 투표 구성원에 참여하거나 제거될 때에는 조정 동작이 발생하며 어느 정도 시간이 소요된다.
   - 마스터 후보 노드의 수를 줄이고 싶다면 한 대씩 클러스터에서 제거하여야 한다.
   - 마스터 후보 노드는 홀수대를 준비하는 것이 비용 대비 효용성이 좋다.
   - [split brain 문제](https://esbook.kimjmin.net/03-cluster/3.3-master-and-data-nodes#split-brain)
3. **서버 자원이 많지 않은 경우**
   - 적어도 마스터 후보 역할을 하는 노드 3대, 데이터 노드 3대가 확보돼야 기본적인 고가용성이 제공되기 때문에 이 시점부터 클러스터를 구성하는 의미가 있다.  
   - 최소한 마스터 후보 역할은 꼭 3대를 지정해야 한다.
4. **서버 자원이 굉장히 많이 필요한 경우**
   - 마스터 후보 노드도 높은 사양의 서버를 할당하거나 노드의 수가 더 늘어나야 한다면 서비스 구조의 복잡도와 관리 비용을 더 높이더라도 강제로 클러스터를 여러 개로 찢어야 한다.
   - 같은 데이터의 싱크를 맞추고 있는 클러스터를 여러 개 구성한 다음 앞단에서 **로드 밸런싱을 하는 전략** , **클러스터별로 데이터를 샤딩하는 전략** , **클러스터 간 검색(cross-cluster search) 도입** 등도 고려해야 한다.
6. **조정 전용 노드**
   - 안정적인 클러스터 운영을 위해서는 조정 전용 노드를 두는 것이 좋다.
   - 각 데이터 노드에서 작업한 결과물을 모아서 돌려주는 작업은 생각보다 큰 부하를 줄 수 있다.
   - 데이터를 들고 있지 않기 때문에 샤드 복구와 관련된 걱정도 없으며 부담없이 프로세스를 Kill 시킬 수 있다.
   - 조정 전용 노드의 읽기 작업과 쓰기 작업을 분리시킬수도 있다.
7. **한 서버에 여러 프로세스 띄우기**
   - 마스터 후보 역할을 하는 프로세스는 다중 프로세스 대상으로 고려하지 말아야 하고 여러 프로세스를 띄우는 대상은 데이터 노드여야 한다.
   
  
> **홀수대의 마스터 후보 노드를 준비하는 것이 좋은 이유**  
> 엘라스틱서치가 투표 구성원을 홀수로 유지하기 위해 투표 구성원에서 마스터 후보 노드를 하나 빼 두기 때문이다.  
> 이 한 대는 투표 구성원에 참여하지 않는다. 마스터 후보 노드가 2k + 1대일 때보다 2k + 2대일 때가 약간 더 안정성이 높기는 하다.  
> 투표 구성원에 포함돼 있던 노드 하나가 죽으면 투표 구성원에는 빠져 있던 나머지 노드가 대신 투표 구성원으로 들어온다.  
> 천천히 한 대씩 순차적으로 죽는 경우라면 1대의 실패를 더 견딜 수 있다.  
> 다만 여러 대가 투표 구성원 조정 전에 동시에 죽는 상황이라면 마스터 후보가 2k + 1대일 때나 2k + 2대일 때나 동일하게 k대의 동시 실패만을 견디기 때문에 홀수대를 준비하는 것이 비용대비 효용성이 좋다.
