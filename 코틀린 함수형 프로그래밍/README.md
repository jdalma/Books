# 1주차. 1장.함수형 프로그래밍 소개, 2장.코틀린으로 함수형 프로그래밍 시작하기

- 카드 결제 성공 시 Coffee를 줌
- 하지만 개선된 버전에서는 결제가 끝나지 않았는데 커피와 결제 객체를 같이 주고있다. (BNPL)
- 실제 결제처리 부수효과는 필연적이다. **따라서 부수효과를 격리해야 한다.**
  - 카드와 원하는 수량을 받아서 청구서를 생성
  - 청구서를 결제하고 그 결과 영수증을 생성
  - 영수증을 바탕으로 커피를 반환함
- 위의 흐름이 오히려 현실 세계와 일치한다. 이 [예제](https://github.com/jdalma/kotlin-playground/blob/main/src/test/kotlin/kotlinfp/_01_%EC%B9%B4%ED%8E%98.kt)를 확인해라
- `in 0..1` : Range 객체는 즐겨써도 무방하다. 컴파일러가 자동으로 효율적으로 변환해준다.
- `inline`을 적극적으로 사용해라

```kotlin
inline val <T> List<T>.tail: List<T> get() = drop(1)
inline val <T> List<T>.head: T get() = first()
```

- 하지만 위의 `head`내부 `first()`는 내부에서 배열이 비어있을 때 예외를 던지기 때문에 순수함수가 아니다.
  - 내부 스펙을 잘 확인해라!!!
- **클로져** = 함수 + 그 함수 안에 있는 자유변수에 값을 제공하기 위한 환경
  - 함수 본문에 그 함수의 파라미터나 지역변수가 아닌 변수가 등장하면 모두 다 자유변수
  - 클로저가 필요한 이유가 자유변수의 값을 알아내려면 환경을 바인딩해줘야 하기 때문이고 그때 어떤 환경을 바인딩해주냐에 따라 정적 스코프와 동적 스코프가 결정된다