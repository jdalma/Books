
# `2023.02.26` 허재 모임 1회차

1. **롤**에 대한 내용을 적어라
2. 기술 스택들도 롤에 엮어서 적어라
   1. 회사에서 사용하는 기술이라도 다루지 않은 기술은 작성하지마라
3. 내가 뭘 했는지에 대해 일목요연하게 작성
5. [한재엽님 이력서](https://jbee.io/about)
6. `AS-IS`에서 `TO-BE`의 이유와 개선점을 명확하게
   1. `Why` + `What` + `How`
7. **키워드**
   1. (CS) 자료구조
   2. (Java) OOP
   3. (Spring) Spring Bean & Container
8. 질문 이슈는 목요일 22시까지 작성
   1. 질문 : 변숭문, 최재형
   2. 답변 : 이정우, 정현준


# `2023.03.05` 허재 모임 2회차

3. **추상화, 캡슐화, 다형성에 대해 알려주세요**
   1. 추상화는 클래스에 대한 공통된 역할과 책임을 추출하는 것이라고 생각한다
   2. `정현준`과 `이승우`라는 객체가 존재한다면 사람으로 추상화 할 수 있다
   3. 위의 예시에서 다형성을 적용한다면 호출자가 `정현준`과 `이승우`라는 객체의 메소드를 직접 호출하지 않고 `사람`이라는 추상화된 객체로 호출하여 동적 디스패치를 통해 실행시킬 수 있다.
   4. 캡슐화는 클래스의 외부, 내부를 분리하여 호출자는 내부를 신경쓰지 않고 외부에 노출된 메소드만 신경쓰면된다. 결론은 필드에 대한 접근과 객체가 가진 메소드들을 외부로 노출된 메소드를 통해서만 필드를 조작하거나 계산된 결과를 받을 수 있게 하는 것이다.
4. **상속보다 합성을 활용하라고 하는데, 왜 그런걸까요?**
   1. 상속을 사용하여 공통된 로직을 그대로 사용할 수 있으며, 부모 클래스에서 수정이 일어나도 자식 클래스는 그대로 사용할 수 있다.
   2. 하지만 상속된 클래스간의 관계는 컴파일 시점에 결정되어 추상화와 다형성을 적용하여 런타임 시점에 타입을 정할 수 있게 할 기회가 없다.
   3. 그리고 자식 클래스 생성 시 부모 클래스를 무조건 생성해줘야 해서 결합도가 높아지고, 호출자는 자식 클래스가 상속 받은 부모 클래스의 외부로 노출된 메소드들도 사용할 수 있게 되므로 캡슐화가 깨지게 된다.
5. **애플리케이션에서 변경 부분을 찾아내고 변경되지 않는 부분(중복)을 찾아 분리하고 변경되는 행동을 캡슐화한다. 그 이유는 무엇일까요?**
   1. 수정이 빈번한 영역을 찾아 분리에 성공한다면 OCP를 지키기에 수월하기 때문이다
   2. 예를 들어, 전략 패턴(템플릿-콜백)을 적용하여 수정이 빈번한 영역을 확장하기 쉽게 만들고 호출자가 실행될 기능을 선택해서 호출하게 만들 수 있다
6. **구현보다 인터페이스에 맞춰서 프로그래밍을 하라고 하는데, 왜 인터페이스에 맞춰서 프로그래밍을 해야할까요?**
   1. 인터페이스 기준으로 프로그래밍을 한다는 것은 위에서 말한 추상화,캡슐화,다형성에서 소개한 내용과 비슷한 것 같다.
   2. 인터페이스에 선언된 기준으로 구현한다면 호출자는 인터페이스에 선언된 규격대로만 사용하면 되기 때문이다.
7. **MVC 아키텍쳐의 컴포넌트 역할을 설명하시오**
   1. 요청에 대한 응답을 반환해야할 때 생기는 책임과 역할을 분리하기 위한 것으로 생각한다.
   2. 컨트롤러가 사용자의 요청을 받아 데이터를 어떻게 가공(모델)해서 어떤 화면을 보여줄 것인지(뷰) 선택하는 것 같다.
8. **RESTful API란?**
   1. REST의 설계 규칙을 잘 지켜서 설계된 API를 RESTful하다고 한다.
   2. REST는 네트워크 메소드로 API의 행위를 드러내고 자원을 URI 경로로 표현하는 것이다.
   3. 결론은 API명세에 대한 설계 표준을 정하여 API명세서만 보아도 의도를 한 눈에 볼 수 있도록 하는 것이 아닐까 싶다.


**피드백**
1. 답변을 할 때 다음 질문을 유도하는 자세가 필요하다
2. 준비가 안된 모습이 보이고, **답변을 일목요연하게 정리하고 대답해야 한다.**

# `2023.03.19` 허재 모임 3회차

1. `@Transactional`
2. 멀티 모듈과 MSA, Redis를 활용한 분산 락에 대한 개념

***

**CS**  
1. 뮤텍스와 세마포어의 적용 대상
2. CPU L1, L2가 비어질 때가 언젠지
3. 한 기술에 대한 시간 복잡도와 개선점을 고민하기
4. 컴파일러와 인터프리터의 차이점
5. 질문을 작성할 때 꼬리질문까지 준비하기
  
**DB**  
1. 인덱스가 걸려있으면 삽입,삭제할 때 정렬을 해야 해서 성능상 이슈가 있다.
2. B+Tree인덱스, 해시 인덱스는 서로 다르다
   1. 전반검색, 범위검색이 안된다
3. 테이블 데이터 기준 20~25%를 초과한다면 인덱스를 안태우는게 좋다

***

# `2023.03.26` 허재 모임 4회차

1. SRP 와 DIP 에 대해 설명하시오.
   1. SRP
      1. 단일책임원칙이다.
      2. **객체는 단 하나의 책임만 가지게 해야한다.**  
      3. 해당 원칙을 잘 지켰는지에 대한 척도는 **수정이 일어났을 떄의 파급 효과**이다.
      4. 한 책임의 변경으로 인한 다른 책임이 변경하는 연쇄작용을 방지할 수 있다.
   2. DIP
      1. 의존역전원칙이다.
      2. 객체에서 다른 클래스를 참조해서 사용해야하는 상황이 생긴다면, 직접 참조하는 것이 아니라 **그 대상의 상위 요소로 참조하라**는 원칙이다.
      3. 하위 클래스를 직접 인스턴스로 가져다 쓰지 마라는 뜻이다.
      4. 추상화되어 있지 않은 클래스를 직접 사용하게 된다면 참조하는 클래스에 의존하게 되기 때문이다.
2. 불변객체와 일급객체에 대해 설명하시오
   1. 가변 객체에 대한 불변 참조 보단 **불변 객체애 대한 가변 참조**를 지향해야한다.
   2. **불변객체**
      1. 불변객체는 객체가 한 번 생성되었다면 
         1. 필드들을 외부나 내부에서 마음대로 수정하지 않게 하고,
         2. 사이드 이펙트를 만들지 않게 하고, (반환은 void지만 파라미터를 가공하는 작업 등등)
         3. 방어적 복사를 통해 데이터들의 일관성을 유지해야 한다
      2. 수정이 일어난다면 그만큼 객체 복사나 생성을 많이하겠지만, [애일리어싱 버그](https://martinfowler.com/bliki/AliasingBug.html)를 방지할 수 있다.
   3. **일급객체**
      1. 함수형 인터페이스와 람다를 일급객체라고 볼 수 있지 않을까
3. N+1 문제에 대해 설명하시오
   1. [N+1 문제 해결](https://github.com/jdalma/footprints/blob/main/JPA/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EB%A7%A4%ED%95%91.md#n--1-%EB%AC%B8%EC%A0%9C)
   2. 테이블간 관계가 성립될 때 연관관계의 주인을 참조하는 다른 테이블의 여러 행만큼 조회 쿼리가 발생하는 문제
4. 동일한 애플리케이션의 N 개의 인스턴스가 같은 DB 를 바라보고 처리해야할 때, 동시성 문제를 해결할 수 있는 방법을 제시해보시오.
   1. DB 레벨
      1. 비관적 락, 낙관적 락, 원자적 연산
   2. Redis의 라이브러리
      1. Lettuce
         1. spin lock 방식
         2. 단점
            1. 무한 루프를 돌며 최대한 다른 스레드에게 CPU를 양보하지 않는다
            2. 다른 스레드가 락을 오래가지고 있는다면 다른 블록킹된 스레드는 CPU를 쓸데 없이 낭비한다
         3. 장점 : 문맥 교환을 줄여 CPU의 부담을 덜어준다
         4. 락을 획득하기 위해 계속 재시도를 한다
         5. 재시도 로직을 추가 작성하여야 한다
         6. Redis에 부하가 갈 수 있다
      2. Redisson
         1. pub-sub 방식
         2. 별도의 재시작 로직을 작성하지 않아도 된다
         3. 자신이 점유하고 있는 락을 해제할 때 같은 채널에 있는 스레드에게 락을 획득하라고 말한다